name: CI - Incremental Bitmap Plugin

on:
  workflow_dispatch:
    inputs:
      run_real_tests:
        description: "Run real-environment tests (USE_MOCK=OFF, E2E_TDENGINE_REAL_TESTS=ON)"
        type: boolean
        default: false
      build_type:
        description: "CMake build type"
        required: false
        default: Debug
        type: choice
        options: [Debug, Release]
  push:
    branches: [ main, develop ]
    paths:
      - 'plugins/incremental_bitmap/**'
  pull_request:
    branches: [ main, develop ]
    paths:
      - 'plugins/incremental_bitmap/**'

env:
  BUILD_TYPE: Debug
  PLUGIN_DIR: plugins/incremental_bitmap

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        compiler: [gcc, clang]
        build_type: [Debug, Release]
        exclude:
          - compiler: clang
            build_type: Debug  # å‡å°‘é‡å¤æž„å»º

    outputs:
      build_type: ${{ matrix.build_type }}
      compiler: ${{ matrix.compiler }}
      run_real_tests: ${{ steps.setup-env.outputs.run_real_tests }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup environment
      id: setup-env
      run: |
        echo "PLUGIN_DIR=${{ env.PLUGIN_DIR }}" >> $GITHUB_ENV
        echo "BUILD_TYPE=${{ github.event_name == 'workflow_dispatch' && github.event.inputs.build_type || matrix.build_type }}" >> $GITHUB_ENV
        echo "CC=${{ matrix.compiler }}" >> $GITHUB_ENV
        # Detect whether to run real tests (only when manually dispatched with run_real_tests=true)
        if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.run_real_tests }}" = "true" ]; then
          echo "RUN_REAL_TESTS=true" >> $GITHUB_ENV
          echo "run_real_tests=true" >> $GITHUB_OUTPUT
        else
          echo "RUN_REAL_TESTS=false" >> $GITHUB_ENV
          echo "run_real_tests=false" >> $GITHUB_OUTPUT
        fi
        # Use lighter test scale in CI to avoid long runtime for heavy benchmarks
        echo "IB_TEST_SCALE=small" >> $GITHUB_ENV

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          build-essential \
          cmake \
          git \
          valgrind \
          gdb \
          libpthread-stubs0-dev \
          libroaring-dev \
          clang-tidy \
          cppcheck \
          clang-format \
          wget \
          curl

    - name: Configure build
      working-directory: ${{ env.PLUGIN_DIR }}
      run: |
        mkdir -p build
        cd build
        EXTRA_FLAGS=""
        if [ "${{ env.BUILD_TYPE }}" = "Debug" ]; then
          # åœ¨Debugä¸‹å¼€å¯è¦†ç›–çŽ‡ç¼–è¯‘æ ‡å¿—ï¼Œç¡®ä¿lcovæœ‰æ•°æ®
          EXTRA_FLAGS="-DCMAKE_C_FLAGS=--coverage -DCMAKE_EXE_LINKER_FLAGS=--coverage"
        fi
        # è®¾ç½® TDengine ç›¸å…³çŽ¯å¢ƒå˜é‡ï¼ˆå¦‚æžœå¯ç”¨çœŸå®žæµ‹è¯•ï¼‰
        if [ "${{ env.RUN_REAL_TESTS }}" = "true" ]; then
          export TDENGINE_HOME=/usr/local
          export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH
          export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig:$PKG_CONFIG_PATH
        fi
        
        cmake .. \
          -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} \
          -DCMAKE_C_COMPILER=${{ matrix.compiler }} \
          -DBUILD_TESTING=ON \
          -DBUILD_TAOSX_PLUGIN=ON \
          -DUSE_MOCK=${{ env.RUN_REAL_TESTS == 'true' && 'OFF' || 'ON' }} \
          -DE2E_TDENGINE_REAL_TESTS=${{ env.RUN_REAL_TESTS == 'true' && 'ON' || 'OFF' }} \
          $EXTRA_FLAGS

    - name: Build plugin
      working-directory: ${{ env.PLUGIN_DIR }}/build
      run: |
        make -j$(nproc) VERBOSE=1

    # ðŸ”§ ä¿®å¤ï¼šå°†çœŸå®žçŽ¯å¢ƒå‡†å¤‡ç§»åˆ°æµ‹è¯•è¿è¡Œä¹‹å‰
    - name: Install TDengine (only when real tests enabled)
      if: env.RUN_REAL_TESTS == 'true'
      run: |
        echo "=== Installing TDengine for real environment tests ==="
        # å®‰è£… TDengine å®¢æˆ·ç«¯åº“
        wget -O - https://www.taosdata.com/assets-download/3.0/TDengine-client-3.0.6.0-Linux-x64.tar.gz | tar -xz
        sudo cp TDengine-client-3.0.6.0/lib/* /usr/local/lib/
        sudo ldconfig
        echo "export TDENGINE_HOME=/usr/local" >> $GITHUB_ENV
        echo "export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH" >> $GITHUB_ENV

    - name: Prepare real TDengine environment (only when enabled)
      if: env.RUN_REAL_TESTS == 'true'
      working-directory: ${{ env.PLUGIN_DIR }}
      timeout-minutes: 15  # å¢žåŠ è¶…æ—¶æ—¶é—´
      run: |
        echo "=== Preparing TDengine real environment ==="
        # è®¾ç½®çŽ¯å¢ƒå˜é‡
        export TDENGINE_HOME=/usr/local
        export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH
        
        # å°è¯•å¯åŠ¨ TDengine æœåŠ¡ï¼ˆå¦‚æžœå­˜åœ¨ï¼‰
        if command -v systemctl >/dev/null 2>&1; then
          sudo systemctl stop taosd || true
          sudo systemctl start taosd || true
          sudo systemctl status taosd || true
        else
          echo "systemctl not available, skipping service management"
        fi
        
        # è¿è¡Œè®¾ç½®è„šæœ¬
        if [ -x "./setup_tdengine_test.sh" ]; then
          ./setup_tdengine_test.sh || echo "setup_tdengine_test.sh completed with non-zero exit, continuing"
        else
          echo "setup_tdengine_test.sh not found, skipping explicit DB setup"
        fi

    - name: Run tests (with per-test timeout)
      working-directory: ${{ env.PLUGIN_DIR }}/build
      timeout-minutes: ${{ env.RUN_REAL_TESTS == 'true' && 45 || 20 }}  # çœŸå®žçŽ¯å¢ƒæµ‹è¯•éœ€è¦æ›´é•¿æ—¶é—´
      run: |
        # è¿è¡Œæ‰€æœ‰æµ‹è¯•ï¼Œæ·»åŠ é”™è¯¯å¤„ç†
        test_failed=0
        exec_count=0
        for test in test_*; do
          if [ -x "$test" ]; then
            echo "Running test: $test"
            exec_count=$((exec_count+1))
            # è·³è¿‡çœŸå®žçŽ¯å¢ƒç›¸å…³äºŒè¿›åˆ¶ï¼ˆä»…åœ¨æœªå¯ç”¨çœŸå®žæµ‹è¯•æ—¶ï¼‰
            if [ "${RUN_REAL_TESTS}" != "true" ]; then
              if echo "$test" | grep -Eq "(e2e_tdengine_real|offset_semantics_real|offset_semantics_realtime)"; then
                echo "Skipping real-environment test: $test"
                continue
              fi
              # CIé»˜è®¤è·³è¿‡é‡åž‹PITRå®Œæ•´æµç¨‹ï¼Œé¿å…è¶…æ—¶ä¸Žå‡é˜´æ€§
              if echo "$test" | grep -Eq "(^|/)test_pitr_e2e$"; then
                echo "Skipping heavy PITR E2E in CI: $test"
                continue
              fi
            fi
            # ä¸ºå•ä¸ªç”¨ä¾‹å¢žåŠ è¶…æ—¶ï¼ŒçœŸå®žçŽ¯å¢ƒæµ‹è¯•éœ€è¦æ›´é•¿æ—¶é—´
            per_timeout=90
            if [ "${RUN_REAL_TESTS}" = "true" ]; then
              per_timeout=180  # çœŸå®žçŽ¯å¢ƒæµ‹è¯•éœ€è¦æ›´é•¿æ—¶é—´
            fi
            if echo "$test" | grep -Eq "(^|/)test_pitr_e2e_simple$"; then
              per_timeout=$((per_timeout + 60))
            fi
            if ! timeout ${per_timeout}s ./$test; then
              echo "Test $test failed, but continuing..."
              test_failed=1
            fi
          fi
        done
        if [ $exec_count -eq 0 ]; then
          echo "ERROR: No executable test_* binaries found. Failing the job to avoid false green."
          exit 1
        fi
        
        # è¿è¡ŒtaosXæ’ä»¶æµ‹è¯•
        if [ -x "test_taosx_plugin_interface" ]; then
          echo "Running taosX plugin test: test_taosx_plugin_interface"
          if ! ./test_taosx_plugin_interface; then
            echo "taosX plugin test failed, but continuing..."
            test_failed=1
          fi
        else
          echo "taosX plugin test not found"
        fi
        
        # å¦‚æžœæœ‰æµ‹è¯•å¤±è´¥ï¼Œé€€å‡ºï¼ˆç¡®ä¿PRèƒ½å‘çŽ°å¤±è´¥ï¼‰
        if [ $test_failed -eq 1 ]; then
          echo "Some tests failed. Exiting with non-zero code."
          exit 1
        fi

    - name: Run tests with Valgrind (Debug builds only, reduced set)
      working-directory: ${{ env.PLUGIN_DIR }}/build
      if: matrix.build_type == 'Debug'
      timeout-minutes: ${{ env.RUN_REAL_TESTS == 'true' && 30 || 20 }}  # çœŸå®žçŽ¯å¢ƒæµ‹è¯•éœ€è¦æ›´é•¿æ—¶é—´
      run: |
        # ä½¿ç”¨Valgrindè¿è¡Œå…³é”®æµ‹è¯•ï¼ˆç²¾ç®€å­é›†ï¼Œä¸¥æ ¼å•æµ‹120sé™æ—¶ï¼‰
        # æ ¸å¿ƒåŠŸèƒ½ï¼ˆ2é¡¹ï¼‰
        for test in test_bitmap_engine_core test_abstraction_layer; do
          if [ -x "$test" ]; then
            echo "Running core test $test with Valgrind (120s)"
            timeout 120 valgrind --tool=memcheck --leak-check=full --show-leak-kinds=all \
                     --error-exitcode=1 --track-origins=yes ./$test || echo "Valgrind test $test failed or timed out"
          fi
        done
        
        # å¯è§‚æµ‹æ€§/æ’ä»¶ï¼ˆ1é¡¹ï¼Œé€‰å…¶ä¸€ï¼‰
        for test in test_taosx_plugin_interface; do
          if [ -x "$test" ]; then
            echo "Running plugin test $test with Valgrind (120s)"
            timeout 120 valgrind --tool=memcheck --leak-check=full --show-leak-kinds=all \
                     --error-exitcode=1 --track-origins=yes ./$test || echo "Valgrind test $test failed or timed out"
          fi
        done


    - name: Collect test results
      if: always()
      working-directory: ${{ env.PLUGIN_DIR }}/build
      run: |
        # æ”¶é›†æµ‹è¯•ç»“æžœ
        echo "=== Test Results ==="
        ls -la test_* 2>/dev/null || echo "No test files found"
        echo "=== Build Artifacts ==="
        ls -la *.so *.a 2>/dev/null || echo "No libraries found"
        echo "=== taosX Plugin Artifacts ==="
        ls -la *taosx* 2>/dev/null || echo "No taosX plugin artifacts found"
        
        # ç”Ÿæˆæµ‹è¯•ç»“æžœæŠ¥å‘Š
        echo "=== Test Results Summary ==="
        echo "# Test Results Report" > test_results_summary.md
        echo "## Test Execution Summary" >> test_results_summary.md
        echo "- Total test files found: $(ls test_* 2>/dev/null | wc -l)" >> test_results_summary.md
        echo "- Executable test files: $(find . -maxdepth 1 -type f -name 'test_*' -executable | wc -l)" >> test_results_summary.md
        echo "- Build artifacts: $(ls *.so *.a 2>/dev/null | wc -l)" >> test_results_summary.md
        echo "- taosX plugin artifacts: $(ls *taosx* 2>/dev/null | wc -l)" >> test_results_summary.md
        echo "" >> test_results_summary.md
        echo "## Discovered Executable Tests" >> test_results_summary.md
        find . -maxdepth 1 -type f -name 'test_*' -executable | sort | sed 's#^\./#- #g' >> test_results_summary.md
        echo "" >> test_results_summary.md
        echo "## Notes" >> test_results_summary.md
        echo "- Heavy tests (e.g., test_pitr_e2e) are skipped in default CI unless RUN_REAL_TESTS=true." >> test_results_summary.md
        echo "- Real-environment tests are only executed on manual dispatch with run_real_tests=true." >> test_results_summary.md
        
        cat test_results_summary.md

  taosx-plugin-test:
    runs-on: ubuntu-latest
    needs: build-and-test

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          build-essential \
          cmake \
          git \
          libpthread-stubs0-dev \
          libroaring-dev

    - name: Build taosX plugin
      working-directory: ${{ env.PLUGIN_DIR }}
      run: |
        mkdir -p build
        cd build
        cmake .. -DBUILD_TAOSX_PLUGIN=ON
        make taosx_incremental_bitmap_plugin test_taosx_plugin_interface

    - name: Test taosX plugin interface
      working-directory: ${{ env.PLUGIN_DIR }}/build
      timeout-minutes: 10  # æ·»åŠ è¶…æ—¶ä¿æŠ¤
      run: |
        echo "=== taosX Plugin Interface Test ==="
        if [ -x "test_taosx_plugin_interface" ]; then
          echo "Running taosX plugin interface test..."
          ./test_taosx_plugin_interface
          echo "taosX plugin interface test completed successfully"
        else
          echo "ERROR: taosX plugin test executable not found"
          exit 1
        fi

    - name: Verify taosX plugin library
      working-directory: ${{ env.PLUGIN_DIR }}/build
      run: |
        echo "=== taosX Plugin Library Verification ==="
        if [ -f "libtaosx_incremental_bitmap_plugin.so" ]; then
          echo "âœ“ taosX plugin library exists"
          file libtaosx_incremental_bitmap_plugin.so
          ldd libtaosx_incremental_bitmap_plugin.so || echo "Library dependencies:"
        else
          echo "âœ— taosX plugin library not found"
          exit 1
        fi

    - name: Test plugin API compatibility
      working-directory: ${{ env.PLUGIN_DIR }}/build
      run: |
        echo "=== taosX Plugin API Compatibility Test ==="
        # æµ‹è¯•æ’ä»¶APIçš„åŸºæœ¬åŠŸèƒ½
        cat > test_api_compatibility.c << 'EOF'
        #include <dlfcn.h>
        #include <stdio.h>
        #include <stdlib.h>
        
        int main() {
            void *handle = dlopen("./libtaosx_incremental_bitmap_plugin.so", RTLD_LAZY);
            if (!handle) {
                printf("ERROR: Cannot load plugin: %s\n", dlerror());
                return 1;
            }
            
            // æµ‹è¯•åŸºæœ¬APIå‡½æ•°
            typedef const char* (*get_name_func)();
            typedef const char* (*get_version_func)();
            typedef int (*init_func)();
            typedef int (*shutdown_func)();
            
            get_name_func get_name = (get_name_func)dlsym(handle, "taosx_plugin_get_name");
            get_version_func get_version = (get_version_func)dlsym(handle, "taosx_plugin_get_version");
            init_func init = (init_func)dlsym(handle, "taosx_plugin_init");
            shutdown_func shutdown = (shutdown_func)dlsym(handle, "taosx_plugin_shutdown");
            
            if (!get_name || !get_version || !init || !shutdown) {
                printf("ERROR: Required API functions not found\n");
                dlclose(handle);
                return 1;
            }
            
            printf("âœ“ Plugin name: %s\n", get_name());
            printf("âœ“ Plugin version: %s\n", get_version());
            
            if (init() == 0) {
                printf("âœ“ Plugin initialization successful\n");
                shutdown();
                printf("âœ“ Plugin shutdown successful\n");
            } else {
                printf("ERROR: Plugin initialization failed\n");
                dlclose(handle);
                return 1;
            }
            
            dlclose(handle);
            printf("âœ“ All API compatibility tests passed\n");
            return 0;
        }
        EOF
        
        gcc -o test_api_compatibility test_api_compatibility.c -ldl
        ./test_api_compatibility

  static-analysis:
    runs-on: ubuntu-latest
    needs: build-and-test

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install static analysis tools
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          clang-tidy \
          cppcheck \
          clang-format \
          splint

    - name: Run clang-tidy
      working-directory: ${{ env.PLUGIN_DIR }}
      run: |
        # åˆ›å»ºç¼–è¯‘æ•°æ®åº“
        mkdir -p build
        cd build
        cmake .. -DCMAKE_EXPORT_COMPILE_COMMANDS=ON
        
        # è¿è¡Œclang-tidy
        run-clang-tidy -header-filter='.*' -checks='*,-fuchsia-*,-google-*,-zircon-*,-abseil-*,-modernize-use-trailing-return-type' \
                       -p build/ > clang-tidy-report.txt 2>&1 || true
        
        # æ˜¾ç¤ºæŠ¥å‘Š
        cat clang-tidy-report.txt

    - name: Run cppcheck
      working-directory: ${{ env.PLUGIN_DIR }}
      run: |
        cppcheck --enable=all --std=c99 --language=c \
                 --suppress=missingIncludeSystem \
                 --suppress=unusedFunction \
                 --xml --xml-version=2 \
                 src/ include/ > cppcheck-report.xml 2>&1 || true
        
        # æ˜¾ç¤ºæŠ¥å‘Š
        cppcheck --enable=all --std=c99 --language=c \
                 --suppress=missingIncludeSystem \
                 --suppress=unusedFunction \
                 src/ include/

    - name: Check code formatting
      working-directory: ${{ env.PLUGIN_DIR }}
      run: |
        # æ£€æŸ¥ä»£ç æ ¼å¼ï¼Œæ·»åŠ ç›®å½•å­˜åœ¨æ£€æŸ¥
        if [ -d "src" ] && [ -d "include" ]; then
          find src/ include/ -name "*.c" -o -name "*.h" | xargs clang-format --dry-run --Werror
        else
          echo "Source directories not found, skipping format check"
        fi

    - name: Upload static analysis reports
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: static-analysis-reports
        path: |
          ${{ env.PLUGIN_DIR }}/build/clang-tidy-report.txt
          ${{ env.PLUGIN_DIR }}/cppcheck-report.xml

  code-coverage:
    runs-on: ubuntu-latest
    needs: build-and-test
    if: needs.build-and-test.outputs.build_type == 'Debug'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install coverage tools
      run: |
        sudo apt-get update
        sudo apt-get install -y lcov

    - name: Generate coverage report
      working-directory: ${{ env.PLUGIN_DIR }}/build
      run: |
        # ç”Ÿæˆè¦†ç›–çŽ‡æŠ¥å‘Š
        lcov --capture --directory . --output-file coverage.info
        lcov --remove coverage.info '/usr/*' --output-file coverage.info
        lcov --remove coverage.info '*/test/*' --output-file coverage.info
        lcov --list coverage.info

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ${{ env.PLUGIN_DIR }}/build/coverage.info
        flags: unittests
        name: codecov-umbrella

  security-scan:
    runs-on: ubuntu-latest
    needs: build-and-test

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Run security scan
      working-directory: ${{ env.PLUGIN_DIR }}
      run: |
        # ä½¿ç”¨semgrepè¿›è¡Œå®‰å…¨æ‰«æï¼ŒæŒ‡å®šç‰ˆæœ¬
        sudo apt-get update
        sudo apt-get install -y jq python3-pip
        pip install semgrep==1.45.0
        semgrep --config=auto --json --output=semgrep-results.json src/ || true
        
        # æ˜¾ç¤ºç»“æžœ
        if [ -f semgrep-results.json ]; then
          echo "Security scan results:"
          cat semgrep-results.json | jq '.results[] | {rule_id, message, path, start_line}' || echo "No security issues found"
        fi

    - name: Upload security scan results
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: security-scan-results
        path: ${{ env.PLUGIN_DIR }}/semgrep-results.json

  documentation:
    runs-on: ubuntu-latest
    needs: build-and-test

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Check documentation
      working-directory: ${{ env.PLUGIN_DIR }}
      run: |
        # æ£€æŸ¥æ–‡æ¡£å®Œæ•´æ€§
        echo "=== Documentation Check ==="
        
        # æ£€æŸ¥å¿…è¦æ–‡æ¡£æ˜¯å¦å­˜åœ¨
        required_docs=(
          "README.md"
          "docs/installation_guide.md"
          "docs/api_usage_guide.md"
          "docs/troubleshooting_guide.md"
          "docs/observability_metrics.md"
        )
        
        missing_docs=0
        for doc in "${required_docs[@]}"; do
          if [ -f "$doc" ]; then
            echo "âœ“ $doc exists"
          else
            echo "âœ— $doc missing"
            missing_docs=1
          fi
        done
        
        # æ£€æŸ¥æ–‡æ¡£é“¾æŽ¥
        echo "=== Checking Documentation Links ==="
        if [ -d "docs" ]; then
          find docs/ -name "*.md" -exec grep -l "\[.*\](" {} \; | while read file; do
            echo "Checking links in $file"
            grep -o "\[.*\]([^)]*)" "$file" | while read link; do
              target=$(echo "$link" | sed 's/\[.*\](\([^)]*\))/\1/')
              if [[ "$target" == http* ]]; then
                echo "  External link: $target"
              elif [[ "$target" == \#* ]]; then
                echo "  Anchor link: $target"
              else
                if [ -f "$target" ] || [ -f "$(dirname "$file")/$target" ]; then
                  echo "  âœ“ Internal link: $target"
                else
                  echo "  âœ— Broken internal link: $target in $file"
                  missing_docs=1
                fi
              fi
            done
          done
        fi
        
        if [ $missing_docs -eq 1 ]; then
          echo "Some documentation issues found, but continuing..."
          # exit 1  # å–æ¶ˆæ³¨é‡Šä»¥åœ¨æ–‡æ¡£æ£€æŸ¥å¤±è´¥æ—¶åœæ­¢
        fi

    - name: Generate documentation coverage report
      working-directory: ${{ env.PLUGIN_DIR }}
      run: |
        echo "=== Documentation Coverage Report ===" > doc_coverage.txt
        
        # ç»Ÿè®¡ä»£ç æ–‡ä»¶
        code_files=$(find src/ -name "*.c" -o -name "*.h" 2>/dev/null | wc -l)
        echo "Code files: $code_files" >> doc_coverage.txt
        
        # ç»Ÿè®¡æ–‡æ¡£æ–‡ä»¶
        doc_files=$(find docs/ -name "*.md" 2>/dev/null | wc -l)
        echo "Documentation files: $doc_files" >> doc_coverage.txt
        
        # ç»Ÿè®¡æµ‹è¯•æ–‡ä»¶
        test_files=$(find test/ -name "*.c" 2>/dev/null | wc -l)
        echo "Test files: $test_files" >> doc_coverage.txt
        
        # è®¡ç®—æ–‡æ¡£è¦†ç›–çŽ‡
        total_files=$((code_files + test_files))
        if [ $total_files -gt 0 ]; then
          coverage=$((doc_files * 100 / total_files))
          echo "Documentation coverage: ${coverage}%" >> doc_coverage.txt
        fi
        
        cat doc_coverage.txt

    - name: Upload documentation report
      uses: actions/upload-artifact@v3
      with:
        name: documentation-coverage
        path: ${{ env.PLUGIN_DIR }}/doc_coverage.txt

  performance-benchmark:
    runs-on: ubuntu-latest
    needs: build-and-test
    if: needs.build-and-test.outputs.build_type == 'Release'

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Run performance benchmarks
      working-directory: ${{ env.PLUGIN_DIR }}/build
      timeout-minutes: 15  # æ·»åŠ è¶…æ—¶ä¿æŠ¤
      run: |
        echo "=== Performance Benchmark ==="
        
        # è¿è¡Œæ€§èƒ½æµ‹è¯•ï¼ˆå¦‚æžœæœ‰ï¼‰
        if [ -x "test_performance" ]; then
          echo "Running performance tests..."
          ./test_performance
        else
          echo "No performance test executable found"
        fi
        
        # åŸºæœ¬æ€§èƒ½æ£€æŸ¥
        echo "=== Basic Performance Check ==="
        for test in test_*; do
          if [ -x "$test" ]; then
            echo "Timing $test..."
            time ./$test > /dev/null 2>&1
          fi
        done

  build-artifacts:
    runs-on: ubuntu-latest
    needs: [build-and-test, static-analysis, code-coverage, security-scan, documentation, taosx-plugin-test]
    if: always()

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download all artifacts
      uses: actions/download-artifact@v3
      with:
        path: artifacts/

    - name: Create build summary
      run: |
        echo "=== Build Summary ===" > build_summary.txt
        echo "Build completed at: $(date)" >> build_summary.txt
        echo "" >> build_summary.txt
        
        # æ£€æŸ¥æž„å»ºçŠ¶æ€
        if [ -d "artifacts" ]; then
          echo "Artifacts collected:" >> build_summary.txt
          find artifacts/ -type f >> build_summary.txt
        fi
        
        echo "" >> build_summary.txt
        echo "=== Job Status ===" >> build_summary.txt
        echo "Build and Test: ${{ needs.build-and-test.result }}" >> build_summary.txt
        echo "Static Analysis: ${{ needs.static-analysis.result }}" >> build_summary.txt
        echo "Code Coverage: ${{ needs.code-coverage.result }}" >> build_summary.txt
        echo "Security Scan: ${{ needs.security-scan.result }}" >> build_summary.txt
        echo "Documentation: ${{ needs.documentation.result }}" >> build_summary.txt
        echo "taosX Plugin Test: ${{ needs.taosx-plugin-test.result }}" >> build_summary.txt
        
        cat build_summary.txt

    - name: Upload build summary
      uses: actions/upload-artifact@v3
      with:
        name: build-summary
        path: build_summary.txt

    - name: Comment on PR
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          const summary = fs.readFileSync('build_summary.txt', 'utf8');
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: `## CI Build Summary\n\n\`\`\`\n${summary}\n\`\`\`\n\n[View full logs](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})`
          });
