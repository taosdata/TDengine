# This set of tests is not Perl-compatible. It checks on special features
# of PCRE2's API, error diagnostics, and the compiled code of some patterns.
# It also checks the non-Perl syntax that PCRE2 supports (Python, .NET,
# Oniguruma). There are also some tests where PCRE2 and Perl differ,
# either because PCRE2 can't be compatible, or there is a possible Perl
# bug.

# NOTE: This is a non-UTF set of tests. When UTF support is needed, use
# test 5.

#forbid_utf
#newline_default lf any anycrlf

# Test binary zeroes in the pattern

# /a\0B/ where 0 is a binary zero
/61 5c 00 62/B,hex
------------------------------------------------------------------
        Bra
        a\x00b
        Ket
        End
------------------------------------------------------------------
    a\x{0}b
 0: a\x00b

# /a0b/ where 0 is a binary zero
/61 00 62/B,hex
------------------------------------------------------------------
        Bra
        a\x00b
        Ket
        End
------------------------------------------------------------------
    a\x{0}b
 0: a\x00b

# /(?#B0C)DE/ where 0 is a binary zero
/28 3f 23 42 00 43 29 44 45/B,hex
------------------------------------------------------------------
        Bra
        DE
        Ket
        End
------------------------------------------------------------------
    DE
 0: DE

/(a)b|/I
Capture group count = 1
May match empty string
Subject length lower bound = 0

/abc/I
Capture group count = 0
First code unit = 'a'
Last code unit = 'c'
Subject length lower bound = 3
    abc
 0: abc
    defabc
 0: abc
    abc\=anchored
 0: abc
\= Expect no match
    defabc\=anchored
No match
    ABC
No match

/^abc/I
Capture group count = 0
Compile options: <none>
Overall options: anchored
First code unit = 'a'
Subject length lower bound = 3
    abc
 0: abc
    abc\=anchored
 0: abc
\= Expect no match
    defabc
No match
    defabc\=anchored
No match

/a+bc/I
Capture group count = 0
First code unit = 'a'
Last code unit = 'c'
Subject length lower bound = 3

/a*bc/I
Capture group count = 0
Starting code units: a b 
Last code unit = 'c'
Subject length lower bound = 2

/a{3}bc/I
Capture group count = 0
First code unit = 'a'
Last code unit = 'c'
Subject length lower bound = 5

/(abc|a+z)/I
Capture group count = 1
First code unit = 'a'
Subject length lower bound = 2

/^abc$/I
Capture group count = 0
Compile options: <none>
Overall options: anchored
First code unit = 'a'
Subject length lower bound = 3
    abc
 0: abc
\= Expect no match
    def\nabc
No match

/ab\idef/
Failed: error 103 at offset 3: unrecognized character follows \

/(?X)ab\idef/
Failed: error 111 at offset 2: unrecognized character after (? or (?-

/x{5,4}/
Failed: error 104 at offset 5: numbers out of order in {} quantifier

/z{65536}/
Failed: error 105 at offset 7: number too big in {} quantifier

/[abcd/
Failed: error 106 at offset 5: missing terminating ] for character class

/[\B]/B
Failed: error 107 at offset 2: escape sequence is invalid in character class

/[\R]/B
Failed: error 107 at offset 2: escape sequence is invalid in character class

/[\X]/B
Failed: error 107 at offset 2: escape sequence is invalid in character class

/[z-a]/
Failed: error 108 at offset 3: range out of order in character class

/^*/
Failed: error 109 at offset 1: quantifier does not follow a repeatable item

/(abc/
Failed: error 114 at offset 4: missing closing parenthesis

/(?# abc/
Failed: error 118 at offset 7: missing ) after (?# comment

/(?z)abc/
Failed: error 111 at offset 2: unrecognized character after (? or (?-

/.*b/I
Capture group count = 0
First code unit at start or follows newline
Last code unit = 'b'
Subject length lower bound = 1

/.*?b/I
Capture group count = 0
First code unit at start or follows newline
Last code unit = 'b'
Subject length lower bound = 1

/cat|dog|elephant/I
Capture group count = 0
Starting code units: c d e 
Subject length lower bound = 3
    this sentence eventually mentions a cat
 0: cat
    this sentences rambles on and on for a while and then reaches elephant
 0: elephant

/cat|dog|elephant/I
Capture group count = 0
Starting code units: c d e 
Subject length lower bound = 3
    this sentence eventually mentions a cat
 0: cat
    this sentences rambles on and on for a while and then reaches elephant
 0: elephant

/cat|dog|elephant/Ii
Capture group count = 0
Options: caseless
Starting code units: C D E c d e 
Subject length lower bound = 3
    this sentence eventually mentions a CAT cat
 0: CAT
    this sentences rambles on and on for a while to elephant ElePhant
 0: elephant

/a|[bcd]/I
Capture group count = 0
Starting code units: a b c d 
Subject length lower bound = 1

/(a|[^\dZ])/I
Capture group count = 1
Starting code units: \x00 \x01 \x02 \x03 \x04 \x05 \x06 \x07 \x08 \x09 \x0a 
  \x0b \x0c \x0d \x0e \x0f \x10 \x11 \x12 \x13 \x14 \x15 \x16 \x17 \x18 \x19 
  \x1a \x1b \x1c \x1d \x1e \x1f \x20 ! " # $ % & ' ( ) * + , - . / : ; < = > 
  ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y [ \ ] ^ _ ` a b c d 
  e f g h i j k l m n o p q r s t u v w x y z { | } ~ \x7f \x80 \x81 \x82 \x83 
  \x84 \x85 \x86 \x87 \x88 \x89 \x8a \x8b \x8c \x8d \x8e \x8f \x90 \x91 \x92 
  \x93 \x94 \x95 \x96 \x97 \x98 \x99 \x9a \x9b \x9c \x9d \x9e \x9f \xa0 \xa1 
  \xa2 \xa3 \xa4 \xa5 \xa6 \xa7 \xa8 \xa9 \xaa \xab \xac \xad \xae \xaf \xb0 
  \xb1 \xb2 \xb3 \xb4 \xb5 \xb6 \xb7 \xb8 \xb9 \xba \xbb \xbc \xbd \xbe \xbf 
  \xc0 \xc1 \xc2 \xc3 \xc4 \xc5 \xc6 \xc7 \xc8 \xc9 \xca \xcb \xcc \xcd \xce 
  \xcf \xd0 \xd1 \xd2 \xd3 \xd4 \xd5 \xd6 \xd7 \xd8 \xd9 \xda \xdb \xdc \xdd 
  \xde \xdf \xe0 \xe1 \xe2 \xe3 \xe4 \xe5 \xe6 \xe7 \xe8 \xe9 \xea \xeb \xec 
  \xed \xee \xef \xf0 \xf1 \xf2 \xf3 \xf4 \xf5 \xf6 \xf7 \xf8 \xf9 \xfa \xfb 
  \xfc \xfd \xfe \xff 
Subject length lower bound = 1

/(a|b)*[\s]/I
Capture group count = 1
Starting code units: \x09 \x0a \x0b \x0c \x0d \x20 a b 
Subject length lower bound = 1

/(ab\2)/
Failed: error 115 at offset 4: reference to non-existent subpattern

/{4,5}abc/
Failed: error 109 at offset 4: quantifier does not follow a repeatable item

/(a)(b)(c)\2/I
Capture group count = 3
Max back reference = 2
First code unit = 'a'
Last code unit = 'c'
Subject length lower bound = 4
    abcb
 0: abcb
 1: a
 2: b
 3: c
    abcb\=ovector=0
 0: abcb
 1: a
 2: b
 3: c
    abcb\=ovector=1
Matched, but too many substrings
 0: abcb
    abcb\=ovector=2
Matched, but too many substrings
 0: abcb
 1: a
    abcb\=ovector=3
Matched, but too many substrings
 0: abcb
 1: a
 2: b
    abcb\=ovector=4
 0: abcb
 1: a
 2: b
 3: c

/(a)bc|(a)(b)\2/I
Capture group count = 3
Max back reference = 2
First code unit = 'a'
Subject length lower bound = 3
    abc
 0: abc
 1: a
    abc\=ovector=0
 0: abc
 1: a
    abc\=ovector=1
Matched, but too many substrings
 0: abc
    abc\=ovector=2
 0: abc
 1: a
    aba
 0: aba
 1: <unset>
 2: a
 3: b
    aba\=ovector=0
 0: aba
 1: <unset>
 2: a
 3: b
    aba\=ovector=1
Matched, but too many substrings
 0: aba
    aba\=ovector=2
Matched, but too many substrings
 0: aba
 1: <unset>
    aba\=ovector=3
Matched, but too many substrings
 0: aba
 1: <unset>
 2: a
    aba\=ovector=4
 0: aba
 1: <unset>
 2: a
 3: b

/abc$/I,dollar_endonly
Capture group count = 0
Options: dollar_endonly
First code unit = 'a'
Last code unit = 'c'
Subject length lower bound = 3
    abc
 0: abc
\= Expect no match
    abc\n
No match
    abc\ndef
No match

/(a)(b)(c)(d)(e)\6/
Failed: error 115 at offset 16: reference to non-existent subpattern

/the quick brown fox/I
Capture group count = 0
First code unit = 't'
Last code unit = 'x'
Subject length lower bound = 19
    the quick brown fox
 0: the quick brown fox
    this is a line with the quick brown fox
 0: the quick brown fox

/the quick brown fox/I,anchored
Capture group count = 0
Options: anchored
First code unit = 't'
Subject length lower bound = 19
    the quick brown fox
 0: the quick brown fox
\= Expect no match
    this is a line with the quick brown fox
No match

/ab(?z)cd/
Failed: error 111 at offset 4: unrecognized character after (? or (?-

/^abc|def/I
Capture group count = 0
Starting code units: a d 
Subject length lower bound = 3
    abcdef
 0: abc
    abcdef\=notbol
 0: def

/.*((abc)$|(def))/I
Capture group count = 3
First code unit at start or follows newline
Subject length lower bound = 3
    defabc
 0: defabc
 1: abc
 2: abc
    defabc\=noteol
 0: def
 1: def
 2: <unset>
 3: def

/)/
Failed: error 122 at offset 0: unmatched closing parenthesis

/a[]b/
Failed: error 106 at offset 4: missing terminating ] for character class

/[^aeiou ]{3,}/I
Capture group count = 0
Starting code units: \x00 \x01 \x02 \x03 \x04 \x05 \x06 \x07 \x08 \x09 \x0a 
  \x0b \x0c \x0d \x0e \x0f \x10 \x11 \x12 \x13 \x14 \x15 \x16 \x17 \x18 \x19 
  \x1a \x1b \x1c \x1d \x1e \x1f ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 
  7 8 9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ 
  \ ] ^ _ ` b c d f g h j k l m n p q r s t v w x y z { | } ~ \x7f \x80 \x81 
  \x82 \x83 \x84 \x85 \x86 \x87 \x88 \x89 \x8a \x8b \x8c \x8d \x8e \x8f \x90 
  \x91 \x92 \x93 \x94 \x95 \x96 \x97 \x98 \x99 \x9a \x9b \x9c \x9d \x9e \x9f 
  \xa0 \xa1 \xa2 \xa3 \xa4 \xa5 \xa6 \xa7 \xa8 \xa9 \xaa \xab \xac \xad \xae 
  \xaf \xb0 \xb1 \xb2 \xb3 \xb4 \xb5 \xb6 \xb7 \xb8 \xb9 \xba \xbb \xbc \xbd 
  \xbe \xbf \xc0 \xc1 \xc2 \xc3 \xc4 \xc5 \xc6 \xc7 \xc8 \xc9 \xca \xcb \xcc 
  \xcd \xce \xcf \xd0 \xd1 \xd2 \xd3 \xd4 \xd5 \xd6 \xd7 \xd8 \xd9 \xda \xdb 
  \xdc \xdd \xde \xdf \xe0 \xe1 \xe2 \xe3 \xe4 \xe5 \xe6 \xe7 \xe8 \xe9 \xea 
  \xeb \xec \xed \xee \xef \xf0 \xf1 \xf2 \xf3 \xf4 \xf5 \xf6 \xf7 \xf8 \xf9 
  \xfa \xfb \xfc \xfd \xfe \xff 
Subject length lower bound = 3
    co-processors, and for
 0: -pr

/<.*>/I
Capture group count = 0
First code unit = '<'
Last code unit = '>'
Subject length lower bound = 2
    abc<def>ghi<klm>nop
 0: <def>ghi<klm>

/<.*?>/I
Capture group count = 0
First code unit = '<'
Last code unit = '>'
Subject length lower bound = 2
    abc<def>ghi<klm>nop
 0: <def>

/<.*>/I,ungreedy
Capture group count = 0
Options: ungreedy
First code unit = '<'
Last code unit = '>'
Subject length lower bound = 2
    abc<def>ghi<klm>nop
 0: <def>

/(?U)<.*>/I
Capture group count = 0
First code unit = '<'
Last code unit = '>'
Subject length lower bound = 2
    abc<def>ghi<klm>nop
 0: <def>

/<.*?>/I,ungreedy
Capture group count = 0
Options: ungreedy
First code unit = '<'
Last code unit = '>'
Subject length lower bound = 2
    abc<def>ghi<klm>nop
 0: <def>ghi<klm>

/={3,}/I,ungreedy
Capture group count = 0
Options: ungreedy
First code unit = '='
Last code unit = '='
Subject length lower bound = 3
    abc========def
 0: ===

/(?U)={3,}?/I
Capture group count = 0
First code unit = '='
Last code unit = '='
Subject length lower bound = 3
    abc========def
 0: ========

/(?<!bar|cattle)foo/I
Capture group count = 0
Max lookbehind = 6
First code unit = 'f'
Last code unit = 'o'
Subject length lower bound = 3
    foo
 0: foo
    catfoo
 0: foo
\= Expect no match
    the barfoo
No match
    and cattlefoo
No match

/abc(?<=a+)b/
Failed: error 125 at offset 3: lookbehind assertion is not fixed length

/12345(?<=aaa|b{0,3})b/
Failed: error 125 at offset 5: lookbehind assertion is not fixed length

/(?<!(foo)a\1)bar/

/(?i)abc/I
Capture group count = 0
First code unit = 'a' (caseless)
Last code unit = 'c' (caseless)
Subject length lower bound = 3

/(a|(?m)a)/I
Capture group count = 1
First code unit = 'a'
Subject length lower bound = 1

/(?i)^1234/I
Capture group count = 0
Compile options: <none>
Overall options: anchored
First code unit = '1'
Subject length lower bound = 4

/(^b|(?i)^d)/I
Capture group count = 1
Compile options: <none>
Overall options: anchored
Starting code units: D b d 
Subject length lower bound = 1

/(?s).*/I
Capture group count = 0
May match empty string
Compile options: <none>
Overall options: anchored
Subject length lower bound = 0

/[abcd]/I
Capture group count = 0
Starting code units: a b c d 
Subject length lower bound = 1

/(?i)[abcd]/I
Capture group count = 0
Starting code units: A B C D a b c d 
Subject length lower bound = 1

/(?m)[xy]|(b|c)/I
Capture group count = 1
Starting code units: b c x y 
Subject length lower bound = 1

/(^a|^b)/Im
Capture group count = 1
Options: multiline
First code unit at start or follows newline
Subject length lower bound = 1

/(?i)(^a|^b)/Im
Capture group count = 1
Options: multiline
First code unit at start or follows newline
Subject length lower bound = 1

/(a)(?(1)a|b|c)/
Failed: error 127 at offset 3: conditional subpattern contains more than two branches

/(?(?=a)a|b|c)/
Failed: error 127 at offset 0: conditional subpattern contains more than two branches

/(?(1a)/
Failed: error 124 at offset 4: missing closing parenthesis for condition

/(?(1a))/
Failed: error 124 at offset 4: missing closing parenthesis for condition

/(?(?i))/
Failed: error 128 at offset 2: assertion expected after (?( or (?(?C)

/(?(abc))/
Failed: error 115 at offset 3: reference to non-existent subpattern

/(?(?<ab))/
Failed: error 128 at offset 2: assertion expected after (?( or (?(?C)

/((?s)blah)\s+\1/I
Capture group count = 1
Max back reference = 1
First code unit = 'b'
Last code unit = 'h'
Subject length lower bound = 9

/((?i)blah)\s+\1/I
Capture group count = 1
Max back reference = 1
First code unit = 'b' (caseless)
Last code unit = 'h' (caseless)
Subject length lower bound = 9

/((?i)b)/IB
------------------------------------------------------------------
        Bra
        CBra 1
     /i b
        Ket
        Ket
        End
------------------------------------------------------------------
Capture group count = 1
First code unit = 'b' (caseless)
Subject length lower bound = 1

/(a*b|(?i:c*(?-i)d))/I
Capture group count = 1
Starting code units: C a b c d 
Subject length lower bound = 1

/a$/I
Capture group count = 0
First code unit = 'a'
Subject length lower bound = 1
    a
 0: a
    a\n
 0: a
\= Expect no match
    a\=noteol
No match
    a\n\=noteol
No match

/a$/Im
Capture group count = 0
Options: multiline
First code unit = 'a'
Subject length lower bound = 1
    a
 0: a
    a\n
 0: a
    a\n\=noteol
 0: a
\= Expect no match
    a\=noteol
No match

/\Aabc/Im
Capture group count = 0
Max lookbehind = 1
Compile options: multiline
Overall options: anchored multiline
First code unit = 'a'
Subject length lower bound = 3

/^abc/Im
Capture group count = 0
Options: multiline
First code unit at start or follows newline
Last code unit = 'c'
Subject length lower bound = 3

/^((a+)(?U)([ab]+)(?-U)([bc]+)(\w*))/I
Capture group count = 5
Compile options: <none>
Overall options: anchored
First code unit = 'a'
Subject length lower bound = 3
  aaaaabbbbbcccccdef
 0: aaaaabbbbbcccccdef
 1: aaaaabbbbbcccccdef
 2: aaaaa
 3: b
 4: bbbbccccc
 5: def

/(?<=foo)[ab]/I
Capture group count = 0
Max lookbehind = 3
Starting code units: a b 
Subject length lower bound = 1

/(?<!foo)(alpha|omega)/I
Capture group count = 1
Max lookbehind = 3
Starting code units: a o 
Last code unit = 'a'
Subject length lower bound = 5

/(?!alphabet)[ab]/I
Capture group count = 0
Starting code units: a b 
Subject length lower bound = 1

/(?<=foo\n)^bar/Im
Capture group count = 0
Max lookbehind = 4
Contains explicit CR or LF match
Options: multiline
Last code unit = 'r'
Subject length lower bound = 3
    foo\nbarbar
 0: bar
\= Expect no match
    rhubarb
No match
    barbell
No match
    abc\nbarton
No match

/^(?<=foo\n)bar/Im
Capture group count = 0
Max lookbehind = 4
Contains explicit CR or LF match
Options: multiline
First code unit at start or follows newline
Last code unit = 'r'
Subject length lower bound = 3
    foo\nbarbar
 0: bar
\= Expect no match
    rhubarb
No match
    barbell
No match
    abc\nbarton
No match

/(?>^abc)/Im
Capture group count = 0
Options: multiline
First code unit at start or follows newline
Last code unit = 'c'
Subject length lower bound = 3
    abc
 0: abc
    def\nabc
 0: abc
\= Expect no match
    defabc
No match

/(?<=ab(c+)d)ef/
Failed: error 125 at offset 0: lookbehind assertion is not fixed length

/(?<=ab(?<=c+)d)ef/
Failed: error 125 at offset 6: lookbehind assertion is not fixed length

/(?<=ab(c|de)f)g/
Failed: error 125 at offset 0: lookbehind assertion is not fixed length

/The next three are in testinput2 because they have variable length branches/

/(?<=bullock|donkey)-cart/I
Capture group count = 0
Max lookbehind = 7
First code unit = '-'
Last code unit = 't'
Subject length lower bound = 5
    the bullock-cart
 0: -cart
    a donkey-cart race
 0: -cart
\= Expect no match
    cart
No match
    horse-and-cart
No match

/(?<=ab(?i)x|y|z)/I
Capture group count = 0
Max lookbehind = 3
May match empty string
Subject length lower bound = 0

/(?>.*)(?<=(abcd)|(xyz))/I
Capture group count = 2
Max lookbehind = 4
May match empty string
Subject length lower bound = 0
    alphabetabcd
 0: alphabetabcd
 1: abcd
    endingxyz
 0: endingxyz
 1: <unset>
 2: xyz

/(?<=ab(?i)x(?-i)y|(?i)z|b)ZZ/I
Capture group count = 0
Max lookbehind = 4
First code unit = 'Z'
Last code unit = 'Z'
Subject length lower bound = 2
    abxyZZ
 0: ZZ
    abXyZZ
 0: ZZ
    ZZZ
 0: ZZ
    zZZ
 0: ZZ
    bZZ
 0: ZZ
    BZZ
 0: ZZ
\= Expect no match
    ZZ
No match
    abXYZZ
No match
    zzz
No match
    bzz
No match

/(?<!(foo)a)bar/I
Capture group count = 1
Max lookbehind = 4
First code unit = 'b'
Last code unit = 'r'
Subject length lower bound = 3
    bar
 0: bar
    foobbar
 0: bar
\= Expect no match
    fooabar
No match

# Perl does not fail these two for the final subjects.

/^(xa|=?\1a){2}$/
    xa=xaa
 0: xa=xaa
 1: =xaa
\= Expect no match
    xa=xaaa
No match

/^(xa|=?\1a)+$/
    xa=xaa
 0: xa=xaa
 1: =xaa
\= Expect no match
    xa=xaaa
No match

# These are syntax tests from Perl 5.005

/a[b-a]/
Failed: error 108 at offset 4: range out of order in character class

/a[]b/
Failed: error 106 at offset 4: missing terminating ] for character class

/a[/
Failed: error 106 at offset 2: missing terminating ] for character class

/*a/
Failed: error 109 at offset 0: quantifier does not follow a repeatable item

/(*)b/
Failed: error 109 at offset 1: quantifier does not follow a repeatable item

/abc)/
Failed: error 122 at offset 3: unmatched closing parenthesis

/(abc/
Failed: error 114 at offset 4: missing closing parenthesis

/a**/
Failed: error 109 at offset 2: quantifier does not follow a repeatable item

/)(/
Failed: error 122 at offset 0: unmatched closing parenthesis

/\1/
Failed: error 115 at offset 1: reference to non-existent subpattern

/\2/
Failed: error 115 at offset 1: reference to non-existent subpattern

/(a)|\2/
Failed: error 115 at offset 5: reference to non-existent subpattern

/a[b-a]/Ii
Failed: error 108 at offset 4: range out of order in character class

/a[]b/Ii
Failed: error 106 at offset 4: missing terminating ] for character class

/a[/Ii
Failed: error 106 at offset 2: missing terminating ] for character class

/*a/Ii
Failed: error 109 at offset 0: quantifier does not follow a repeatable item

/(*)b/Ii
Failed: error 109 at offset 1: quantifier does not follow a repeatable item

/abc)/Ii
Failed: error 122 at offset 3: unmatched closing parenthesis

/(abc/Ii
Failed: error 114 at offset 4: missing closing parenthesis

/a**/Ii
Failed: error 109 at offset 2: quantifier does not follow a repeatable item

/)(/Ii
Failed: error 122 at offset 0: unmatched closing parenthesis

/:(?:/
Failed: error 114 at offset 4: missing closing parenthesis

/(?<%)b/
Failed: error 162 at offset 3: subpattern name expected

/a(?{)b/
Failed: error 111 at offset 3: unrecognized character after (? or (?-

/a(?{{})b/
Failed: error 111 at offset 3: unrecognized character after (? or (?-

/a(?{}})b/
Failed: error 111 at offset 3: unrecognized character after (? or (?-

/a(?{"{"})b/
Failed: error 111 at offset 3: unrecognized character after (? or (?-

/a(?{"{"}})b/
Failed: error 111 at offset 3: unrecognized character after (? or (?-

/(?(1?)a|b)/
Failed: error 124 at offset 4: missing closing parenthesis for condition

/[a[:xyz:/
Failed: error 106 at offset 8: missing terminating ] for character class

/(?<=x+)y/
Failed: error 125 at offset 0: lookbehind assertion is not fixed length

/a{37,17}/
Failed: error 104 at offset 7: numbers out of order in {} quantifier

/abc/\
Failed: error 101 at offset 4: \ at end of pattern

/abc/\i
Failed: error 101 at offset 4: \ at end of pattern

/(a)bc(d)/I
Capture group count = 2
First code unit = 'a'
Last code unit = 'd'
Subject length lower bound = 4
    abcd
 0: abcd
 1: a
 2: d
    abcd\=copy=2
 0: abcd
 1: a
 2: d
 2C d (1)
    abcd\=copy=5
 0: abcd
 1: a
 2: d
Copy substring 5 failed (-49): unknown substring

/(.{20})/I
Capture group count = 1
Subject length lower bound = 20
    abcdefghijklmnopqrstuvwxyz
 0: abcdefghijklmnopqrst
 1: abcdefghijklmnopqrst
    abcdefghijklmnopqrstuvwxyz\=copy=1
 0: abcdefghijklmnopqrst
 1: abcdefghijklmnopqrst
 1C abcdefghijklmnopqrst (20)
    abcdefghijklmnopqrstuvwxyz\=get=1
 0: abcdefghijklmnopqrst
 1: abcdefghijklmnopqrst
 1G abcdefghijklmnopqrst (20)

/(.{15})/I
Capture group count = 1
Subject length lower bound = 15
    abcdefghijklmnopqrstuvwxyz
 0: abcdefghijklmno
 1: abcdefghijklmno
    abcdefghijklmnopqrstuvwxyz\=copy=1,get=1
 0: abcdefghijklmno
 1: abcdefghijklmno
 1C abcdefghijklmno (15)
 1G abcdefghijklmno (15)

/(.{16})/I
Capture group count = 1
Subject length lower bound = 16
    abcdefghijklmnopqrstuvwxyz
 0: abcdefghijklmnop
 1: abcdefghijklmnop
    abcdefghijklmnopqrstuvwxyz\=copy=1,get=1,getall
 0: abcdefghijklmnop
 1: abcdefghijklmnop
 1C abcdefghijklmnop (16)
 1G abcdefghijklmnop (16)
 0L abcdefghijklmnop
 1L abcdefghijklmnop

/^(a|(bc))de(f)/I
Capture group count = 3
Compile options: <none>
Overall options: anchored
Starting code units: a b 
Subject length lower bound = 4
    adef\=get=1,get=2,get=3,get=4,getall
 0: adef
 1: a
 2: <unset>
 3: f
 1G a (1)
Get substring 2 failed (-55): requested value is not set
 3G f (1)
Get substring 4 failed (-49): unknown substring
 0L adef
 1L a
 2L 
 3L f
    bcdef\=get=1,get=2,get=3,get=4,getall
 0: bcdef
 1: bc
 2: bc
 3: f
 1G bc (2)
 2G bc (2)
 3G f (1)
Get substring 4 failed (-49): unknown substring
 0L bcdef
 1L bc
 2L bc
 3L f
    adefghijk\=copy=0
 0: adef
 1: a
 2: <unset>
 3: f
 0C adef (4)

/^abc\00def/I
Capture group count = 0
Compile options: <none>
Overall options: anchored
First code unit = 'a'
Subject length lower bound = 7
    abc\00def\=copy=0,getall
 0: abc\x00def
 0C abc\x00def (7)
 0L abc\x00def

/word ((?:[a-zA-Z0-9]+ )((?:[a-zA-Z0-9]+ )((?:[a-zA-Z0-9]+ )((?:[a-zA-Z0-9]+
)((?:[a-zA-Z0-9]+ )((?:[a-zA-Z0-9]+ )((?:[a-zA-Z0-9]+ )((?:[a-zA-Z0-9]+
)?)?)?)?)?)?)?)?)?otherword/I
Capture group count = 8
Contains explicit CR or LF match
First code unit = 'w'
Last code unit = 'd'
Subject length lower bound = 14

/.*X/IB
------------------------------------------------------------------
        Bra
        Any*
        X
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
First code unit at start or follows newline
Last code unit = 'X'
Subject length lower bound = 1

/.*X/IBs
------------------------------------------------------------------
        Bra
        AllAny*
        X
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Compile options: dotall
Overall options: anchored dotall
Last code unit = 'X'
Subject length lower bound = 1

/(.*X|^B)/IB
------------------------------------------------------------------
        Bra
        CBra 1
        Any*
        X
        Alt
        ^
        B
        Ket
        Ket
        End
------------------------------------------------------------------
Capture group count = 1
First code unit at start or follows newline
Subject length lower bound = 1

/(.*X|^B)/IBs
------------------------------------------------------------------
        Bra
        CBra 1
        AllAny*
        X
        Alt
        ^
        B
        Ket
        Ket
        End
------------------------------------------------------------------
Capture group count = 1
Compile options: dotall
Overall options: anchored dotall
Subject length lower bound = 1

/(?s)(.*X|^B)/IB
------------------------------------------------------------------
        Bra
        CBra 1
        AllAny*
        X
        Alt
        ^
        B
        Ket
        Ket
        End
------------------------------------------------------------------
Capture group count = 1
Compile options: <none>
Overall options: anchored
Subject length lower bound = 1

/(?s:.*X|^B)/IB
------------------------------------------------------------------
        Bra
        Bra
        AllAny*
        X
        Alt
        ^
        B
        Ket
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Compile options: <none>
Overall options: anchored
Subject length lower bound = 1

/\Biss\B/I,aftertext
Capture group count = 0
Max lookbehind = 1
First code unit = 'i'
Last code unit = 's'
Subject length lower bound = 3
    Mississippi
 0: iss
 0+ issippi

/iss/I,aftertext,altglobal
Capture group count = 0
First code unit = 'i'
Last code unit = 's'
Subject length lower bound = 3
    Mississippi
 0: iss
 0+ issippi
 0: iss
 0+ ippi

/\Biss\B/I,aftertext,altglobal
Capture group count = 0
Max lookbehind = 1
First code unit = 'i'
Last code unit = 's'
Subject length lower bound = 3
    Mississippi
 0: iss
 0+ issippi

/\Biss\B/Ig,aftertext
Capture group count = 0
Max lookbehind = 1
First code unit = 'i'
Last code unit = 's'
Subject length lower bound = 3
    Mississippi
 0: iss
 0+ issippi
 0: iss
 0+ ippi
\= Expect no match
    Mississippi\=anchored
No match

/(?<=[Ms])iss/Ig,aftertext
Capture group count = 0
Max lookbehind = 1
First code unit = 'i'
Last code unit = 's'
Subject length lower bound = 3
    Mississippi
 0: iss
 0+ issippi
 0: iss
 0+ ippi

/(?<=[Ms])iss/I,aftertext,altglobal
Capture group count = 0
Max lookbehind = 1
First code unit = 'i'
Last code unit = 's'
Subject length lower bound = 3
    Mississippi
 0: iss
 0+ issippi

/^iss/Ig,aftertext
Capture group count = 0
Compile options: <none>
Overall options: anchored
First code unit = 'i'
Subject length lower bound = 3
    ississippi
 0: iss
 0+ issippi

/.*iss/Ig,aftertext
Capture group count = 0
First code unit at start or follows newline
Last code unit = 's'
Subject length lower bound = 3
    abciss\nxyzisspqr
 0: abciss
 0+ \x0axyzisspqr
 0: xyziss
 0+ pqr

/.i./Ig,aftertext
Capture group count = 0
Last code unit = 'i'
Subject length lower bound = 3
    Mississippi
 0: Mis
 0+ sissippi
 0: sis
 0+ sippi
 0: sip
 0+ pi
    Mississippi\=anchored
 0: Mis
 0+ sissippi
 0: sis
 0+ sippi
 0: sip
 0+ pi
    Missouri river
 0: Mis
 0+ souri river
 0: ri 
 0+ river
 0: riv
 0+ er
    Missouri river\=anchored
 0: Mis
 0+ souri river

/^.is/Ig,aftertext
Capture group count = 0
Compile options: <none>
Overall options: anchored
Subject length lower bound = 3
    Mississippi
 0: Mis
 0+ sissippi

/^ab\n/Ig,aftertext
Capture group count = 0
Contains explicit CR or LF match
Compile options: <none>
Overall options: anchored
First code unit = 'a'
Subject length lower bound = 3
    ab\nab\ncd
 0: ab\x0a
 0+ ab\x0acd

/^ab\n/Igm,aftertext
Capture group count = 0
Contains explicit CR or LF match
Options: multiline
First code unit at start or follows newline
Last code unit = \x0a
Subject length lower bound = 3
    ab\nab\ncd
 0: ab\x0a
 0+ ab\x0acd
 0: ab\x0a
 0+ cd

/^/gm,newline=any
    a\rb\nc\r\nxyz\=aftertext
 0: 
 0+ a\x0db\x0ac\x0d\x0axyz
 0: 
 0+ b\x0ac\x0d\x0axyz
 0: 
 0+ c\x0d\x0axyz
 0: 
 0+ xyz

/abc/I
Capture group count = 0
First code unit = 'a'
Last code unit = 'c'
Subject length lower bound = 3

/abc|bac/I
Capture group count = 0
Starting code units: a b 
Last code unit = 'c'
Subject length lower bound = 3

/(abc|bac)/I
Capture group count = 1
Starting code units: a b 
Last code unit = 'c'
Subject length lower bound = 3

/(abc|(c|dc))/I
Capture group count = 2
Starting code units: a c d 
Last code unit = 'c'
Subject length lower bound = 1

/(abc|(d|de)c)/I
Capture group count = 2
Starting code units: a d 
Last code unit = 'c'
Subject length lower bound = 2

/a*/I
Capture group count = 0
May match empty string
Subject length lower bound = 0

/a+/I
Capture group count = 0
First code unit = 'a'
Subject length lower bound = 1

/(baa|a+)/I
Capture group count = 1
Starting code units: a b 
Last code unit = 'a'
Subject length lower bound = 1

/a{0,3}/I
Capture group count = 0
May match empty string
Subject length lower bound = 0

/baa{3,}/I
Capture group count = 0
First code unit = 'b'
Last code unit = 'a'
Subject length lower bound = 5

/"([^\\"]+|\\.)*"/I
Capture group count = 1
First code unit = '"'
Last code unit = '"'
Subject length lower bound = 2

/(abc|ab[cd])/I
Capture group count = 1
First code unit = 'a'
Subject length lower bound = 3

/(a|.)/I
Capture group count = 1
Subject length lower bound = 1

/a|ba|\w/I
Capture group count = 0
Starting code units: 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P 
  Q R S T U V W X Y Z _ a b c d e f g h i j k l m n o p q r s t u v w x y z 
Subject length lower bound = 1

/abc(?=pqr)/I
Capture group count = 0
First code unit = 'a'
Last code unit = 'r'
Subject length lower bound = 3

/...(?<=abc)/I
Capture group count = 0
Max lookbehind = 3
Subject length lower bound = 3

/abc(?!pqr)/I
Capture group count = 0
First code unit = 'a'
Last code unit = 'c'
Subject length lower bound = 3

/ab./I
Capture group count = 0
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 3

/ab[xyz]/I
Capture group count = 0
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 3

/abc*/I
Capture group count = 0
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 2

/ab.c*/I
Capture group count = 0
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 3

/a.c*/I
Capture group count = 0
First code unit = 'a'
Subject length lower bound = 2

/.c*/I
Capture group count = 0
Subject length lower bound = 1

/ac*/I
Capture group count = 0
First code unit = 'a'
Subject length lower bound = 1

/(a.c*|b.c*)/I
Capture group count = 1
Starting code units: a b 
Subject length lower bound = 2

/a.c*|aba/I
Capture group count = 0
First code unit = 'a'
Subject length lower bound = 2

/.+a/I
Capture group count = 0
Last code unit = 'a'
Subject length lower bound = 2

/(?=abcda)a.*/I
Capture group count = 0
First code unit = 'a'
Last code unit = 'a'
Subject length lower bound = 2

/(?=a)a.*/I
Capture group count = 0
First code unit = 'a'
Subject length lower bound = 1

/a(b)*/I
Capture group count = 1
First code unit = 'a'
Subject length lower bound = 1

/a\d*/I
Capture group count = 0
First code unit = 'a'
Subject length lower bound = 1

/ab\d*/I
Capture group count = 0
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 2

/a(\d)*/I
Capture group count = 1
First code unit = 'a'
Subject length lower bound = 1

/abcde{0,0}/I
Capture group count = 0
First code unit = 'a'
Last code unit = 'd'
Subject length lower bound = 4

/ab\d+/I
Capture group count = 0
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 3

/a(?(1)b)(.)/I
Capture group count = 1
Max back reference = 1
First code unit = 'a'
Subject length lower bound = 2

/a(?(1)bag|big)(.)/I
Capture group count = 1
Max back reference = 1
First code unit = 'a'
Last code unit = 'g'
Subject length lower bound = 5

/a(?(1)bag|big)*(.)/I
Capture group count = 1
Max back reference = 1
First code unit = 'a'
Subject length lower bound = 2

/a(?(1)bag|big)+(.)/I
Capture group count = 1
Max back reference = 1
First code unit = 'a'
Last code unit = 'g'
Subject length lower bound = 5

/a(?(1)b..|b..)(.)/I
Capture group count = 1
Max back reference = 1
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 5

/ab\d{0}e/I
Capture group count = 0
First code unit = 'a'
Last code unit = 'e'
Subject length lower bound = 3

/a?b?/I
Capture group count = 0
May match empty string
Subject length lower bound = 0
    a
 0: a
    b
 0: b
    ab
 0: ab
    \
 0: 
\= Expect no match
    \=notempty
No match

/|-/I
Capture group count = 0
May match empty string
Subject length lower bound = 0
    abcd
 0: 
    -abc
 0: 
    ab-c\=notempty
 0: -
\= Expect no match
    abc\=notempty
No match

/^.?abcd/I
Capture group count = 0
Compile options: <none>
Overall options: anchored
Last code unit = 'd'
Subject length lower bound = 4

/\(             # ( at start
  (?:           # Non-capturing bracket
  (?>[^()]+)    # Either a sequence of non-brackets (no backtracking)
  |             # Or
  (?R)          # Recurse - i.e. nested bracketed string
  )*            # Zero or more contents
  \)            # Closing )
  /Ix
Capture group count = 0
Options: extended
First code unit = '('
Last code unit = ')'
Subject length lower bound = 2
    (abcd)
 0: (abcd)
    (abcd)xyz
 0: (abcd)
    xyz(abcd)
 0: (abcd)
    (ab(xy)cd)pqr
 0: (ab(xy)cd)
    (ab(xycd)pqr
 0: (xycd)
    () abc ()
 0: ()
    12(abcde(fsh)xyz(foo(bar))lmno)89
 0: (abcde(fsh)xyz(foo(bar))lmno)
\= Expect no match
    abcd
No match
    abcd)
No match
    (abcd
No match

/\(  ( (?>[^()]+) | (?R) )* \) /Igx
Capture group count = 1
Options: extended
First code unit = '('
Last code unit = ')'
Subject length lower bound = 2
    (ab(xy)cd)pqr
 0: (ab(xy)cd)
 1: cd
    1(abcd)(x(y)z)pqr
 0: (abcd)
 1: abcd
 0: (x(y)z)
 1: z

/\(  (?: (?>[^()]+) | (?R) ) \) /Ix
Capture group count = 0
Options: extended
First code unit = '('
Last code unit = ')'
Subject length lower bound = 3
    (abcd)
 0: (abcd)
    (ab(xy)cd)
 0: (xy)
    (a(b(c)d)e)
 0: (c)
    ((ab))
 0: ((ab))
\= Expect no match
    ()
No match

/\(  (?: (?>[^()]+) | (?R) )? \) /Ix
Capture group count = 0
Options: extended
First code unit = '('
Last code unit = ')'
Subject length lower bound = 2
    ()
 0: ()
    12(abcde(fsh)xyz(foo(bar))lmno)89
 0: (fsh)

/\(  ( (?>[^()]+) | (?R) )* \) /Ix
Capture group count = 1
Options: extended
First code unit = '('
Last code unit = ')'
Subject length lower bound = 2
    (ab(xy)cd)
 0: (ab(xy)cd)
 1: cd

/\( ( ( (?>[^()]+) | (?R) )* ) \) /Ix
Capture group count = 2
Options: extended
First code unit = '('
Last code unit = ')'
Subject length lower bound = 2
    (ab(xy)cd)
 0: (ab(xy)cd)
 1: ab(xy)cd
 2: cd

/\( (123)? ( ( (?>[^()]+) | (?R) )* ) \) /Ix
Capture group count = 3
Options: extended
First code unit = '('
Last code unit = ')'
Subject length lower bound = 2
    (ab(xy)cd)
 0: (ab(xy)cd)
 1: <unset>
 2: ab(xy)cd
 3: cd
    (123ab(xy)cd)
 0: (123ab(xy)cd)
 1: 123
 2: ab(xy)cd
 3: cd

/\( ( (123)? ( (?>[^()]+) | (?R) )* ) \) /Ix
Capture group count = 3
Options: extended
First code unit = '('
Last code unit = ')'
Subject length lower bound = 2
    (ab(xy)cd)
 0: (ab(xy)cd)
 1: ab(xy)cd
 2: <unset>
 3: cd
    (123ab(xy)cd)
 0: (123ab(xy)cd)
 1: 123ab(xy)cd
 2: 123
 3: cd

/\( (((((((((( ( (?>[^()]+) | (?R) )* )))))))))) \) /Ix
Capture group count = 11
Options: extended
First code unit = '('
Last code unit = ')'
Subject length lower bound = 2
    (ab(xy)cd)
 0: (ab(xy)cd)
 1: ab(xy)cd
 2: ab(xy)cd
 3: ab(xy)cd
 4: ab(xy)cd
 5: ab(xy)cd
 6: ab(xy)cd
 7: ab(xy)cd
 8: ab(xy)cd
 9: ab(xy)cd
10: ab(xy)cd
11: cd

/\( ( ( (?>[^()<>]+) | ((?>[^()]+)) | (?R) )* ) \) /Ix
Capture group count = 3
Options: extended
First code unit = '('
Last code unit = ')'
Subject length lower bound = 2
    (abcd(xyz<p>qrs)123)
 0: (abcd(xyz<p>qrs)123)
 1: abcd(xyz<p>qrs)123
 2: 123

/\( ( ( (?>[^()]+) | ((?R)) )* ) \) /Ix
Capture group count = 3
Options: extended
First code unit = '('
Last code unit = ')'
Subject length lower bound = 2
    (ab(cd)ef)
 0: (ab(cd)ef)
 1: ab(cd)ef
 2: ef
 3: (cd)
    (ab(cd(ef)gh)ij)
 0: (ab(cd(ef)gh)ij)
 1: ab(cd(ef)gh)ij
 2: ij
 3: (cd(ef)gh)

/^[[:alnum:]]/IB
------------------------------------------------------------------
        Bra
        ^
        [0-9A-Za-z]
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Compile options: <none>
Overall options: anchored
Starting code units: 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P 
  Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z 
Subject length lower bound = 1

/^[[:^alnum:]]/IB
------------------------------------------------------------------
        Bra
        ^
        [\x00-/:-@[-`{-\xff] (neg)
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Compile options: <none>
Overall options: anchored
Starting code units: \x00 \x01 \x02 \x03 \x04 \x05 \x06 \x07 \x08 \x09 \x0a 
  \x0b \x0c \x0d \x0e \x0f \x10 \x11 \x12 \x13 \x14 \x15 \x16 \x17 \x18 \x19 
  \x1a \x1b \x1c \x1d \x1e \x1f \x20 ! " # $ % & ' ( ) * + , - . / : ; < = > 
  ? @ [ \ ] ^ _ ` { | } ~ \x7f \x80 \x81 \x82 \x83 \x84 \x85 \x86 \x87 \x88 
  \x89 \x8a \x8b \x8c \x8d \x8e \x8f \x90 \x91 \x92 \x93 \x94 \x95 \x96 \x97 
  \x98 \x99 \x9a \x9b \x9c \x9d \x9e \x9f \xa0 \xa1 \xa2 \xa3 \xa4 \xa5 \xa6 
  \xa7 \xa8 \xa9 \xaa \xab \xac \xad \xae \xaf \xb0 \xb1 \xb2 \xb3 \xb4 \xb5 
  \xb6 \xb7 \xb8 \xb9 \xba \xbb \xbc \xbd \xbe \xbf \xc0 \xc1 \xc2 \xc3 \xc4 
  \xc5 \xc6 \xc7 \xc8 \xc9 \xca \xcb \xcc \xcd \xce \xcf \xd0 \xd1 \xd2 \xd3 
  \xd4 \xd5 \xd6 \xd7 \xd8 \xd9 \xda \xdb \xdc \xdd \xde \xdf \xe0 \xe1 \xe2 
  \xe3 \xe4 \xe5 \xe6 \xe7 \xe8 \xe9 \xea \xeb \xec \xed \xee \xef \xf0 \xf1 
  \xf2 \xf3 \xf4 \xf5 \xf6 \xf7 \xf8 \xf9 \xfa \xfb \xfc \xfd \xfe \xff 
Subject length lower bound = 1

/^[[:alpha:]]/IB
------------------------------------------------------------------
        Bra
        ^
        [A-Za-z]
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Compile options: <none>
Overall options: anchored
Starting code units: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 
  a b c d e f g h i j k l m n o p q r s t u v w x y z 
Subject length lower bound = 1

/^[[:^alpha:]]/IB
------------------------------------------------------------------
        Bra
        ^
        [\x00-@[-`{-\xff] (neg)
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Compile options: <none>
Overall options: anchored
Starting code units: \x00 \x01 \x02 \x03 \x04 \x05 \x06 \x07 \x08 \x09 \x0a 
  \x0b \x0c \x0d \x0e \x0f \x10 \x11 \x12 \x13 \x14 \x15 \x16 \x17 \x18 \x19 
  \x1a \x1b \x1c \x1d \x1e \x1f \x20 ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 
  5 6 7 8 9 : ; < = > ? @ [ \ ] ^ _ ` { | } ~ \x7f \x80 \x81 \x82 \x83 \x84 
  \x85 \x86 \x87 \x88 \x89 \x8a \x8b \x8c \x8d \x8e \x8f \x90 \x91 \x92 \x93 
  \x94 \x95 \x96 \x97 \x98 \x99 \x9a \x9b \x9c \x9d \x9e \x9f \xa0 \xa1 \xa2 
  \xa3 \xa4 \xa5 \xa6 \xa7 \xa8 \xa9 \xaa \xab \xac \xad \xae \xaf \xb0 \xb1 
  \xb2 \xb3 \xb4 \xb5 \xb6 \xb7 \xb8 \xb9 \xba \xbb \xbc \xbd \xbe \xbf \xc0 
  \xc1 \xc2 \xc3 \xc4 \xc5 \xc6 \xc7 \xc8 \xc9 \xca \xcb \xcc \xcd \xce \xcf 
  \xd0 \xd1 \xd2 \xd3 \xd4 \xd5 \xd6 \xd7 \xd8 \xd9 \xda \xdb \xdc \xdd \xde 
  \xdf \xe0 \xe1 \xe2 \xe3 \xe4 \xe5 \xe6 \xe7 \xe8 \xe9 \xea \xeb \xec \xed 
  \xee \xef \xf0 \xf1 \xf2 \xf3 \xf4 \xf5 \xf6 \xf7 \xf8 \xf9 \xfa \xfb \xfc 
  \xfd \xfe \xff 
Subject length lower bound = 1

/[_[:alpha:]]/I
Capture group count = 0
Starting code units: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 
  _ a b c d e f g h i j k l m n o p q r s t u v w x y z 
Subject length lower bound = 1

/^[[:ascii:]]/IB
------------------------------------------------------------------
        Bra
        ^
        [\x00-\x7f]
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Compile options: <none>
Overall options: anchored
Starting code units: \x00 \x01 \x02 \x03 \x04 \x05 \x06 \x07 \x08 \x09 \x0a 
  \x0b \x0c \x0d \x0e \x0f \x10 \x11 \x12 \x13 \x14 \x15 \x16 \x17 \x18 \x19 
  \x1a \x1b \x1c \x1d \x1e \x1f \x20 ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 
  5 6 7 8 9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y 
  Z [ \ ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~ 
  \x7f 
Subject length lower bound = 1

/^[[:^ascii:]]/IB
------------------------------------------------------------------
        Bra
        ^
        [\x80-\xff] (neg)
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Compile options: <none>
Overall options: anchored
Starting code units: \x80 \x81 \x82 \x83 \x84 \x85 \x86 \x87 \x88 \x89 \x8a 
  \x8b \x8c \x8d \x8e \x8f \x90 \x91 \x92 \x93 \x94 \x95 \x96 \x97 \x98 \x99 
  \x9a \x9b \x9c \x9d \x9e \x9f \xa0 \xa1 \xa2 \xa3 \xa4 \xa5 \xa6 \xa7 \xa8 
  \xa9 \xaa \xab \xac \xad \xae \xaf \xb0 \xb1 \xb2 \xb3 \xb4 \xb5 \xb6 \xb7 
  \xb8 \xb9 \xba \xbb \xbc \xbd \xbe \xbf \xc0 \xc1 \xc2 \xc3 \xc4 \xc5 \xc6 
  \xc7 \xc8 \xc9 \xca \xcb \xcc \xcd \xce \xcf \xd0 \xd1 \xd2 \xd3 \xd4 \xd5 
  \xd6 \xd7 \xd8 \xd9 \xda \xdb \xdc \xdd \xde \xdf \xe0 \xe1 \xe2 \xe3 \xe4 
  \xe5 \xe6 \xe7 \xe8 \xe9 \xea \xeb \xec \xed \xee \xef \xf0 \xf1 \xf2 \xf3 
  \xf4 \xf5 \xf6 \xf7 \xf8 \xf9 \xfa \xfb \xfc \xfd \xfe \xff 
Subject length lower bound = 1

/^[[:blank:]]/IB
------------------------------------------------------------------
        Bra
        ^
        [\x09 ]
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Compile options: <none>
Overall options: anchored
Starting code units: \x09 \x20 
Subject length lower bound = 1

/^[[:^blank:]]/IB
------------------------------------------------------------------
        Bra
        ^
        [\x00-\x08\x0a-\x1f!-\xff] (neg)
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Compile options: <none>
Overall options: anchored
Starting code units: \x00 \x01 \x02 \x03 \x04 \x05 \x06 \x07 \x08 \x0a \x0b 
  \x0c \x0d \x0e \x0f \x10 \x11 \x12 \x13 \x14 \x15 \x16 \x17 \x18 \x19 \x1a 
  \x1b \x1c \x1d \x1e \x1f ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 
  : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ 
  _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~ \x7f \x80 
  \x81 \x82 \x83 \x84 \x85 \x86 \x87 \x88 \x89 \x8a \x8b \x8c \x8d \x8e \x8f 
  \x90 \x91 \x92 \x93 \x94 \x95 \x96 \x97 \x98 \x99 \x9a \x9b \x9c \x9d \x9e 
  \x9f \xa0 \xa1 \xa2 \xa3 \xa4 \xa5 \xa6 \xa7 \xa8 \xa9 \xaa \xab \xac \xad 
  \xae \xaf \xb0 \xb1 \xb2 \xb3 \xb4 \xb5 \xb6 \xb7 \xb8 \xb9 \xba \xbb \xbc 
  \xbd \xbe \xbf \xc0 \xc1 \xc2 \xc3 \xc4 \xc5 \xc6 \xc7 \xc8 \xc9 \xca \xcb 
  \xcc \xcd \xce \xcf \xd0 \xd1 \xd2 \xd3 \xd4 \xd5 \xd6 \xd7 \xd8 \xd9 \xda 
  \xdb \xdc \xdd \xde \xdf \xe0 \xe1 \xe2 \xe3 \xe4 \xe5 \xe6 \xe7 \xe8 \xe9 
  \xea \xeb \xec \xed \xee \xef \xf0 \xf1 \xf2 \xf3 \xf4 \xf5 \xf6 \xf7 \xf8 
  \xf9 \xfa \xfb \xfc \xfd \xfe \xff 
Subject length lower bound = 1

/[\n\x0b\x0c\x0d[:blank:]]/I
Capture group count = 0
Contains explicit CR or LF match
Starting code units: \x09 \x0a \x0b \x0c \x0d \x20 
Subject length lower bound = 1

/^[[:cntrl:]]/IB
------------------------------------------------------------------
        Bra
        ^
        [\x00-\x1f\x7f]
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Compile options: <none>
Overall options: anchored
Starting code units: \x00 \x01 \x02 \x03 \x04 \x05 \x06 \x07 \x08 \x09 \x0a 
  \x0b \x0c \x0d \x0e \x0f \x10 \x11 \x12 \x13 \x14 \x15 \x16 \x17 \x18 \x19 
  \x1a \x1b \x1c \x1d \x1e \x1f \x7f 
Subject length lower bound = 1

/^[[:digit:]]/IB
------------------------------------------------------------------
        Bra
        ^
        [0-9]
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Compile options: <none>
Overall options: anchored
Starting code units: 0 1 2 3 4 5 6 7 8 9 
Subject length lower bound = 1

/^[[:graph:]]/IB
------------------------------------------------------------------
        Bra
        ^
        [!-~]
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Compile options: <none>
Overall options: anchored
Starting code units: ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : 
  ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ 
  ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~ 
Subject length lower bound = 1

/^[[:lower:]]/IB
------------------------------------------------------------------
        Bra
        ^
        [a-z]
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Compile options: <none>
Overall options: anchored
Starting code units: a b c d e f g h i j k l m n o p q r s t u v w x y z 
Subject length lower bound = 1

/^[[:print:]]/IB
------------------------------------------------------------------
        Bra
        ^
        [ -~]
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Compile options: <none>
Overall options: anchored
Starting code units: \x20 ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 
  9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] 
  ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~ 
Subject length lower bound = 1

/^[[:punct:]]/IB
------------------------------------------------------------------
        Bra
        ^
        [!-/:-@[-`{-~]
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Compile options: <none>
Overall options: anchored
Starting code units: ! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \ ] ^ 
  _ ` { | } ~ 
Subject length lower bound = 1

/^[[:space:]]/IB
------------------------------------------------------------------
        Bra
        ^
        [\x09-\x0d ]
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Compile options: <none>
Overall options: anchored
Starting code units: \x09 \x0a \x0b \x0c \x0d \x20 
Subject length lower bound = 1

/^[[:upper:]]/IB
------------------------------------------------------------------
        Bra
        ^
        [A-Z]
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Compile options: <none>
Overall options: anchored
Starting code units: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 
Subject length lower bound = 1

/^[[:xdigit:]]/IB
------------------------------------------------------------------
        Bra
        ^
        [0-9A-Fa-f]
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Compile options: <none>
Overall options: anchored
Starting code units: 0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f 
Subject length lower bound = 1

/^[[:word:]]/IB
------------------------------------------------------------------
        Bra
        ^
        [0-9A-Z_a-z]
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Compile options: <none>
Overall options: anchored
Starting code units: 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P 
  Q R S T U V W X Y Z _ a b c d e f g h i j k l m n o p q r s t u v w x y z 
Subject length lower bound = 1

/^[[:^cntrl:]]/IB
------------------------------------------------------------------
        Bra
        ^
        [ -~\x80-\xff] (neg)
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Compile options: <none>
Overall options: anchored
Starting code units: \x20 ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 
  9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] 
  ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~ \x80 \x81 
  \x82 \x83 \x84 \x85 \x86 \x87 \x88 \x89 \x8a \x8b \x8c \x8d \x8e \x8f \x90 
  \x91 \x92 \x93 \x94 \x95 \x96 \x97 \x98 \x99 \x9a \x9b \x9c \x9d \x9e \x9f 
  \xa0 \xa1 \xa2 \xa3 \xa4 \xa5 \xa6 \xa7 \xa8 \xa9 \xaa \xab \xac \xad \xae 
  \xaf \xb0 \xb1 \xb2 \xb3 \xb4 \xb5 \xb6 \xb7 \xb8 \xb9 \xba \xbb \xbc \xbd 
  \xbe \xbf \xc0 \xc1 \xc2 \xc3 \xc4 \xc5 \xc6 \xc7 \xc8 \xc9 \xca \xcb \xcc 
  \xcd \xce \xcf \xd0 \xd1 \xd2 \xd3 \xd4 \xd5 \xd6 \xd7 \xd8 \xd9 \xda \xdb 
  \xdc \xdd \xde \xdf \xe0 \xe1 \xe2 \xe3 \xe4 \xe5 \xe6 \xe7 \xe8 \xe9 \xea 
  \xeb \xec \xed \xee \xef \xf0 \xf1 \xf2 \xf3 \xf4 \xf5 \xf6 \xf7 \xf8 \xf9 
  \xfa \xfb \xfc \xfd \xfe \xff 
Subject length lower bound = 1

/^[12[:^digit:]]/IB
------------------------------------------------------------------
        Bra
        ^
        [\x00-/12:-\xff] (neg)
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Compile options: <none>
Overall options: anchored
Starting code units: \x00 \x01 \x02 \x03 \x04 \x05 \x06 \x07 \x08 \x09 \x0a 
  \x0b \x0c \x0d \x0e \x0f \x10 \x11 \x12 \x13 \x14 \x15 \x16 \x17 \x18 \x19 
  \x1a \x1b \x1c \x1d \x1e \x1f \x20 ! " # $ % & ' ( ) * + , - . / 1 2 : ; < 
  = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a 
  b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~ \x7f \x80 \x81 \x82 
  \x83 \x84 \x85 \x86 \x87 \x88 \x89 \x8a \x8b \x8c \x8d \x8e \x8f \x90 \x91 
  \x92 \x93 \x94 \x95 \x96 \x97 \x98 \x99 \x9a \x9b \x9c \x9d \x9e \x9f \xa0 
  \xa1 \xa2 \xa3 \xa4 \xa5 \xa6 \xa7 \xa8 \xa9 \xaa \xab \xac \xad \xae \xaf 
  \xb0 \xb1 \xb2 \xb3 \xb4 \xb5 \xb6 \xb7 \xb8 \xb9 \xba \xbb \xbc \xbd \xbe 
  \xbf \xc0 \xc1 \xc2 \xc3 \xc4 \xc5 \xc6 \xc7 \xc8 \xc9 \xca \xcb \xcc \xcd 
  \xce \xcf \xd0 \xd1 \xd2 \xd3 \xd4 \xd5 \xd6 \xd7 \xd8 \xd9 \xda \xdb \xdc 
  \xdd \xde \xdf \xe0 \xe1 \xe2 \xe3 \xe4 \xe5 \xe6 \xe7 \xe8 \xe9 \xea \xeb 
  \xec \xed \xee \xef \xf0 \xf1 \xf2 \xf3 \xf4 \xf5 \xf6 \xf7 \xf8 \xf9 \xfa 
  \xfb \xfc \xfd \xfe \xff 
Subject length lower bound = 1

/^[[:^blank:]]/IB
------------------------------------------------------------------
        Bra
        ^
        [\x00-\x08\x0a-\x1f!-\xff] (neg)
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Compile options: <none>
Overall options: anchored
Starting code units: \x00 \x01 \x02 \x03 \x04 \x05 \x06 \x07 \x08 \x0a \x0b 
  \x0c \x0d \x0e \x0f \x10 \x11 \x12 \x13 \x14 \x15 \x16 \x17 \x18 \x19 \x1a 
  \x1b \x1c \x1d \x1e \x1f ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 
  : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ 
  _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~ \x7f \x80 
  \x81 \x82 \x83 \x84 \x85 \x86 \x87 \x88 \x89 \x8a \x8b \x8c \x8d \x8e \x8f 
  \x90 \x91 \x92 \x93 \x94 \x95 \x96 \x97 \x98 \x99 \x9a \x9b \x9c \x9d \x9e 
  \x9f \xa0 \xa1 \xa2 \xa3 \xa4 \xa5 \xa6 \xa7 \xa8 \xa9 \xaa \xab \xac \xad 
  \xae \xaf \xb0 \xb1 \xb2 \xb3 \xb4 \xb5 \xb6 \xb7 \xb8 \xb9 \xba \xbb \xbc 
  \xbd \xbe \xbf \xc0 \xc1 \xc2 \xc3 \xc4 \xc5 \xc6 \xc7 \xc8 \xc9 \xca \xcb 
  \xcc \xcd \xce \xcf \xd0 \xd1 \xd2 \xd3 \xd4 \xd5 \xd6 \xd7 \xd8 \xd9 \xda 
  \xdb \xdc \xdd \xde \xdf \xe0 \xe1 \xe2 \xe3 \xe4 \xe5 \xe6 \xe7 \xe8 \xe9 
  \xea \xeb \xec \xed \xee \xef \xf0 \xf1 \xf2 \xf3 \xf4 \xf5 \xf6 \xf7 \xf8 
  \xf9 \xfa \xfb \xfc \xfd \xfe \xff 
Subject length lower bound = 1

/[01[:alpha:]%]/IB
------------------------------------------------------------------
        Bra
        [%01A-Za-z]
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Starting code units: % 0 1 A B C D E F G H I J K L M N O P Q R S T U V W 
  X Y Z a b c d e f g h i j k l m n o p q r s t u v w x y z 
Subject length lower bound = 1

/[[.ch.]]/I
Failed: error 113 at offset 1: POSIX collating elements are not supported

/[[=ch=]]/I
Failed: error 113 at offset 1: POSIX collating elements are not supported

/[[:rhubarb:]]/I
Failed: error 130 at offset 3: unknown POSIX class name

/[[:upper:]]/Ii
Capture group count = 0
Options: caseless
Starting code units: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 
  a b c d e f g h i j k l m n o p q r s t u v w x y z 
Subject length lower bound = 1
    A
 0: A
    a
 0: a

/[[:lower:]]/Ii
Capture group count = 0
Options: caseless
Starting code units: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 
  a b c d e f g h i j k l m n o p q r s t u v w x y z 
Subject length lower bound = 1
    A
 0: A
    a
 0: a

/((?-i)[[:lower:]])[[:lower:]]/Ii
Capture group count = 1
Options: caseless
Starting code units: a b c d e f g h i j k l m n o p q r s t u v w x y z 
Subject length lower bound = 2
    ab
 0: ab
 1: a
    aB
 0: aB
 1: a
\= Expect no match
    Ab
No match
    AB
No match

/[\200-\110]/I
Failed: error 108 at offset 9: range out of order in character class

/^(?(0)f|b)oo/I
Failed: error 115 at offset 5: reference to non-existent subpattern

# This one's here because of the large output vector needed

/(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\d+(?:\s|$))(\w+)\s+(\270)/I
Capture group count = 271
Max back reference = 270
Starting code units: 0 1 2 3 4 5 6 7 8 9 
Subject length lower bound = 1
     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 ABC ABC\=ovector=300
 0: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 ABC ABC
 1: 1 
 2: 2 
 3: 3 
 4: 4 
 5: 5 
 6: 6 
 7: 7 
 8: 8 
 9: 9 
10: 10 
11: 11 
12: 12 
13: 13 
14: 14 
15: 15 
16: 16 
17: 17 
18: 18 
19: 19 
20: 20 
21: 21 
22: 22 
23: 23 
24: 24 
25: 25 
26: 26 
27: 27 
28: 28 
29: 29 
30: 30 
31: 31 
32: 32 
33: 33 
34: 34 
35: 35 
36: 36 
37: 37 
38: 38 
39: 39 
40: 40 
41: 41 
42: 42 
43: 43 
44: 44 
45: 45 
46: 46 
47: 47 
48: 48 
49: 49 
50: 50 
51: 51 
52: 52 
53: 53 
54: 54 
55: 55 
56: 56 
57: 57 
58: 58 
59: 59 
60: 60 
61: 61 
62: 62 
63: 63 
64: 64 
65: 65 
66: 66 
67: 67 
68: 68 
69: 69 
70: 70 
71: 71 
72: 72 
73: 73 
74: 74 
75: 75 
76: 76 
77: 77 
78: 78 
79: 79 
80: 80 
81: 81 
82: 82 
83: 83 
84: 84 
85: 85 
86: 86 
87: 87 
88: 88 
89: 89 
90: 90 
91: 91 
92: 92 
93: 93 
94: 94 
95: 95 
96: 96 
97: 97 
98: 98 
99: 99 
100: 100 
101: 101 
102: 102 
103: 103 
104: 104 
105: 105 
106: 106 
107: 107 
108: 108 
109: 109 
110: 110 
111: 111 
112: 112 
113: 113 
114: 114 
115: 115 
116: 116 
117: 117 
118: 118 
119: 119 
120: 120 
121: 121 
122: 122 
123: 123 
124: 124 
125: 125 
126: 126 
127: 127 
128: 128 
129: 129 
130: 130 
131: 131 
132: 132 
133: 133 
134: 134 
135: 135 
136: 136 
137: 137 
138: 138 
139: 139 
140: 140 
141: 141 
142: 142 
143: 143 
144: 144 
145: 145 
146: 146 
147: 147 
148: 148 
149: 149 
150: 150 
151: 151 
152: 152 
153: 153 
154: 154 
155: 155 
156: 156 
157: 157 
158: 158 
159: 159 
160: 160 
161: 161 
162: 162 
163: 163 
164: 164 
165: 165 
166: 166 
167: 167 
168: 168 
169: 169 
170: 170 
171: 171 
172: 172 
173: 173 
174: 174 
175: 175 
176: 176 
177: 177 
178: 178 
179: 179 
180: 180 
181: 181 
182: 182 
183: 183 
184: 184 
185: 185 
186: 186 
187: 187 
188: 188 
189: 189 
190: 190 
191: 191 
192: 192 
193: 193 
194: 194 
195: 195 
196: 196 
197: 197 
198: 198 
199: 199 
200: 200 
201: 201 
202: 202 
203: 203 
204: 204 
205: 205 
206: 206 
207: 207 
208: 208 
209: 209 
210: 210 
211: 211 
212: 212 
213: 213 
214: 214 
215: 215 
216: 216 
217: 217 
218: 218 
219: 219 
220: 220 
221: 221 
222: 222 
223: 223 
224: 224 
225: 225 
226: 226 
227: 227 
228: 228 
229: 229 
230: 230 
231: 231 
232: 232 
233: 233 
234: 234 
235: 235 
236: 236 
237: 237 
238: 238 
239: 239 
240: 240 
241: 241 
242: 242 
243: 243 
244: 244 
245: 245 
246: 246 
247: 247 
248: 248 
249: 249 
250: 250 
251: 251 
252: 252 
253: 253 
254: 254 
255: 255 
256: 256 
257: 257 
258: 258 
259: 259 
260: 260 
261: 261 
262: 262 
263: 263 
264: 264 
265: 265 
266: 266 
267: 267 
268: 268 
269: 269 
270: ABC
271: ABC

# This one's here because Perl does this differently and PCRE2 can't at present

/(main(O)?)+/I
Capture group count = 2
First code unit = 'm'
Last code unit = 'n'
Subject length lower bound = 4
    mainmain
 0: mainmain
 1: main
    mainOmain
 0: mainOmain
 1: main
 2: O

# These are all cases where Perl does it differently (nested captures)

/^(a(b)?)+$/I
Capture group count = 2
Compile options: <none>
Overall options: anchored
First code unit = 'a'
Subject length lower bound = 1
    aba
 0: aba
 1: a
 2: b

/^(aa(bb)?)+$/I
Capture group count = 2
Compile options: <none>
Overall options: anchored
First code unit = 'a'
Subject length lower bound = 2
    aabbaa
 0: aabbaa
 1: aa
 2: bb

/^(aa|aa(bb))+$/I
Capture group count = 2
Compile options: <none>
Overall options: anchored
First code unit = 'a'
Subject length lower bound = 2
    aabbaa
 0: aabbaa
 1: aa
 2: bb

/^(aa(bb)??)+$/I
Capture group count = 2
Compile options: <none>
Overall options: anchored
First code unit = 'a'
Subject length lower bound = 2
    aabbaa
 0: aabbaa
 1: aa
 2: bb

/^(?:aa(bb)?)+$/I
Capture group count = 1
Compile options: <none>
Overall options: anchored
First code unit = 'a'
Subject length lower bound = 2
    aabbaa
 0: aabbaa
 1: bb

/^(aa(b(b))?)+$/I
Capture group count = 3
Compile options: <none>
Overall options: anchored
First code unit = 'a'
Subject length lower bound = 2
    aabbaa
 0: aabbaa
 1: aa
 2: bb
 3: b

/^(?:aa(b(b))?)+$/I
Capture group count = 2
Compile options: <none>
Overall options: anchored
First code unit = 'a'
Subject length lower bound = 2
    aabbaa
 0: aabbaa
 1: bb
 2: b

/^(?:aa(b(?:b))?)+$/I
Capture group count = 1
Compile options: <none>
Overall options: anchored
First code unit = 'a'
Subject length lower bound = 2
    aabbaa
 0: aabbaa
 1: bb

/^(?:aa(bb(?:b))?)+$/I
Capture group count = 1
Compile options: <none>
Overall options: anchored
First code unit = 'a'
Subject length lower bound = 2
    aabbbaa
 0: aabbbaa
 1: bbb

/^(?:aa(b(?:bb))?)+$/I
Capture group count = 1
Compile options: <none>
Overall options: anchored
First code unit = 'a'
Subject length lower bound = 2
    aabbbaa
 0: aabbbaa
 1: bbb

/^(?:aa(?:b(b))?)+$/I
Capture group count = 1
Compile options: <none>
Overall options: anchored
First code unit = 'a'
Subject length lower bound = 2
    aabbaa
 0: aabbaa
 1: b

/^(?:aa(?:b(bb))?)+$/I
Capture group count = 1
Compile options: <none>
Overall options: anchored
First code unit = 'a'
Subject length lower bound = 2
    aabbbaa
 0: aabbbaa
 1: bb

/^(aa(b(bb))?)+$/I
Capture group count = 3
Compile options: <none>
Overall options: anchored
First code unit = 'a'
Subject length lower bound = 2
    aabbbaa
 0: aabbbaa
 1: aa
 2: bbb
 3: bb

/^(aa(bb(bb))?)+$/I
Capture group count = 3
Compile options: <none>
Overall options: anchored
First code unit = 'a'
Subject length lower bound = 2
    aabbbbaa
 0: aabbbbaa
 1: aa
 2: bbbb
 3: bb

# ----------------

/#/IBx
------------------------------------------------------------------
        Bra
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
May match empty string
Options: extended
Subject length lower bound = 0

/a#/IBx
------------------------------------------------------------------
        Bra
        a
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Options: extended
First code unit = 'a'
Subject length lower bound = 1

/[\s]/IB
------------------------------------------------------------------
        Bra
        [\x09-\x0d ]
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Starting code units: \x09 \x0a \x0b \x0c \x0d \x20 
Subject length lower bound = 1

/[\S]/IB
------------------------------------------------------------------
        Bra
        [\x00-\x08\x0e-\x1f!-\xff] (neg)
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Starting code units: \x00 \x01 \x02 \x03 \x04 \x05 \x06 \x07 \x08 \x0e \x0f 
  \x10 \x11 \x12 \x13 \x14 \x15 \x16 \x17 \x18 \x19 \x1a \x1b \x1c \x1d \x1e 
  \x1f ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @ A B C 
  D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c d e f g h 
  i j k l m n o p q r s t u v w x y z { | } ~ \x7f \x80 \x81 \x82 \x83 \x84 
  \x85 \x86 \x87 \x88 \x89 \x8a \x8b \x8c \x8d \x8e \x8f \x90 \x91 \x92 \x93 
  \x94 \x95 \x96 \x97 \x98 \x99 \x9a \x9b \x9c \x9d \x9e \x9f \xa0 \xa1 \xa2 
  \xa3 \xa4 \xa5 \xa6 \xa7 \xa8 \xa9 \xaa \xab \xac \xad \xae \xaf \xb0 \xb1 
  \xb2 \xb3 \xb4 \xb5 \xb6 \xb7 \xb8 \xb9 \xba \xbb \xbc \xbd \xbe \xbf \xc0 
  \xc1 \xc2 \xc3 \xc4 \xc5 \xc6 \xc7 \xc8 \xc9 \xca \xcb \xcc \xcd \xce \xcf 
  \xd0 \xd1 \xd2 \xd3 \xd4 \xd5 \xd6 \xd7 \xd8 \xd9 \xda \xdb \xdc \xdd \xde 
  \xdf \xe0 \xe1 \xe2 \xe3 \xe4 \xe5 \xe6 \xe7 \xe8 \xe9 \xea \xeb \xec \xed 
  \xee \xef \xf0 \xf1 \xf2 \xf3 \xf4 \xf5 \xf6 \xf7 \xf8 \xf9 \xfa \xfb \xfc 
  \xfd \xfe \xff 
Subject length lower bound = 1

/a(?i)b/IB
------------------------------------------------------------------
        Bra
        a
     /i b
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
First code unit = 'a'
Last code unit = 'b' (caseless)
Subject length lower bound = 2
    ab
 0: ab
    aB
 0: aB
\= Expect no match
    AB
No match

/(a(?i)b)/IB
------------------------------------------------------------------
        Bra
        CBra 1
        a
     /i b
        Ket
        Ket
        End
------------------------------------------------------------------
Capture group count = 1
First code unit = 'a'
Last code unit = 'b' (caseless)
Subject length lower bound = 2
    ab
 0: ab
 1: ab
    aB
 0: aB
 1: aB
\= Expect no match
    AB
No match

/   (?i)abc/IBx
------------------------------------------------------------------
        Bra
     /i abc
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Options: extended
First code unit = 'a' (caseless)
Last code unit = 'c' (caseless)
Subject length lower bound = 3

/#this is a comment
  (?i)abc/IBx
------------------------------------------------------------------
        Bra
     /i abc
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Options: extended
First code unit = 'a' (caseless)
Last code unit = 'c' (caseless)
Subject length lower bound = 3

/123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890/IB
------------------------------------------------------------------
        Bra
        123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
First code unit = '1'
Last code unit = '0'
Subject length lower bound = 300

/\Q123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890/IB
------------------------------------------------------------------
        Bra
        123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
First code unit = '1'
Last code unit = '0'
Subject length lower bound = 300

/\Q\E/IB
------------------------------------------------------------------
        Bra
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
May match empty string
Subject length lower bound = 0
    \
 0: 

/\Q\Ex/IB
------------------------------------------------------------------
        Bra
        x
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
First code unit = 'x'
Subject length lower bound = 1

/ \Q\E/IB
------------------------------------------------------------------
        Bra
         
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
First code unit = ' '
Subject length lower bound = 1

/a\Q\E/IB
------------------------------------------------------------------
        Bra
        a
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
First code unit = 'a'
Subject length lower bound = 1
  abc
 0: a
  bca
 0: a
  bac
 0: a

/a\Q\Eb/IB
------------------------------------------------------------------
        Bra
        ab
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 2
  abc
 0: ab

/\Q\Eabc/IB
------------------------------------------------------------------
        Bra
        abc
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
First code unit = 'a'
Last code unit = 'c'
Subject length lower bound = 3

/x*+\w/IB
------------------------------------------------------------------
        Bra
        x*+
        \w
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Starting code units: 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P 
  Q R S T U V W X Y Z _ a b c d e f g h i j k l m n o p q r s t u v w x y z 
Subject length lower bound = 1
\= Expect no match
    xxxxx
No match

/x?+/IB
------------------------------------------------------------------
        Bra
        x?+
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
May match empty string
Subject length lower bound = 0

/x++/IB
------------------------------------------------------------------
        Bra
        x++
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
First code unit = 'x'
Subject length lower bound = 1

/x{1,3}+/B,no_auto_possess
------------------------------------------------------------------
        Bra
        x
        x{0,2}+
        Ket
        End
------------------------------------------------------------------

/x{1,3}+/Bi,no_auto_possess
------------------------------------------------------------------
        Bra
     /i x
     /i x{0,2}+
        Ket
        End
------------------------------------------------------------------

/[^x]{1,3}+/B,no_auto_possess
------------------------------------------------------------------
        Bra
        [^x]
        [^x]{0,2}+
        Ket
        End
------------------------------------------------------------------

/[^x]{1,3}+/Bi,no_auto_possess
------------------------------------------------------------------
        Bra
     /i [^x]
     /i [^x]{0,2}+
        Ket
        End
------------------------------------------------------------------

/(x)*+/IB
------------------------------------------------------------------
        Bra
        Braposzero
        CBraPos 1
        x
        KetRpos
        Ket
        End
------------------------------------------------------------------
Capture group count = 1
May match empty string
Subject length lower bound = 0

/^(\w++|\s++)*$/I
Capture group count = 1
May match empty string
Compile options: <none>
Overall options: anchored
Subject length lower bound = 0
    now is the time for all good men to come to the aid of the party
 0: now is the time for all good men to come to the aid of the party
 1: party
\= Expect no match
    this is not a line with only words and spaces!
No match

/(\d++)(\w)/I
Capture group count = 2
Starting code units: 0 1 2 3 4 5 6 7 8 9 
Subject length lower bound = 2
    12345a
 0: 12345a
 1: 12345
 2: a
\= Expect no match
    12345+
No match

/a++b/I
Capture group count = 0
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 2
    aaab
 0: aaab

/(a++b)/I
Capture group count = 1
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 2
    aaab
 0: aaab
 1: aaab

/(a++)b/I
Capture group count = 1
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 2
    aaab
 0: aaab
 1: aaa

/([^()]++|\([^()]*\))+/I
Capture group count = 1
Starting code units: \x00 \x01 \x02 \x03 \x04 \x05 \x06 \x07 \x08 \x09 \x0a 
  \x0b \x0c \x0d \x0e \x0f \x10 \x11 \x12 \x13 \x14 \x15 \x16 \x17 \x18 \x19 
  \x1a \x1b \x1c \x1d \x1e \x1f \x20 ! " # $ % & ' ( * + , - . / 0 1 2 3 4 5 
  6 7 8 9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 
  [ \ ] ^ _ ` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~ \x7f 
  \x80 \x81 \x82 \x83 \x84 \x85 \x86 \x87 \x88 \x89 \x8a \x8b \x8c \x8d \x8e 
  \x8f \x90 \x91 \x92 \x93 \x94 \x95 \x96 \x97 \x98 \x99 \x9a \x9b \x9c \x9d 
  \x9e \x9f \xa0 \xa1 \xa2 \xa3 \xa4 \xa5 \xa6 \xa7 \xa8 \xa9 \xaa \xab \xac 
  \xad \xae \xaf \xb0 \xb1 \xb2 \xb3 \xb4 \xb5 \xb6 \xb7 \xb8 \xb9 \xba \xbb 
  \xbc \xbd \xbe \xbf \xc0 \xc1 \xc2 \xc3 \xc4 \xc5 \xc6 \xc7 \xc8 \xc9 \xca 
  \xcb \xcc \xcd \xce \xcf \xd0 \xd1 \xd2 \xd3 \xd4 \xd5 \xd6 \xd7 \xd8 \xd9 
  \xda \xdb \xdc \xdd \xde \xdf \xe0 \xe1 \xe2 \xe3 \xe4 \xe5 \xe6 \xe7 \xe8 
  \xe9 \xea \xeb \xec \xed \xee \xef \xf0 \xf1 \xf2 \xf3 \xf4 \xf5 \xf6 \xf7 
  \xf8 \xf9 \xfa \xfb \xfc \xfd \xfe \xff 
Subject length lower bound = 1
    ((abc(ade)ufh()()x
 0: abc(ade)ufh()()x
 1: x

/\(([^()]++|\([^()]+\))+\)/I
Capture group count = 1
First code unit = '('
Last code unit = ')'
Subject length lower bound = 3
    (abc)
 0: (abc)
 1: abc
    (abc(def)xyz)
 0: (abc(def)xyz)
 1: xyz
\= Expect no match
    ((()aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
No match

/(abc){1,3}+/IB
------------------------------------------------------------------
        Bra
        Once
        CBra 1
        abc
        Ket
        Brazero
        Bra
        CBra 1
        abc
        Ket
        Brazero
        CBra 1
        abc
        Ket
        Ket
        Ket
        Ket
        End
------------------------------------------------------------------
Capture group count = 1
First code unit = 'a'
Last code unit = 'c'
Subject length lower bound = 3

/a+?+/I
Failed: error 109 at offset 3: quantifier does not follow a repeatable item

/a{2,3}?+b/I
Failed: error 109 at offset 7: quantifier does not follow a repeatable item

/(?U)a+?+/I
Failed: error 109 at offset 7: quantifier does not follow a repeatable item

/a{2,3}?+b/I,ungreedy
Failed: error 109 at offset 7: quantifier does not follow a repeatable item

/x(?U)a++b/IB
------------------------------------------------------------------
        Bra
        x
        a++
        b
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
First code unit = 'x'
Last code unit = 'b'
Subject length lower bound = 3
    xaaaab
 0: xaaaab

/(?U)xa++b/IB
------------------------------------------------------------------
        Bra
        x
        a++
        b
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
First code unit = 'x'
Last code unit = 'b'
Subject length lower bound = 3
    xaaaab
 0: xaaaab

/^((a+)(?U)([ab]+)(?-U)([bc]+)(\w*))/IB
------------------------------------------------------------------
        Bra
        ^
        CBra 1
        CBra 2
        a+
        Ket
        CBra 3
        [ab]+?
        Ket
        CBra 4
        [bc]+
        Ket
        CBra 5
        \w*+
        Ket
        Ket
        Ket
        End
------------------------------------------------------------------
Capture group count = 5
Compile options: <none>
Overall options: anchored
First code unit = 'a'
Subject length lower bound = 3

/^x(?U)a+b/IB
------------------------------------------------------------------
        Bra
        ^
        x
        a++
        b
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Compile options: <none>
Overall options: anchored
First code unit = 'x'
Last code unit = 'b'
Subject length lower bound = 3

/^x(?U)(a+)b/IB
------------------------------------------------------------------
        Bra
        ^
        x
        CBra 1
        a+?
        Ket
        b
        Ket
        End
------------------------------------------------------------------
Capture group count = 1
Compile options: <none>
Overall options: anchored
First code unit = 'x'
Last code unit = 'b'
Subject length lower bound = 3

/[.x.]/I
Failed: error 113 at offset 0: POSIX collating elements are not supported

/[=x=]/I
Failed: error 113 at offset 0: POSIX collating elements are not supported

/[:x:]/I
Failed: error 112 at offset 0: POSIX named classes are supported only within a class

/\F/I
Failed: error 137 at offset 2: PCRE2 does not support \F, \L, \l, \N{name}, \U, or \u

/\l/I
Failed: error 137 at offset 2: PCRE2 does not support \F, \L, \l, \N{name}, \U, or \u

/\L/I
Failed: error 137 at offset 2: PCRE2 does not support \F, \L, \l, \N{name}, \U, or \u

/\N{name}/I
Failed: error 137 at offset 2: PCRE2 does not support \F, \L, \l, \N{name}, \U, or \u

/\u/I
Failed: error 137 at offset 2: PCRE2 does not support \F, \L, \l, \N{name}, \U, or \u

/\U/I
Failed: error 137 at offset 2: PCRE2 does not support \F, \L, \l, \N{name}, \U, or \u

/a{1,3}b/ungreedy
    ab
 0: ab

/[/I
Failed: error 106 at offset 1: missing terminating ] for character class

/[a-/I
Failed: error 106 at offset 3: missing terminating ] for character class

/[[:space:]/I
Failed: error 106 at offset 10: missing terminating ] for character class

/[\s]/IB
------------------------------------------------------------------
        Bra
        [\x09-\x0d ]
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Starting code units: \x09 \x0a \x0b \x0c \x0d \x20 
Subject length lower bound = 1

/[[:space:]]/IB
------------------------------------------------------------------
        Bra
        [\x09-\x0d ]
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Starting code units: \x09 \x0a \x0b \x0c \x0d \x20 
Subject length lower bound = 1

/[[:space:]abcde]/IB
------------------------------------------------------------------
        Bra
        [\x09-\x0d a-e]
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Starting code units: \x09 \x0a \x0b \x0c \x0d \x20 a b c d e 
Subject length lower bound = 1

/< (?: (?(R) \d++  | [^<>]*+) | (?R)) * >/Ix
Capture group count = 0
Options: extended
First code unit = '<'
Last code unit = '>'
Subject length lower bound = 2
    <>
 0: <>
    <abcd>
 0: <abcd>
    <abc <123> hij>
 0: <abc <123> hij>
    <abc <def> hij>
 0: <def>
    <abc<>def>
 0: <abc<>def>
    <abc<>
 0: <>
\= Expect no match
    <abc
No match

/8J\$WE\<\.rX\+ix\[d1b\!H\#\?vV0vrK\:ZH1\=2M\>iV\;\?aPhFB\<\*vW\@QW\@sO9\}cfZA\-i\'w\%hKd6gt1UJP\,15_\#QY\$M\^Mss_U\/\]\&LK9\[5vQub\^w\[KDD\<EjmhUZ\?\.akp2dF\>qmj\;2\}YWFdYx\.Ap\]hjCPTP\(n28k\+3\;o\&WXqs\/gOXdr\$\:r\'do0\;b4c\(f_Gr\=\"\\4\)\[01T7ajQJvL\$W\~mL_sS\/4h\:x\*\[ZN\=KLs\&L5zX\/\/\>it\,o\:aU\(\;Z\>pW\&T7oP\'2K\^E\:x9\'c\[\%z\-\,64JQ5AeH_G\#KijUKghQw\^\\vea3a\?kka_G\$8\#\`\*kynsxzBLru\'\]k_\[7FrVx\}\^\=\$blx\>s\-N\%j\;D\*aZDnsw\:YKZ\%Q\.Kne9\#hP\?\+b3\(SOvL\,\^\;\&u5\@\?5C5Bhb\=m\-vEh_L15Jl\]U\)0RP6\{q\%L\^_z5E\'Dw6X\b/IB
------------------------------------------------------------------
        Bra
        8J$WE<.rX+ix[d1b!H#?vV0vrK:ZH1=2M>iV;?aPhFB<*vW@QW@sO9}cfZA-i'w%hKd6gt1UJP,15_#QY$M^Mss_U/]&LK9[5vQub^w[KDD<EjmhUZ?.akp2dF>qmj;2}YWFdYx.Ap]hjCPTP(n28k+3;o&WXqs/gOXdr$:r'do0;b4c(f_Gr="\4)[01T7ajQJvL$W~mL_sS/4h:x*[ZN=KLs&L5zX//>it,o:aU(;Z>pW&T7oP'2K^E:x9'c[%z-,64JQ5AeH_G#KijUKghQw^\vea3a?kka_G$8#`*kynsxzBLru']k_[7FrVx}^=$blx>s-N%j;D*aZDnsw:YKZ%Q.Kne9#hP?+b3(SOvL,^;&u5@?5C5Bhb=m-vEh_L15Jl]U)0RP6{q%L^_z5E'Dw6X
        \b
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Max lookbehind = 1
First code unit = '8'
Last code unit = 'X'
Subject length lower bound = 409

/\$\<\.X\+ix\[d1b\!H\#\?vV0vrK\:ZH1\=2M\>iV\;\?aPhFB\<\*vW\@QW\@sO9\}cfZA\-i\'w\%hKd6gt1UJP\,15_\#QY\$M\^Mss_U\/\]\&LK9\[5vQub\^w\[KDD\<EjmhUZ\?\.akp2dF\>qmj\;2\}YWFdYx\.Ap\]hjCPTP\(n28k\+3\;o\&WXqs\/gOXdr\$\:r\'do0\;b4c\(f_Gr\=\"\\4\)\[01T7ajQJvL\$W\~mL_sS\/4h\:x\*\[ZN\=KLs\&L5zX\/\/\>it\,o\:aU\(\;Z\>pW\&T7oP\'2K\^E\:x9\'c\[\%z\-\,64JQ5AeH_G\#KijUKghQw\^\\vea3a\?kka_G\$8\#\`\*kynsxzBLru\'\]k_\[7FrVx\}\^\=\$blx\>s\-N\%j\;D\*aZDnsw\:YKZ\%Q\.Kne9\#hP\?\+b3\(SOvL\,\^\;\&u5\@\?5C5Bhb\=m\-vEh_L15Jl\]U\)0RP6\{q\%L\^_z5E\'Dw6X\b/IB
------------------------------------------------------------------
        Bra
        $<.X+ix[d1b!H#?vV0vrK:ZH1=2M>iV;?aPhFB<*vW@QW@sO9}cfZA-i'w%hKd6gt1UJP,15_#QY$M^Mss_U/]&LK9[5vQub^w[KDD<EjmhUZ?.akp2dF>qmj;2}YWFdYx.Ap]hjCPTP(n28k+3;o&WXqs/gOXdr$:r'do0;b4c(f_Gr="\4)[01T7ajQJvL$W~mL_sS/4h:x*[ZN=KLs&L5zX//>it,o:aU(;Z>pW&T7oP'2K^E:x9'c[%z-,64JQ5AeH_G#KijUKghQw^\vea3a?kka_G$8#`*kynsxzBLru']k_[7FrVx}^=$blx>s-N%j;D*aZDnsw:YKZ%Q.Kne9#hP?+b3(SOvL,^;&u5@?5C5Bhb=m-vEh_L15Jl]U)0RP6{q%L^_z5E'Dw6X
        \b
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Max lookbehind = 1
First code unit = '$'
Last code unit = 'X'
Subject length lower bound = 404

/(.*)\d+\1/I
Capture group count = 1
Max back reference = 1
Subject length lower bound = 1

/(.*)\d+/I
Capture group count = 1
First code unit at start or follows newline
Subject length lower bound = 1

/(.*)\d+\1/Is
Capture group count = 1
Max back reference = 1
Options: dotall
Subject length lower bound = 1

/(.*)\d+/Is
Capture group count = 1
Compile options: dotall
Overall options: anchored dotall
Subject length lower bound = 1

/(.*(xyz))\d+\2/I
Capture group count = 2
Max back reference = 2
First code unit at start or follows newline
Last code unit = 'z'
Subject length lower bound = 7

/((.*))\d+\1/I
Capture group count = 2
Max back reference = 1
Subject length lower bound = 1
    abc123bc
 0: bc123bc
 1: bc
 2: bc

/a[b]/I
Capture group count = 0
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 2

/(?=a).*/I
Capture group count = 0
May match empty string
First code unit = 'a'
Subject length lower bound = 1

/(?=abc).xyz/Ii
Capture group count = 0
Options: caseless
First code unit = 'a' (caseless)
Last code unit = 'z' (caseless)
Subject length lower bound = 4

/(?=abc)(?i).xyz/I
Capture group count = 0
First code unit = 'a'
Last code unit = 'z' (caseless)
Subject length lower bound = 4

/(?=a)(?=b)/I
Capture group count = 0
May match empty string
First code unit = 'a'
Subject length lower bound = 1

/(?=.)a/I
Capture group count = 0
First code unit = 'a'
Subject length lower bound = 1

/((?=abcda)a)/I
Capture group count = 1
First code unit = 'a'
Last code unit = 'a'
Subject length lower bound = 2

/((?=abcda)ab)/I
Capture group count = 1
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 2

/()a/I
Capture group count = 1
First code unit = 'a'
Subject length lower bound = 1

/(?:(?=.)|(?<!x))a/I
Capture group count = 0
Max lookbehind = 1
First code unit = 'a'
Subject length lower bound = 1

/(?(1)ab|ac)(.)/I
Capture group count = 1
Max back reference = 1
First code unit = 'a'
Subject length lower bound = 3

/(?(1)abz|acz)(.)/I
Capture group count = 1
Max back reference = 1
First code unit = 'a'
Last code unit = 'z'
Subject length lower bound = 4

/(?(1)abz)(.)/I
Capture group count = 1
Max back reference = 1
Subject length lower bound = 1

/(?(1)abz)(1)23/I
Capture group count = 1
Max back reference = 1
Last code unit = '3'
Subject length lower bound = 3

/(a)+/I
Capture group count = 1
First code unit = 'a'
Subject length lower bound = 1

/(a){2,3}/I
Capture group count = 1
First code unit = 'a'
Last code unit = 'a'
Subject length lower bound = 2

/(a)*/I
Capture group count = 1
May match empty string
Subject length lower bound = 0

/[a]/I
Capture group count = 0
First code unit = 'a'
Subject length lower bound = 1

/[ab]/I
Capture group count = 0
Starting code units: a b 
Subject length lower bound = 1

/[ab]/I
Capture group count = 0
Starting code units: a b 
Subject length lower bound = 1

/[^a]/I
Capture group count = 0
Subject length lower bound = 1

/\d456/I
Capture group count = 0
Starting code units: 0 1 2 3 4 5 6 7 8 9 
Last code unit = '6'
Subject length lower bound = 4

/\d456/I
Capture group count = 0
Starting code units: 0 1 2 3 4 5 6 7 8 9 
Last code unit = '6'
Subject length lower bound = 4

/a^b/I
Capture group count = 0
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 2

/^a/Im
Capture group count = 0
Options: multiline
First code unit at start or follows newline
Last code unit = 'a'
Subject length lower bound = 1
  abcde
 0: a
  xy\nabc
 0: a
\= Expect no match
  xyabc
No match

/c|abc/I
Capture group count = 0
Starting code units: a c 
Last code unit = 'c'
Subject length lower bound = 1

/(?i)[ab]/I
Capture group count = 0
Starting code units: A B a b 
Subject length lower bound = 1

/[ab](?i)cd/I
Capture group count = 0
Starting code units: a b 
Last code unit = 'd' (caseless)
Subject length lower bound = 3

/abc(?C)def/I
Capture group count = 0
First code unit = 'a'
Last code unit = 'f'
Subject length lower bound = 6
    abcdef
--->abcdef
  0 ^  ^       d
 0: abcdef
    1234abcdef
--->1234abcdef
  0     ^  ^       d
 0: abcdef
\= Expect no match
    abcxyz
No match
    abcxyzf
--->abcxyzf
  0 ^  ^        d
No match

/abc(?C)de(?C1)f/I
Capture group count = 0
First code unit = 'a'
Last code unit = 'f'
Subject length lower bound = 6
    123abcdef
--->123abcdef
  0    ^  ^       d
  1    ^    ^     f
 0: abcdef

/(?C1)\dabc(?C2)def/I
Capture group count = 0
Starting code units: 0 1 2 3 4 5 6 7 8 9 
Last code unit = 'f'
Subject length lower bound = 7
    1234abcdef
--->1234abcdef
  1 ^              \d
  1  ^             \d
  1   ^            \d
  1    ^           \d
  2    ^   ^       d
 0: 4abcdef
\= Expect no match
    abcdef
No match

/(?C1)\dabc(?C2)def/I
Capture group count = 0
Starting code units: 0 1 2 3 4 5 6 7 8 9 
Last code unit = 'f'
Subject length lower bound = 7
    1234abcdef
--->1234abcdef
  1 ^              \d
  1  ^             \d
  1   ^            \d
  1    ^           \d
  2    ^   ^       d
 0: 4abcdef
\= Expect no match
    abcdef
No match

/(?C255)ab/I
Capture group count = 0
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 2

/(?C256)ab/I
Failed: error 138 at offset 6: number after (?C is greater than 255

/(?Cab)xx/I
Failed: error 182 at offset 3: unrecognized string delimiter follows (?C

/(?C12vr)x/I
Failed: error 139 at offset 5: closing parenthesis for (?C expected

/abc(?C)def/I
Capture group count = 0
First code unit = 'a'
Last code unit = 'f'
Subject length lower bound = 6
    \x83\x0\x61bcdef
--->\x83\x00abcdef
  0         ^  ^       d
 0: abcdef

/(abc)(?C)de(?C1)f/I
Capture group count = 1
First code unit = 'a'
Last code unit = 'f'
Subject length lower bound = 6
    123abcdef
--->123abcdef
  0    ^  ^       d
  1    ^    ^     f
 0: abcdef
 1: abc
    123abcdef\=callout_capture
Callout 0: last capture = 1
 1: abc
--->123abcdef
       ^  ^       d
Callout 1: last capture = 1
 1: abc
--->123abcdef
       ^    ^     f
 0: abcdef
 1: abc
    123abcdefC-\=callout_none
 0: abcdef
 1: abc
\= Expect no match
    123abcdef\=callout_fail=1
--->123abcdef
  0    ^  ^       d
  1    ^    ^     f
No match

/(?C0)(abc(?C1))*/I
Capture group count = 1
May match empty string
Subject length lower bound = 0
    abcabcabc
--->abcabcabc
  0 ^             (
  1 ^  ^          )*
  1 ^     ^       )*
  1 ^        ^    )*
 0: abcabcabc
 1: abc
    abcabc\=callout_fail=1:4
--->abcabc
  0 ^          (
  1 ^  ^       )*
  1 ^     ^    )*
 0: abcabc
 1: abc
    abcabcabc\=callout_fail=1:4
--->abcabcabc
  0 ^             (
  1 ^  ^          )*
  1 ^     ^       )*
  1 ^        ^    )*
 0: abcabc
 1: abc

/(\d{3}(?C))*/I
Capture group count = 1
May match empty string
Subject length lower bound = 0
    123\=callout_capture
Callout 0: last capture = 0
--->123
    ^  ^    )*
 0: 123
 1: 123
    123456\=callout_capture
Callout 0: last capture = 0
--->123456
    ^  ^       )*
Callout 0: last capture = 1
 1: 123
--->123456
    ^     ^    )*
 0: 123456
 1: 456
    123456789\=callout_capture
Callout 0: last capture = 0
--->123456789
    ^  ^          )*
Callout 0: last capture = 1
 1: 123
--->123456789
    ^     ^       )*
Callout 0: last capture = 1
 1: 456
--->123456789
    ^        ^    )*
 0: 123456789
 1: 789

/((xyz)(?C)p|(?C1)xyzabc)/I
Capture group count = 2
First code unit = 'x'
Subject length lower bound = 4
    xyzabc\=callout_capture
Callout 0: last capture = 2
 1: <unset>
 2: xyz
--->xyzabc
    ^  ^       p
Callout 1: last capture = 0
--->xyzabc
    ^          x
 0: xyzabc
 1: xyzabc

/(X)((xyz)(?C)p|(?C1)xyzabc)/I
Capture group count = 3
First code unit = 'X'
Last code unit = 'x'
Subject length lower bound = 5
    Xxyzabc\=callout_capture
Callout 0: last capture = 3
 1: X
 2: <unset>
 3: xyz
--->Xxyzabc
    ^   ^       p
Callout 1: last capture = 1
 1: X
--->Xxyzabc
    ^^          x
 0: Xxyzabc
 1: X
 2: xyzabc

/(?=(abc))(?C)abcdef/I
Capture group count = 1
First code unit = 'a'
Last code unit = 'f'
Subject length lower bound = 6
    abcdef\=callout_capture
Callout 0: last capture = 1
 1: abc
--->abcdef
    ^          a
 0: abcdef
 1: abc

/(?!(abc)(?C1)d)(?C2)abcxyz/I
Capture group count = 1
First code unit = 'a'
Last code unit = 'z'
Subject length lower bound = 6
    abcxyz\=callout_capture
Callout 1: last capture = 1
 1: abc
--->abcxyz
    ^  ^       d
Callout 2: last capture = 0
--->abcxyz
    ^          a
 0: abcxyz

/(?<=(abc)(?C))xyz/I
Capture group count = 1
Max lookbehind = 3
First code unit = 'x'
Last code unit = 'z'
Subject length lower bound = 3
   abcxyz\=callout_capture
Callout 0: last capture = 1
 1: abc
--->abcxyz
       ^       )
 0: xyz
 1: abc

/a(b+)(c*)(?C1)/I
Capture group count = 2
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 2
\= Expect no match
    abbbbbccc\=callout_data=1
--->abbbbbccc
  1 ^        ^    End of pattern
Callout data = 1
No match

/a(b+?)(c*?)(?C1)/I
Capture group count = 2
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 2
\= Expect no match
    abbbbbccc\=callout_data=1
--->abbbbbccc
  1 ^ ^           End of pattern
Callout data = 1
  1 ^  ^          End of pattern
Callout data = 1
  1 ^   ^         End of pattern
Callout data = 1
  1 ^    ^        End of pattern
Callout data = 1
  1 ^     ^       End of pattern
Callout data = 1
  1 ^      ^      End of pattern
Callout data = 1
  1 ^       ^     End of pattern
Callout data = 1
  1 ^        ^    End of pattern
Callout data = 1
No match

/(?C)abc/I
Capture group count = 0
First code unit = 'a'
Last code unit = 'c'
Subject length lower bound = 3

/(?C)^abc/I
Capture group count = 0
Compile options: <none>
Overall options: anchored
First code unit = 'a'
Subject length lower bound = 3

/(?C)a|b/I
Capture group count = 0
Starting code units: a b 
Subject length lower bound = 1

/a|(b)(?C)/I
Capture group count = 1
Starting code units: a b 
Subject length lower bound = 1
    b
--->b
  0 ^^    End of pattern
 0: b
 1: b

/x(ab|(bc|(de|(?R))))/I
Capture group count = 3
First code unit = 'x'
Subject length lower bound = 3
    xab
 0: xab
 1: ab
    xbc
 0: xbc
 1: bc
 2: bc
    xde
 0: xde
 1: de
 2: de
 3: de
    xxab
 0: xxab
 1: xab
 2: xab
 3: xab
    xxxab
 0: xxxab
 1: xxab
 2: xxab
 3: xxab
\= Expect no match
    xyab
No match

/^([^()]|\((?1)*\))*$/I
Capture group count = 1
May match empty string
Compile options: <none>
Overall options: anchored
Subject length lower bound = 0
    abc
 0: abc
 1: c
    a(b)c
 0: a(b)c
 1: c
    a(b(c))d
 0: a(b(c))d
 1: d
\= Expect no match)
    a(b(c)d
No match

/^>abc>([^()]|\((?1)*\))*<xyz<$/I
Capture group count = 1
Compile options: <none>
Overall options: anchored
First code unit = '>'
Last code unit = '<'
Subject length lower bound = 10
   >abc>123<xyz<
 0: >abc>123<xyz<
 1: 3
   >abc>1(2)3<xyz<
 0: >abc>1(2)3<xyz<
 1: 3
   >abc>(1(2)3)<xyz<
 0: >abc>(1(2)3)<xyz<
 1: (1(2)3)

/(a(?1)b)/IB
------------------------------------------------------------------
        Bra
        CBra 1
        a
        Recurse
        b
        Ket
        Ket
        End
------------------------------------------------------------------
Capture group count = 1
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 2

/(a(?1)+b)/IB
------------------------------------------------------------------
        Bra
        CBra 1
        a
        SBra
        Recurse
        KetRmax
        b
        Ket
        Ket
        End
------------------------------------------------------------------
Capture group count = 1
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 2

/^(\d+|\((?1)([+*-])(?1)\)|-(?1))$/I
Capture group count = 2
Compile options: <none>
Overall options: anchored
Starting code units: ( - 0 1 2 3 4 5 6 7 8 9 
Subject length lower bound = 1
    12
 0: 12
 1: 12
    (((2+2)*-3)-7)
 0: (((2+2)*-3)-7)
 1: (((2+2)*-3)-7)
 2: -
    -12
 0: -12
 1: -12
\= Expect no match
    ((2+2)*-3)-7)
No match

/^(x(y|(?1){2})z)/I
Capture group count = 2
Compile options: <none>
Overall options: anchored
First code unit = 'x'
Subject length lower bound = 3
    xyz
 0: xyz
 1: xyz
 2: y
    xxyzxyzz
 0: xxyzxyzz
 1: xxyzxyzz
 2: xyzxyz
\= Expect no match
    xxyzz
No match
    xxyzxyzxyzz
No match

/((< (?: (?(R) \d++  | [^<>]*+) | (?2)) * >))/Ix
Capture group count = 2
Options: extended
First code unit = '<'
Last code unit = '>'
Subject length lower bound = 2
    <>
 0: <>
 1: <>
 2: <>
    <abcd>
 0: <abcd>
 1: <abcd>
 2: <abcd>
    <abc <123> hij>
 0: <abc <123> hij>
 1: <abc <123> hij>
 2: <abc <123> hij>
    <abc <def> hij>
 0: <def>
 1: <def>
 2: <def>
    <abc<>def>
 0: <abc<>def>
 1: <abc<>def>
 2: <abc<>def>
    <abc<>
 0: <>
 1: <>
 2: <>
\= Expect no match
    <abc
No match

/(?1)/I
Failed: error 115 at offset 3: reference to non-existent subpattern

/((?2)(abc)/I
Failed: error 114 at offset 10: missing closing parenthesis

/^(abc)def(?1)/I
Capture group count = 1
Compile options: <none>
Overall options: anchored
First code unit = 'a'
Subject length lower bound = 9
    abcdefabc
 0: abcdefabc
 1: abc

/^(a|b|c)=(?1)+/I
Capture group count = 1
Compile options: <none>
Overall options: anchored
Starting code units: a b c 
Subject length lower bound = 2
    a=a
 0: a=a
 1: a
    a=b
 0: a=b
 1: a
    a=bc
 0: a=bc
 1: a

/^(a|b|c)=((?1))+/I
Capture group count = 2
Compile options: <none>
Overall options: anchored
Starting code units: a b c 
Subject length lower bound = 2
    a=a
 0: a=a
 1: a
 2: a
    a=b
 0: a=b
 1: a
 2: b
    a=bc
 0: a=bc
 1: a
 2: c

/a(?P<name1>b|c)d(?P<longername2>e)/IB
------------------------------------------------------------------
        Bra
        a
        CBra 1
        b
        Alt
        c
        Ket
        d
        CBra 2
        e
        Ket
        Ket
        End
------------------------------------------------------------------
Capture group count = 2
Named capture groups:
  longername2   2
  name1         1
First code unit = 'a'
Last code unit = 'e'
Subject length lower bound = 4
    abde
 0: abde
 1: b
 2: e
    acde
 0: acde
 1: c
 2: e

/(?:a(?P<c>c(?P<d>d)))(?P<a>a)/IB
------------------------------------------------------------------
        Bra
        Bra
        a
        CBra 1
        c
        CBra 2
        d
        Ket
        Ket
        Ket
        CBra 3
        a
        Ket
        Ket
        End
------------------------------------------------------------------
Capture group count = 3
Named capture groups:
  a   3
  c   1
  d   2
First code unit = 'a'
Last code unit = 'a'
Subject length lower bound = 4

/(?P<a>a)...(?P=a)bbb(?P>a)d/IB
------------------------------------------------------------------
        Bra
        CBra 1
        a
        Ket
        Any
        Any
        Any
        \1
        bbb
        Recurse
        d
        Ket
        End
------------------------------------------------------------------
Capture group count = 1
Max back reference = 1
Named capture groups:
  a   1
First code unit = 'a'
Last code unit = 'd'
Subject length lower bound = 10

/^\W*(?:(?P<one>(?P<two>.)\W*(?P>one)\W*(?P=two)|)|(?P<three>(?P<four>.)\W*(?P>three)\W*(?P=four)|\W*.\W*))\W*$/Ii
Capture group count = 4
Max back reference = 4
Named capture groups:
  four    4
  one     1
  three   3
  two     2
May match empty string
Compile options: caseless
Overall options: anchored caseless
Subject length lower bound = 0
    1221
 0: 1221
 1: 1221
 2: 1
    Satan, oscillate my metallic sonatas!
 0: Satan, oscillate my metallic sonatas!
 1: <unset>
 2: <unset>
 3: Satan, oscillate my metallic sonatas
 4: S
    A man, a plan, a canal: Panama!
 0: A man, a plan, a canal: Panama!
 1: <unset>
 2: <unset>
 3: A man, a plan, a canal: Panama
 4: A
    Able was I ere I saw Elba.
 0: Able was I ere I saw Elba.
 1: <unset>
 2: <unset>
 3: Able was I ere I saw Elba
 4: A
\= Expect no match
    The quick brown fox
No match

/((?(R)a|b))\1(?1)?/I
Capture group count = 1
Max back reference = 1
Subject length lower bound = 2
  bb
 0: bb
 1: b
  bbaa
 0: bba
 1: b

/(.*)a/Is
Capture group count = 1
Compile options: dotall
Overall options: anchored dotall
Last code unit = 'a'
Subject length lower bound = 1

/(.*)a\1/Is
Capture group count = 1
Max back reference = 1
Options: dotall
Last code unit = 'a'
Subject length lower bound = 1

/(.*)a(b)\2/Is
Capture group count = 2
Max back reference = 2
Compile options: dotall
Overall options: anchored dotall
Last code unit = 'b'
Subject length lower bound = 3

/((.*)a|(.*)b)z/Is
Capture group count = 3
Compile options: dotall
Overall options: anchored dotall
Last code unit = 'z'
Subject length lower bound = 2

/((.*)a|(.*)b)z\1/Is
Capture group count = 3
Max back reference = 1
Options: dotall
Last code unit = 'z'
Subject length lower bound = 3

/((.*)a|(.*)b)z\2/Is
Capture group count = 3
Max back reference = 2
Options: dotall
Last code unit = 'z'
Subject length lower bound = 2

/((.*)a|(.*)b)z\3/Is
Capture group count = 3
Max back reference = 3
Options: dotall
Last code unit = 'z'
Subject length lower bound = 2

/((.*)a|^(.*)b)z\3/Is
Capture group count = 3
Max back reference = 3
Compile options: dotall
Overall options: anchored dotall
Last code unit = 'z'
Subject length lower bound = 2

/(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)a/Is
Capture group count = 31
May match empty string
Compile options: dotall
Overall options: anchored dotall
Subject length lower bound = 0

/(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)a\31/Is
Capture group count = 31
Max back reference = 31
May match empty string
Options: dotall
Subject length lower bound = 0

/(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)|(.*)a\32/Is
Capture group count = 32
Max back reference = 32
May match empty string
Options: dotall
Subject length lower bound = 0

/(a)(bc)/IB,no_auto_capture
------------------------------------------------------------------
        Bra
        Bra
        a
        Ket
        Bra
        bc
        Ket
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Options: no_auto_capture
First code unit = 'a'
Last code unit = 'c'
Subject length lower bound = 3
  abc
 0: abc

/(?P<one>a)(bc)/IB,no_auto_capture
------------------------------------------------------------------
        Bra
        CBra 1
        a
        Ket
        Bra
        bc
        Ket
        Ket
        End
------------------------------------------------------------------
Capture group count = 1
Named capture groups:
  one   1
Options: no_auto_capture
First code unit = 'a'
Last code unit = 'c'
Subject length lower bound = 3
  abc
 0: abc
 1: a

/(a)(?P<named>bc)/IB,no_auto_capture
------------------------------------------------------------------
        Bra
        Bra
        a
        Ket
        CBra 1
        bc
        Ket
        Ket
        End
------------------------------------------------------------------
Capture group count = 1
Named capture groups:
  named   1
Options: no_auto_capture
First code unit = 'a'
Last code unit = 'c'
Subject length lower bound = 3

/(aaa(?C1)bbb|ab)/I
Capture group count = 1
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 2
   aaabbb
--->aaabbb
  1 ^  ^       b
 0: aaabbb
 1: aaabbb
   aaabbb\=callout_data=0
--->aaabbb
  1 ^  ^       b
 0: aaabbb
 1: aaabbb
   aaabbb\=callout_data=1
--->aaabbb
  1 ^  ^       b
Callout data = 1
 0: ab
 1: ab
\= Expect no match
   aaabbb\=callout_data=-1
--->aaabbb
  1 ^  ^       b
Callout data = -1
No match

/ab(?P<one>cd)ef(?P<two>gh)/I
Capture group count = 2
Named capture groups:
  one   1
  two   2
First code unit = 'a'
Last code unit = 'h'
Subject length lower bound = 8
    abcdefgh
 0: abcdefgh
 1: cd
 2: gh
    abcdefgh\=copy=1,get=two
 0: abcdefgh
 1: cd
 2: gh
 1C cd (2)
  G gh (2) two (group 2)
    abcdefgh\=copy=one,copy=two
 0: abcdefgh
 1: cd
 2: gh
  C cd (2) one (group 1)
  C gh (2) two (group 2)
    abcdefgh\=copy=three
 0: abcdefgh
 1: cd
 2: gh
Number not found for group 'three'
Copy substring 'three' failed (-49): unknown substring

/(?P<Tes>)(?P<Test>)/IB
------------------------------------------------------------------
        Bra
        CBra 1
        Ket
        CBra 2
        Ket
        Ket
        End
------------------------------------------------------------------
Capture group count = 2
Named capture groups:
  Tes    1
  Test   2
May match empty string
Subject length lower bound = 0

/(?P<Test>)(?P<Tes>)/IB
------------------------------------------------------------------
        Bra
        CBra 1
        Ket
        CBra 2
        Ket
        Ket
        End
------------------------------------------------------------------
Capture group count = 2
Named capture groups:
  Tes    2
  Test   1
May match empty string
Subject length lower bound = 0

/(?P<Z>zz)(?P<A>aa)/I
Capture group count = 2
Named capture groups:
  A   2
  Z   1
First code unit = 'z'
Last code unit = 'a'
Subject length lower bound = 4
    zzaa\=copy=Z
 0: zzaa
 1: zz
 2: aa
  C zz (2) Z (group 1)
    zzaa\=copy=A
 0: zzaa
 1: zz
 2: aa
  C aa (2) A (group 2)

/(?P<x>eks)(?P<x>eccs)/I
Failed: error 143 at offset 16: two named subpatterns have the same name (PCRE2_DUPNAMES not set)

/(?P<abc>abc(?P<def>def)(?P<abc>xyz))/I
Failed: error 143 at offset 31: two named subpatterns have the same name (PCRE2_DUPNAMES not set)

"\[((?P<elem>\d+)(,(?P>elem))*)\]"I
Capture group count = 3
Named capture groups:
  elem   2
First code unit = '['
Last code unit = ']'
Subject length lower bound = 3
    [10,20,30,5,5,4,4,2,43,23,4234]
 0: [10,20,30,5,5,4,4,2,43,23,4234]
 1: 10,20,30,5,5,4,4,2,43,23,4234
 2: 10
 3: ,4234
\= Expect no match
    []
No match

"\[((?P<elem>\d+)(,(?P>elem))*)?\]"I
Capture group count = 3
Named capture groups:
  elem   2
First code unit = '['
Last code unit = ']'
Subject length lower bound = 2
    [10,20,30,5,5,4,4,2,43,23,4234]
 0: [10,20,30,5,5,4,4,2,43,23,4234]
 1: 10,20,30,5,5,4,4,2,43,23,4234
 2: 10
 3: ,4234
    []
 0: []

/(a(b(?2)c))?/IB
------------------------------------------------------------------
        Bra
        Brazero
        CBra 1
        a
        CBra 2
        b
        Recurse
        c
        Ket
        Ket
        Ket
        End
------------------------------------------------------------------
Capture group count = 2
May match empty string
Subject length lower bound = 0

/(a(b(?2)c))*/IB
------------------------------------------------------------------
        Bra
        Brazero
        CBra 1
        a
        CBra 2
        b
        Recurse
        c
        Ket
        KetRmax
        Ket
        End
------------------------------------------------------------------
Capture group count = 2
May match empty string
Subject length lower bound = 0

/(a(b(?2)c)){0,2}/IB
------------------------------------------------------------------
        Bra
        Brazero
        Bra
        CBra 1
        a
        CBra 2
        b
        Recurse
        c
        Ket
        Ket
        Brazero
        CBra 1
        a
        CBra 2
        b
        Recurse
        c
        Ket
        Ket
        Ket
        Ket
        End
------------------------------------------------------------------
Capture group count = 2
May match empty string
Subject length lower bound = 0

/[ab]{1}+/B
------------------------------------------------------------------
        Bra
        [ab]
        Ket
        End
------------------------------------------------------------------

/()(?1){1}/B
------------------------------------------------------------------
        Bra
        CBra 1
        Ket
        Recurse
        Ket
        End
------------------------------------------------------------------

/()(?1)/B
------------------------------------------------------------------
        Bra
        CBra 1
        Ket
        Recurse
        Ket
        End
------------------------------------------------------------------

/((w\/|-|with)*(free|immediate)*.*?shipping\s*[!.-]*)/Ii
Capture group count = 3
Options: caseless
Last code unit = 'g' (caseless)
Subject length lower bound = 8
     Baby Bjorn Active Carrier - With free SHIPPING!!
 0: Baby Bjorn Active Carrier - With free SHIPPING!!
 1: Baby Bjorn Active Carrier - With free SHIPPING!!

/((w\/|-|with)*(free|immediate)*.*?shipping\s*[!.-]*)/Ii
Capture group count = 3
Options: caseless
Last code unit = 'g' (caseless)
Subject length lower bound = 8
     Baby Bjorn Active Carrier - With free SHIPPING!!
 0: Baby Bjorn Active Carrier - With free SHIPPING!!
 1: Baby Bjorn Active Carrier - With free SHIPPING!!

/a*.*b/IB
------------------------------------------------------------------
        Bra
        a*
        Any*
        b
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Last code unit = 'b'
Subject length lower bound = 1

/(a|b)*.?c/IB
------------------------------------------------------------------
        Bra
        Brazero
        CBra 1
        a
        Alt
        b
        KetRmax
        Any?
        c
        Ket
        End
------------------------------------------------------------------
Capture group count = 1
Last code unit = 'c'
Subject length lower bound = 1

/abc(?C255)de(?C)f/IB
------------------------------------------------------------------
        Bra
        abc
        Callout 255 10 1
        de
        Callout 0 16 1
        f
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
First code unit = 'a'
Last code unit = 'f'
Subject length lower bound = 6

/abcde/IB,auto_callout
------------------------------------------------------------------
        Bra
        Callout 255 0 1
        a
        Callout 255 1 1
        b
        Callout 255 2 1
        c
        Callout 255 3 1
        d
        Callout 255 4 1
        e
        Callout 255 5 0
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Options: auto_callout
First code unit = 'a'
Last code unit = 'e'
Subject length lower bound = 5
  abcde
--->abcde
 +0 ^         a
 +1 ^^        b
 +2 ^ ^       c
 +3 ^  ^      d
 +4 ^   ^     e
 +5 ^    ^    End of pattern
 0: abcde
\= Expect no match
  abcdfe
--->abcdfe
 +0 ^          a
 +1 ^^         b
 +2 ^ ^        c
 +3 ^  ^       d
 +4 ^   ^      e
No match

/a*b/IB,auto_callout
------------------------------------------------------------------
        Bra
        Callout 255 0 2
        a*+
        Callout 255 2 1
        b
        Callout 255 3 0
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Options: auto_callout
Starting code units: a b 
Last code unit = 'b'
Subject length lower bound = 1
  ab
--->ab
 +0 ^      a*
 +2 ^^     b
 +3 ^ ^    End of pattern
 0: ab
  aaaab
--->aaaab
 +0 ^         a*
 +2 ^   ^     b
 +3 ^    ^    End of pattern
 0: aaaab
  aaaacb
--->aaaacb
 +0 ^          a*
 +2 ^   ^      b
 +0  ^         a*
 +2  ^  ^      b
 +0   ^        a*
 +2   ^ ^      b
 +0    ^       a*
 +2    ^^      b
 +0      ^     a*
 +2      ^     b
 +3      ^^    End of pattern
 0: b

/a*b/IB,auto_callout
------------------------------------------------------------------
        Bra
        Callout 255 0 2
        a*+
        Callout 255 2 1
        b
        Callout 255 3 0
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Options: auto_callout
Starting code units: a b 
Last code unit = 'b'
Subject length lower bound = 1
  ab
--->ab
 +0 ^      a*
 +2 ^^     b
 +3 ^ ^    End of pattern
 0: ab
  aaaab
--->aaaab
 +0 ^         a*
 +2 ^   ^     b
 +3 ^    ^    End of pattern
 0: aaaab
  aaaacb
--->aaaacb
 +0 ^          a*
 +2 ^   ^      b
 +0  ^         a*
 +2  ^  ^      b
 +0   ^        a*
 +2   ^ ^      b
 +0    ^       a*
 +2    ^^      b
 +0      ^     a*
 +2      ^     b
 +3      ^^    End of pattern
 0: b

/a+b/IB,auto_callout
------------------------------------------------------------------
        Bra
        Callout 255 0 2
        a++
        Callout 255 2 1
        b
        Callout 255 3 0
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Options: auto_callout
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 2
  ab
--->ab
 +0 ^      a+
 +2 ^^     b
 +3 ^ ^    End of pattern
 0: ab
  aaaab
--->aaaab
 +0 ^         a+
 +2 ^   ^     b
 +3 ^    ^    End of pattern
 0: aaaab
\= Expect no match
  aaaacb
--->aaaacb
 +0 ^          a+
 +2 ^   ^      b
 +0  ^         a+
 +2  ^  ^      b
 +0   ^        a+
 +2   ^ ^      b
 +0    ^       a+
 +2    ^^      b
No match

/(abc|def)x/IB,auto_callout
------------------------------------------------------------------
        Bra
        Callout 255 0 1
        CBra 1
        Callout 255 1 1
        a
        Callout 255 2 1
        b
        Callout 255 3 1
        c
        Callout 255 4 1
        Alt
        Callout 255 5 1
        d
        Callout 255 6 1
        e
        Callout 255 7 1
        f
        Callout 255 8 1
        Ket
        Callout 255 9 1
        x
        Callout 255 10 0
        Ket
        End
------------------------------------------------------------------
Capture group count = 1
Options: auto_callout
Starting code units: a d 
Last code unit = 'x'
Subject length lower bound = 4
  abcx
--->abcx
 +0 ^        (
 +1 ^        a
 +2 ^^       b
 +3 ^ ^      c
 +4 ^  ^     |
 +9 ^  ^     x
+10 ^   ^    End of pattern
 0: abcx
 1: abc
  defx
--->defx
 +0 ^        (
 +1 ^        a
 +5 ^        d
 +6 ^^       e
 +7 ^ ^      f
 +8 ^  ^     )
 +9 ^  ^     x
+10 ^   ^    End of pattern
 0: defx
 1: def
\= Expect no match
  abcdefzx
--->abcdefzx
 +0 ^            (
 +1 ^            a
 +2 ^^           b
 +3 ^ ^          c
 +4 ^  ^         |
 +9 ^  ^         x
 +5 ^            d
 +0    ^         (
 +1    ^         a
 +5    ^         d
 +6    ^^        e
 +7    ^ ^       f
 +8    ^  ^      )
 +9    ^  ^      x
No match

/(abc|def)x/IB,auto_callout
------------------------------------------------------------------
        Bra
        Callout 255 0 1
        CBra 1
        Callout 255 1 1
        a
        Callout 255 2 1
        b
        Callout 255 3 1
        c
        Callout 255 4 1
        Alt
        Callout 255 5 1
        d
        Callout 255 6 1
        e
        Callout 255 7 1
        f
        Callout 255 8 1
        Ket
        Callout 255 9 1
        x
        Callout 255 10 0
        Ket
        End
------------------------------------------------------------------
Capture group count = 1
Options: auto_callout
Starting code units: a d 
Last code unit = 'x'
Subject length lower bound = 4
  abcx
--->abcx
 +0 ^        (
 +1 ^        a
 +2 ^^       b
 +3 ^ ^      c
 +4 ^  ^     |
 +9 ^  ^     x
+10 ^   ^    End of pattern
 0: abcx
 1: abc
  defx
--->defx
 +0 ^        (
 +1 ^        a
 +5 ^        d
 +6 ^^       e
 +7 ^ ^      f
 +8 ^  ^     )
 +9 ^  ^     x
+10 ^   ^    End of pattern
 0: defx
 1: def
\= Expect no match
  abcdefzx
--->abcdefzx
 +0 ^            (
 +1 ^            a
 +2 ^^           b
 +3 ^ ^          c
 +4 ^  ^         |
 +9 ^  ^         x
 +5 ^            d
 +0    ^         (
 +1    ^         a
 +5    ^         d
 +6    ^^        e
 +7    ^ ^       f
 +8    ^  ^      )
 +9    ^  ^      x
No match

/(ab|cd){3,4}/I,auto_callout
Capture group count = 1
Options: auto_callout
Starting code units: a c 
Subject length lower bound = 6
  ababab
--->ababab
 +0 ^          (
 +1 ^          a
 +2 ^^         b
 +3 ^ ^        |
 +1 ^ ^        a
 +2 ^  ^       b
 +3 ^   ^      |
 +1 ^   ^      a
 +2 ^    ^     b
 +3 ^     ^    |
 +1 ^     ^    a
 +4 ^     ^    c
+12 ^     ^    End of pattern
 0: ababab
 1: ab
  abcdabcd
--->abcdabcd
 +0 ^            (
 +1 ^            a
 +2 ^^           b
 +3 ^ ^          |
 +1 ^ ^          a
 +4 ^ ^          c
 +5 ^  ^         d
 +6 ^   ^        ){3,4}
 +1 ^   ^        a
 +2 ^    ^       b
 +3 ^     ^      |
 +1 ^     ^      a
 +4 ^     ^      c
 +5 ^      ^     d
 +6 ^       ^    ){3,4}
+12 ^       ^    End of pattern
 0: abcdabcd
 1: cd
  abcdcdcdcdcd
--->abcdcdcdcdcd
 +0 ^                (
 +1 ^                a
 +2 ^^               b
 +3 ^ ^              |
 +1 ^ ^              a
 +4 ^ ^              c
 +5 ^  ^             d
 +6 ^   ^            ){3,4}
 +1 ^   ^            a
 +4 ^   ^            c
 +5 ^    ^           d
 +6 ^     ^          ){3,4}
 +1 ^     ^          a
 +4 ^     ^          c
 +5 ^      ^         d
 +6 ^       ^        ){3,4}
+12 ^       ^        End of pattern
 0: abcdcdcd
 1: cd

/([ab]{,4}c|xy)/IB,auto_callout
------------------------------------------------------------------
        Bra
        Callout 255 0 1
        CBra 1
        Callout 255 1 4
        [ab]
        Callout 255 5 1
        {
        Callout 255 6 1
        ,
        Callout 255 7 1
        4
        Callout 255 8 1
        }
        Callout 255 9 1
        c
        Callout 255 10 1
        Alt
        Callout 255 11 1
        x
        Callout 255 12 1
        y
        Callout 255 13 1
        Ket
        Callout 255 14 0
        Ket
        End
------------------------------------------------------------------
Capture group count = 1
Options: auto_callout
Starting code units: a b x 
Subject length lower bound = 2
\= Expect no match
    Note: that { does NOT introduce a quantifier
--->Note: that { does NOT introduce a quantifier
 +0         ^                                        (
 +1         ^                                        [ab]
 +5         ^^                                       {
+11         ^                                        x
 +0                                 ^                (
 +1                                 ^                [ab]
 +5                                 ^^               {
+11                                 ^                x
 +0                                     ^            (
 +1                                     ^            [ab]
 +5                                     ^^           {
+11                                     ^            x
No match

/([ab]{,4}c|xy)/IB,auto_callout
------------------------------------------------------------------
        Bra
        Callout 255 0 1
        CBra 1
        Callout 255 1 4
        [ab]
        Callout 255 5 1
        {
        Callout 255 6 1
        ,
        Callout 255 7 1
        4
        Callout 255 8 1
        }
        Callout 255 9 1
        c
        Callout 255 10 1
        Alt
        Callout 255 11 1
        x
        Callout 255 12 1
        y
        Callout 255 13 1
        Ket
        Callout 255 14 0
        Ket
        End
------------------------------------------------------------------
Capture group count = 1
Options: auto_callout
Starting code units: a b x 
Subject length lower bound = 2
\= Expect no match
    Note: that { does NOT introduce a quantifier
--->Note: that { does NOT introduce a quantifier
 +0         ^                                        (
 +1         ^                                        [ab]
 +5         ^^                                       {
+11         ^                                        x
 +0                                 ^                (
 +1                                 ^                [ab]
 +5                                 ^^               {
+11                                 ^                x
 +0                                     ^            (
 +1                                     ^            [ab]
 +5                                     ^^           {
+11                                     ^            x
No match

/([ab]{1,4}c|xy){4,5}?123/IB,auto_callout
------------------------------------------------------------------
        Bra
        Callout 255 0 1
        CBra 1
        Callout 255 1 9
        [ab]{1,4}+
        Callout 255 10 1
        c
        Callout 255 11 1
        Alt
        Callout 255 12 1
        x
        Callout 255 13 1
        y
        Callout 255 14 7
        Ket
        CBra 1
        Callout 255 1 9
        [ab]{1,4}+
        Callout 255 10 1
        c
        Callout 255 11 1
        Alt
        Callout 255 12 1
        x
        Callout 255 13 1
        y
        Callout 255 14 7
        Ket
        CBra 1
        Callout 255 1 9
        [ab]{1,4}+
        Callout 255 10 1
        c
        Callout 255 11 1
        Alt
        Callout 255 12 1
        x
        Callout 255 13 1
        y
        Callout 255 14 7
        Ket
        CBra 1
        Callout 255 1 9
        [ab]{1,4}+
        Callout 255 10 1
        c
        Callout 255 11 1
        Alt
        Callout 255 12 1
        x
        Callout 255 13 1
        y
        Callout 255 14 7
        Ket
        Braminzero
        CBra 1
        Callout 255 1 9
        [ab]{1,4}+
        Callout 255 10 1
        c
        Callout 255 11 1
        Alt
        Callout 255 12 1
        x
        Callout 255 13 1
        y
        Callout 255 14 7
        Ket
        Callout 255 21 1
        1
        Callout 255 22 1
        2
        Callout 255 23 1
        3
        Callout 255 24 0
        Ket
        End
------------------------------------------------------------------
Capture group count = 1
Options: auto_callout
Starting code units: a b x 
Last code unit = '3'
Subject length lower bound = 11
    aacaacaacaacaac123
--->aacaacaacaacaac123
 +0 ^                      (
 +1 ^                      [ab]{1,4}
+10 ^ ^                    c
+11 ^  ^                   |
 +1 ^  ^                   [ab]{1,4}
+10 ^    ^                 c
+11 ^     ^                |
 +1 ^     ^                [ab]{1,4}
+10 ^       ^              c
+11 ^        ^             |
 +1 ^        ^             [ab]{1,4}
+10 ^          ^           c
+11 ^           ^          |
+21 ^           ^          1
 +1 ^           ^          [ab]{1,4}
+10 ^             ^        c
+11 ^              ^       |
+21 ^              ^       1
+22 ^               ^      2
+23 ^                ^     3
+24 ^                 ^    End of pattern
 0: aacaacaacaacaac123
 1: aac

/\b.*/I
Capture group count = 0
Max lookbehind = 1
May match empty string
Subject length lower bound = 0
  ab cd\=offset=1
 0:  cd

/\b.*/Is
Capture group count = 0
Max lookbehind = 1
May match empty string
Options: dotall
Subject length lower bound = 0
  ab cd\=startoffset=1
 0:  cd

/(?!.bcd).*/I
Capture group count = 0
May match empty string
Subject length lower bound = 0
  Xbcd12345
 0: bcd12345

/abcde/I
Capture group count = 0
First code unit = 'a'
Last code unit = 'e'
Subject length lower bound = 5
    ab\=ps
Partial match: ab
    abc\=ps
Partial match: abc
    abcd\=ps
Partial match: abcd
    abcde\=ps
 0: abcde
    the quick brown abc\=ps
Partial match: abc
\= Expect no match\=ps
    the quick brown abxyz fox\=ps
No match

"^(0?[1-9]|[12][0-9]|3[01])/(0?[1-9]|1[012])/(20)?\d\d$"I
Capture group count = 3
Compile options: <none>
Overall options: anchored
Starting code units: 0 1 2 3 4 5 6 7 8 9 
Last code unit = '/'
Subject length lower bound = 6
    13/05/04\=ps
 0: 13/05/04
 1: 13
 2: 05
    13/5/2004\=ps
 0: 13/5/2004
 1: 13
 2: 5
 3: 20
    02/05/09\=ps
 0: 02/05/09
 1: 02
 2: 05
    1\=ps
Partial match: 1
    1/2\=ps
Partial match: 1/2
    1/2/0\=ps
Partial match: 1/2/0
    1/2/04\=ps
 0: 1/2/04
 1: 1
 2: 2
    0\=ps
Partial match: 0
    02/\=ps
Partial match: 02/
    02/0\=ps
Partial match: 02/0
    02/1\=ps
Partial match: 02/1
\= Expect no match\=ps
    \=ps
No match
    123\=ps
No match
    33/4/04\=ps
No match
    3/13/04\=ps
No match
    0/1/2003\=ps
No match
    0/\=ps
No match
    02/0/\=ps
No match
    02/13\=ps
No match

/0{0,2}ABC/I
Capture group count = 0
Starting code units: 0 A 
Last code unit = 'C'
Subject length lower bound = 3

/\d{3,}ABC/I
Capture group count = 0
Starting code units: 0 1 2 3 4 5 6 7 8 9 
Last code unit = 'C'
Subject length lower bound = 6

/\d*ABC/I
Capture group count = 0
Starting code units: 0 1 2 3 4 5 6 7 8 9 A 
Last code unit = 'C'
Subject length lower bound = 3

/[abc]+DE/I
Capture group count = 0
Starting code units: a b c 
Last code unit = 'E'
Subject length lower bound = 3

/[abc]?123/I
Capture group count = 0
Starting code units: 1 a b c 
Last code unit = '3'
Subject length lower bound = 3
    123\=ps
 0: 123
    a\=ps
Partial match: a
    b\=ps
Partial match: b
    c\=ps
Partial match: c
    c12\=ps
Partial match: c12
    c123\=ps
 0: c123

/^(?:\d){3,5}X/I
Capture group count = 0
Compile options: <none>
Overall options: anchored
Starting code units: 0 1 2 3 4 5 6 7 8 9 
Last code unit = 'X'
Subject length lower bound = 4
    1\=ps
Partial match: 1
    123\=ps
Partial match: 123
    123X
 0: 123X
    1234\=ps
Partial match: 1234
    1234X
 0: 1234X
    12345\=ps
Partial match: 12345
    12345X
 0: 12345X
\= Expect no match
    1X
No match
    123456\=ps
No match

"<(\w+)/?>(.)*</(\1)>"Igms
Capture group count = 3
Max back reference = 1
Options: dotall multiline
First code unit = '<'
Last code unit = '>'
Subject length lower bound = 7
    <!DOCTYPE seite SYSTEM "http://www.lco.lineas.de/xmlCms.dtd">\n<seite>\n<dokumenteninformation>\n<seitentitel>Partner der LCO</seitentitel>\n<sprache>de</sprache>\n<seitenbeschreibung>Partner der LINEAS Consulting\nGmbH</seitenbeschreibung>\n<schluesselworte>LINEAS Consulting GmbH Hamburg\nPartnerfirmen</schluesselworte>\n<revisit>30 days</revisit>\n<robots>index,follow</robots>\n<menueinformation>\n<aktiv>ja</aktiv>\n<menueposition>3</menueposition>\n<menuetext>Partner</menuetext>\n</menueinformation>\n<lastedited>\n<autor>LCO</autor>\n<firma>LINEAS Consulting</firma>\n<datum>15.10.2003</datum>\n</lastedited>\n</dokumenteninformation>\n<inhalt>\n\n<absatzueberschrift>Die Partnerfirmen der LINEAS Consulting\nGmbH</absatzueberschrift>\n\n<absatz><link ziel="http://www.ca.com/" zielfenster="_blank">\n<bild name="logo_ca.gif" rahmen="no"/></link> <link\nziel="http://www.ey.com/" zielfenster="_blank"><bild\nname="logo_euy.gif" rahmen="no"/></link>\n</absatz>\n\n<absatz><link ziel="http://www.cisco.de/" zielfenster="_blank">\n<bild name="logo_cisco.gif" rahmen="ja"/></link></absatz>\n\n<absatz><link ziel="http://www.atelion.de/"\nzielfenster="_blank"><bild\nname="logo_atelion.gif" rahmen="no"/></link>\n</absatz>\n\n<absatz><link ziel="http://www.line-information.de/"\nzielfenster="_blank">\n<bild name="logo_line_information.gif" rahmen="no"/></link>\n</absatz>\n\n<absatz><bild name="logo_aw.gif" rahmen="no"/></absatz>\n\n<absatz><link ziel="http://www.incognis.de/"\nzielfenster="_blank"><bild\nname="logo_incognis.gif" rahmen="no"/></link></absatz>\n\n<absatz><link ziel="http://www.addcraft.com/"\nzielfenster="_blank"><bild\nname="logo_addcraft.gif" rahmen="no"/></link></absatz>\n\n<absatz><link ziel="http://www.comendo.com/"\nzielfenster="_blank"><bild\nname="logo_comendo.gif" rahmen="no"/></link></absatz>\n\n</inhalt>\n</seite>\=jitstack=1024
 0: <seite>\x0a<dokumenteninformation>\x0a<seitentitel>Partner der LCO</seitentitel>\x0a<sprache>de</sprache>\x0a<seitenbeschreibung>Partner der LINEAS Consulting\x0aGmbH</seitenbeschreibung>\x0a<schluesselworte>LINEAS Consulting GmbH Hamburg\x0aPartnerfirmen</schluesselworte>\x0a<revisit>30 days</revisit>\x0a<robots>index,follow</robots>\x0a<menueinformation>\x0a<aktiv>ja</aktiv>\x0a<menueposition>3</menueposition>\x0a<menuetext>Partner</menuetext>\x0a</menueinformation>\x0a<lastedited>\x0a<autor>LCO</autor>\x0a<firma>LINEAS Consulting</firma>\x0a<datum>15.10.2003</datum>\x0a</lastedited>\x0a</dokumenteninformation>\x0a<inhalt>\x0a\x0a<absatzueberschrift>Die Partnerfirmen der LINEAS Consulting\x0aGmbH</absatzueberschrift>\x0a\x0a<absatz><link ziel="http://www.ca.com/" zielfenster="_blank">\x0a<bild name="logo_ca.gif" rahmen="no"/></link> <link\x0aziel="http://www.ey.com/" zielfenster="_blank"><bild\x0aname="logo_euy.gif" rahmen="no"/></link>\x0a</absatz>\x0a\x0a<absatz><link ziel="http://www.cisco.de/" zielfenster="_blank">\x0a<bild name="logo_cisco.gif" rahmen="ja"/></link></absatz>\x0a\x0a<absatz><link ziel="http://www.atelion.de/"\x0azielfenster="_blank"><bild\x0aname="logo_atelion.gif" rahmen="no"/></link>\x0a</absatz>\x0a\x0a<absatz><link ziel="http://www.line-information.de/"\x0azielfenster="_blank">\x0a<bild name="logo_line_information.gif" rahmen="no"/></link>\x0a</absatz>\x0a\x0a<absatz><bild name="logo_aw.gif" rahmen="no"/></absatz>\x0a\x0a<absatz><link ziel="http://www.incognis.de/"\x0azielfenster="_blank"><bild\x0aname="logo_incognis.gif" rahmen="no"/></link></absatz>\x0a\x0a<absatz><link ziel="http://www.addcraft.com/"\x0azielfenster="_blank"><bild\x0aname="logo_addcraft.gif" rahmen="no"/></link></absatz>\x0a\x0a<absatz><link ziel="http://www.comendo.com/"\x0azielfenster="_blank"><bild\x0aname="logo_comendo.gif" rahmen="no"/></link></absatz>\x0a\x0a</inhalt>\x0a</seite>
 1: seite
 2: \x0a
 3: seite

/line\nbreak/I
Capture group count = 0
Contains explicit CR or LF match
First code unit = 'l'
Last code unit = 'k'
Subject length lower bound = 10
    this is a line\nbreak
 0: line\x0abreak
    line one\nthis is a line\nbreak in the second line
 0: line\x0abreak

/line\nbreak/I,firstline
Capture group count = 0
Contains explicit CR or LF match
Options: firstline
First code unit = 'l'
Last code unit = 'k'
Subject length lower bound = 10
    this is a line\nbreak
 0: line\x0abreak
\= Expect no match
    line one\nthis is a line\nbreak in the second line
No match

/line\nbreak/Im,firstline
Capture group count = 0
Contains explicit CR or LF match
Options: firstline multiline
First code unit = 'l'
Last code unit = 'k'
Subject length lower bound = 10
    this is a line\nbreak
 0: line\x0abreak
\= Expect no match
    line one\nthis is a line\nbreak in the second line
No match

/(?i)(?-i)AbCd/I
Capture group count = 0
First code unit = 'A'
Last code unit = 'd'
Subject length lower bound = 4
    AbCd
 0: AbCd
\= Expect no match
    abcd
No match

/a{11111111111111111111}/I
Failed: error 105 at offset 8: number too big in {} quantifier

/(){64294967295}/I
Failed: error 105 at offset 9: number too big in {} quantifier

/(){2,4294967295}/I
Failed: error 105 at offset 11: number too big in {} quantifier

"(?i:a)(?i:b)(?i:c)(?i:d)(?i:e)(?i:f)(?i:g)(?i:h)(?i:i)(?i:j)(k)(?i:l)A\1B"I
Capture group count = 1
Max back reference = 1
First code unit = 'a' (caseless)
Last code unit = 'B'
Subject length lower bound = 15
    abcdefghijklAkB
 0: abcdefghijklAkB
 1: k

"(?P<n0>a)(?P<n1>b)(?P<n2>c)(?P<n3>d)(?P<n4>e)(?P<n5>f)(?P<n6>g)(?P<n7>h)(?P<n8>i)(?P<n9>j)(?P<n10>k)(?P<n11>l)A\11B"I
Capture group count = 12
Max back reference = 11
Named capture groups:
  n0    1
  n1    2
  n10  11
  n11  12
  n2    3
  n3    4
  n4    5
  n5    6
  n6    7
  n7    8
  n8    9
  n9   10
First code unit = 'a'
Last code unit = 'B'
Subject length lower bound = 15
    abcdefghijklAkB
 0: abcdefghijklAkB
 1: a
 2: b
 3: c
 4: d
 5: e
 6: f
 7: g
 8: h
 9: i
10: j
11: k
12: l

"(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)A\11B"I
Capture group count = 12
Max back reference = 11
First code unit = 'a'
Last code unit = 'B'
Subject length lower bound = 15
    abcdefghijklAkB
 0: abcdefghijklAkB
 1: a
 2: b
 3: c
 4: d
 5: e
 6: f
 7: g
 8: h
 9: i
10: j
11: k
12: l

"(?P<name0>a)(?P<name1>a)(?P<name2>a)(?P<name3>a)(?P<name4>a)(?P<name5>a)(?P<name6>a)(?P<name7>a)(?P<name8>a)(?P<name9>a)(?P<name10>a)(?P<name11>a)(?P<name12>a)(?P<name13>a)(?P<name14>a)(?P<name15>a)(?P<name16>a)(?P<name17>a)(?P<name18>a)(?P<name19>a)(?P<name20>a)(?P<name21>a)(?P<name22>a)(?P<name23>a)(?P<name24>a)(?P<name25>a)(?P<name26>a)(?P<name27>a)(?P<name28>a)(?P<name29>a)(?P<name30>a)(?P<name31>a)(?P<name32>a)(?P<name33>a)(?P<name34>a)(?P<name35>a)(?P<name36>a)(?P<name37>a)(?P<name38>a)(?P<name39>a)(?P<name40>a)(?P<name41>a)(?P<name42>a)(?P<name43>a)(?P<name44>a)(?P<name45>a)(?P<name46>a)(?P<name47>a)(?P<name48>a)(?P<name49>a)(?P<name50>a)(?P<name51>a)(?P<name52>a)(?P<name53>a)(?P<name54>a)(?P<name55>a)(?P<name56>a)(?P<name57>a)(?P<name58>a)(?P<name59>a)(?P<name60>a)(?P<name61>a)(?P<name62>a)(?P<name63>a)(?P<name64>a)(?P<name65>a)(?P<name66>a)(?P<name67>a)(?P<name68>a)(?P<name69>a)(?P<name70>a)(?P<name71>a)(?P<name72>a)(?P<name73>a)(?P<name74>a)(?P<name75>a)(?P<name76>a)(?P<name77>a)(?P<name78>a)(?P<name79>a)(?P<name80>a)(?P<name81>a)(?P<name82>a)(?P<name83>a)(?P<name84>a)(?P<name85>a)(?P<name86>a)(?P<name87>a)(?P<name88>a)(?P<name89>a)(?P<name90>a)(?P<name91>a)(?P<name92>a)(?P<name93>a)(?P<name94>a)(?P<name95>a)(?P<name96>a)(?P<name97>a)(?P<name98>a)(?P<name99>a)(?P<name100>a)"I
Capture group count = 101
Named capture groups:
  name0     1
  name1     2
  name10   11
  name100 101
  name11   12
  name12   13
  name13   14
  name14   15
  name15   16
  name16   17
  name17   18
  name18   19
  name19   20
  name2     3
  name20   21
  name21   22
  name22   23
  name23   24
  name24   25
  name25   26
  name26   27
  name27   28
  name28   29
  name29   30
  name3     4
  name30   31
  name31   32
  name32   33
  name33   34
  name34   35
  name35   36
  name36   37
  name37   38
  name38   39
  name39   40
  name4     5
  name40   41
  name41   42
  name42   43
  name43   44
  name44   45
  name45   46
  name46   47
  name47   48
  name48   49
  name49   50
  name5     6
  name50   51
  name51   52
  name52   53
  name53   54
  name54   55
  name55   56
  name56   57
  name57   58
  name58   59
  name59   60
  name6     7
  name60   61
  name61   62
  name62   63
  name63   64
  name64   65
  name65   66
  name66   67
  name67   68
  name68   69
  name69   70
  name7     8
  name70   71
  name71   72
  name72   73
  name73   74
  name74   75
  name75   76
  name76   77
  name77   78
  name78   79
  name79   80
  name8     9
  name80   81
  name81   82
  name82   83
  name83   84
  name84   85
  name85   86
  name86   87
  name87   88
  name88   89
  name89   90
  name9    10
  name90   91
  name91   92
  name92   93
  name93   94
  name94   95
  name95   96
  name96   97
  name97   98
  name98   99
  name99  100
First code unit = 'a'
Last code unit = 'a'
Subject length lower bound = 101
    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
Matched, but too many substrings
 0: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
 1: a
 2: a
 3: a
 4: a
 5: a
 6: a
 7: a
 8: a
 9: a
10: a
11: a
12: a
13: a
14: a

"(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)(a)"I
Capture group count = 101
First code unit = 'a'
Last code unit = 'a'
Subject length lower bound = 101
    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
Matched, but too many substrings
 0: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
 1: a
 2: a
 3: a
 4: a
 5: a
 6: a
 7: a
 8: a
 9: a
10: a
11: a
12: a
13: a
14: a

/[^()]*(?:\((?R)\)[^()]*)*/I
Capture group count = 0
May match empty string
Subject length lower bound = 0
    (this(and)that
 0: 
    (this(and)that)
 0: (this(and)that)
    (this(and)that)stuff
 0: (this(and)that)stuff

/[^()]*(?:\((?>(?R))\)[^()]*)*/I
Capture group count = 0
May match empty string
Subject length lower bound = 0
    (this(and)that
 0: 
    (this(and)that)
 0: (this(and)that)

/[^()]*(?:\((?R)\))*[^()]*/I
Capture group count = 0
May match empty string
Subject length lower bound = 0
    (this(and)that
 0: 
    (this(and)that)
 0: (this(and)that)

/(?:\((?R)\))*[^()]*/I
Capture group count = 0
May match empty string
Subject length lower bound = 0
    (this(and)that
 0: 
    (this(and)that)
 0: 
    ((this))
 0: ((this))

/(?:\((?R)\))|[^()]*/I
Capture group count = 0
May match empty string
Subject length lower bound = 0
    (this(and)that
 0: 
    (this(and)that)
 0: 
    (this)
 0: (this)
    ((this))
 0: ((this))

/\x{0000ff}/I
Capture group count = 0
First code unit = \xff
Subject length lower bound = 1

/^((?P<A>a1)|(?P<A>a2)b)/I
Failed: error 143 at offset 18: two named subpatterns have the same name (PCRE2_DUPNAMES not set)

/^((?P<A>a1)|(?P<A>a2)b)/I,dupnames
Capture group count = 3
Named capture groups:
  A   2
  A   3
Compile options: dupnames
Overall options: anchored dupnames
First code unit = 'a'
Subject length lower bound = 2
    a1b\=copy=A
 0: a1
 1: a1
 2: a1
  C a1 (2) A (non-unique)
    a2b\=copy=A
 0: a2b
 1: a2b
 2: <unset>
 3: a2
  C a2 (2) A (non-unique)
    a1b\=copy=Z,copy=A
 0: a1
 1: a1
 2: a1
Number not found for group 'Z'
Copy substring 'Z' failed (-49): unknown substring
  C a1 (2) A (non-unique)

/(?|(?<a>)(?<b>)(?<a>)|(?<a>)(?<b>)(?<a>))/I,dupnames
Capture group count = 3
Named capture groups:
  a   1
  a   3
  b   2
May match empty string
Options: dupnames
Subject length lower bound = 0

/^(?P<A>a)(?P<A>b)/I,dupnames
Capture group count = 2
Named capture groups:
  A   1
  A   2
Compile options: dupnames
Overall options: anchored dupnames
First code unit = 'a'
Subject length lower bound = 2
    ab\=copy=A
 0: ab
 1: a
 2: b
  C a (1) A (non-unique)

/^(?P<A>a)(?P<A>b)|cd/I,dupnames
Capture group count = 2
Named capture groups:
  A   1
  A   2
Options: dupnames
Starting code units: a c 
Subject length lower bound = 2
    ab\=copy=A
 0: ab
 1: a
 2: b
  C a (1) A (non-unique)
    cd\=copy=A
 0: cd
Copy substring 'A' failed (-55): requested value is not set

/^(?P<A>a)(?P<A>b)|cd(?P<A>ef)(?P<A>gh)/I,dupnames
Capture group count = 4
Named capture groups:
  A   1
  A   2
  A   3
  A   4
Options: dupnames
Starting code units: a c 
Subject length lower bound = 2
    cdefgh\=copy=A
 0: cdefgh
 1: <unset>
 2: <unset>
 3: ef
 4: gh
  C ef (2) A (non-unique)

/^((?P<A>a1)|(?P<A>a2)b)/I,dupnames
Capture group count = 3
Named capture groups:
  A   2
  A   3
Compile options: dupnames
Overall options: anchored dupnames
First code unit = 'a'
Subject length lower bound = 2
    a1b\=get=A
 0: a1
 1: a1
 2: a1
  G a1 (2) A (non-unique)
    a2b\=get=A
 0: a2b
 1: a2b
 2: <unset>
 3: a2
  G a2 (2) A (non-unique)
    a1b\=get=Z,get=A
 0: a1
 1: a1
 2: a1
Number not found for group 'Z'
Get substring 'Z' failed (-49): unknown substring
  G a1 (2) A (non-unique)

/^(?P<A>a)(?P<A>b)/I,dupnames
Capture group count = 2
Named capture groups:
  A   1
  A   2
Compile options: dupnames
Overall options: anchored dupnames
First code unit = 'a'
Subject length lower bound = 2
    ab\=get=A
 0: ab
 1: a
 2: b
  G a (1) A (non-unique)

/^(?P<A>a)(?P<A>b)|cd/I,dupnames
Capture group count = 2
Named capture groups:
  A   1
  A   2
Options: dupnames
Starting code units: a c 
Subject length lower bound = 2
    ab\=get=A
 0: ab
 1: a
 2: b
  G a (1) A (non-unique)
    cd\=get=A
 0: cd
Get substring 'A' failed (-55): requested value is not set

/^(?P<A>a)(?P<A>b)|cd(?P<A>ef)(?P<A>gh)/I,dupnames
Capture group count = 4
Named capture groups:
  A   1
  A   2
  A   3
  A   4
Options: dupnames
Starting code units: a c 
Subject length lower bound = 2
    cdefgh\=get=A
 0: cdefgh
 1: <unset>
 2: <unset>
 3: ef
 4: gh
  G ef (2) A (non-unique)

/(?J)^((?P<A>a1)|(?P<A>a2)b)/I
Capture group count = 3
Named capture groups:
  A   2
  A   3
Compile options: <none>
Overall options: anchored
Duplicate name status changes
First code unit = 'a'
Subject length lower bound = 2
    a1b\=copy=A
 0: a1
 1: a1
 2: a1
  C a1 (2) A (non-unique)
    a2b\=copy=A
 0: a2b
 1: a2b
 2: <unset>
 3: a2
  C a2 (2) A (non-unique)

/^(?P<A>a) (?J:(?P<B>b)(?P<B>c)) (?P<A>d)/I
Failed: error 143 at offset 38: two named subpatterns have the same name (PCRE2_DUPNAMES not set)

# In this next test, J is not set at the outer level; consequently it isn't set
# in the pattern's options; consequently pcre2_substring_get_byname() produces
# a random value.

/^(?P<A>a) (?J:(?P<B>b)(?P<B>c)) (?P<C>d)/I
Capture group count = 4
Named capture groups:
  A   1
  B   2
  B   3
  C   4
Compile options: <none>
Overall options: anchored
Duplicate name status changes
First code unit = 'a'
Subject length lower bound = 6
    a bc d\=copy=A,copy=B,copy=C
 0: a bc d
 1: a
 2: b
 3: c
 4: d
  C a (1) A (group 1)
  C b (1) B (non-unique)
  C d (1) C (group 4)

/^(?P<A>a)?(?(A)a|b)/I
Capture group count = 1
Max back reference = 1
Named capture groups:
  A   1
Compile options: <none>
Overall options: anchored
Subject length lower bound = 1
    aabc
 0: aa
 1: a
    bc
 0: b
\= Expect no match
    abc
No match

/(?:(?(ZZ)a|b)(?P<ZZ>X))+/I
Capture group count = 1
Max back reference = 1
Named capture groups:
  ZZ   1
Last code unit = 'X'
Subject length lower bound = 2
    bXaX
 0: bXaX
 1: X

/(?:(?(2y)a|b)(X))+/I
Failed: error 124 at offset 7: missing closing parenthesis for condition

/(?:(?(ZA)a|b)(?P<ZZ>X))+/I
Failed: error 115 at offset 6: reference to non-existent subpattern

/(?:(?(ZZ)a|b)(?(ZZ)a|b)(?P<ZZ>X))+/I
Capture group count = 1
Max back reference = 1
Named capture groups:
  ZZ   1
Last code unit = 'X'
Subject length lower bound = 3
    bbXaaX
 0: bbXaaX
 1: X

/(?:(?(ZZ)a|\(b\))\\(?P<ZZ>X))+/I
Capture group count = 1
Max back reference = 1
Named capture groups:
  ZZ   1
Last code unit = 'X'
Subject length lower bound = 3
    (b)\\Xa\\X
 0: (b)\Xa\X
 1: X

/(?P<ABC/I
Failed: error 142 at offset 7: syntax error in subpattern name (missing terminator?)

/(?:(?(A)(?P=A)a|b)(?P<A>X|Y))+/I
Capture group count = 1
Max back reference = 1
Named capture groups:
  A   1
Subject length lower bound = 2
    bXXaYYaY
 0: bXXaYYaY
 1: Y
    bXYaXXaX
 0: bX
 1: X

/()()()()()()()()()(?:(?(A)(?P=A)a|b)(?P<A>X|Y))+/I
Capture group count = 10
Max back reference = 10
Named capture groups:
  A  10
Subject length lower bound = 2
    bXXaYYaY
 0: bXXaYYaY
 1: 
 2: 
 3: 
 4: 
 5: 
 6: 
 7: 
 8: 
 9: 
10: Y

/\s*,\s*/I
Capture group count = 0
Starting code units: \x09 \x0a \x0b \x0c \x0d \x20 , 
Last code unit = ','
Subject length lower bound = 1
    \x0b,\x0b
 0: \x0b,\x0b
    \x0c,\x0d
 0: \x0c,\x0d

/^abc/Im,newline=lf
Capture group count = 0
Options: multiline
Forced newline is LF
First code unit at start or follows newline
Last code unit = 'c'
Subject length lower bound = 3
    xyz\nabc
 0: abc
    xyz\r\nabc
 0: abc
\= Expect no match
    xyz\rabc
No match
    xyzabc\r
No match
    xyzabc\rpqr
No match
    xyzabc\r\n
No match
    xyzabc\r\npqr
No match

/^abc/Im,newline=crlf
Capture group count = 0
Options: multiline
Forced newline is CRLF
First code unit at start or follows newline
Last code unit = 'c'
Subject length lower bound = 3
    xyz\r\nabclf>
 0: abc
\= Expect no match
    xyz\nabclf
No match
    xyz\rabclf
No match

/^abc/Im,newline=cr
Capture group count = 0
Options: multiline
Forced newline is CR
First code unit at start or follows newline
Last code unit = 'c'
Subject length lower bound = 3
    xyz\rabc
 0: abc
\= Expect no match
    xyz\nabc
No match
    xyz\r\nabc
No match

/^abc/Im,newline=bad
** Invalid value in 'newline=bad'

/.*/I,newline=lf
Capture group count = 0
May match empty string
Forced newline is LF
First code unit at start or follows newline
Subject length lower bound = 0
    abc\ndef
 0: abc
    abc\rdef
 0: abc\x0ddef
    abc\r\ndef
 0: abc\x0d

/.*/I,newline=cr
Capture group count = 0
May match empty string
Forced newline is CR
First code unit at start or follows newline
Subject length lower bound = 0
    abc\ndef
 0: abc\x0adef
    abc\rdef
 0: abc
    abc\r\ndef
 0: abc

/.*/I,newline=crlf
Capture group count = 0
May match empty string
Forced newline is CRLF
First code unit at start or follows newline
Subject length lower bound = 0
    abc\ndef
 0: abc\x0adef
    abc\rdef
 0: abc\x0ddef
    abc\r\ndef
 0: abc

/\w+(.)(.)?def/Is
Capture group count = 2
Options: dotall
Starting code units: 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P 
  Q R S T U V W X Y Z _ a b c d e f g h i j k l m n o p q r s t u v w x y z 
Last code unit = 'f'
Subject length lower bound = 5
    abc\ndef
 0: abc\x0adef
 1: \x0a
    abc\rdef
 0: abc\x0ddef
 1: \x0d
    abc\r\ndef
 0: abc\x0d\x0adef
 1: \x0d
 2: \x0a

/(?P<B>25[0-5]|2[0-4]\d|[01]?\d?\d)(?:\.(?P>B)){3}/I
Capture group count = 1
Named capture groups:
  B   1
Starting code units: 0 1 2 3 4 5 6 7 8 9 
Last code unit = '.'
Subject length lower bound = 7

/()()()()()()()()()()()()()()()()()()()()
 ()()()()()()()()()()()()()()()()()()()()
 ()()()()()()()()()()()()()()()()()()()()
 ()()()()()()()()()()()()()()()()()()()()
 ()()()()()()()()()()()()()()()()()()()()
 (.(.))/Ix
Capture group count = 102
Options: extended
Subject length lower bound = 2
    XY\=ovector=133
 0: XY
 1: 
 2: 
 3: 
 4: 
 5: 
 6: 
 7: 
 8: 
 9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 
65: 
66: 
67: 
68: 
69: 
70: 
71: 
72: 
73: 
74: 
75: 
76: 
77: 
78: 
79: 
80: 
81: 
82: 
83: 
84: 
85: 
86: 
87: 
88: 
89: 
90: 
91: 
92: 
93: 
94: 
95: 
96: 
97: 
98: 
99: 
100: 
101: XY
102: Y

/(a*b|(?i:c*(?-i)d))/I
Capture group count = 1
Starting code units: C a b c d 
Subject length lower bound = 1

/()[ab]xyz/I
Capture group count = 1
Starting code units: a b 
Last code unit = 'z'
Subject length lower bound = 4

/(|)[ab]xyz/I
Capture group count = 1
Starting code units: a b 
Last code unit = 'z'
Subject length lower bound = 4

/(|c)[ab]xyz/I
Capture group count = 1
Starting code units: a b c 
Last code unit = 'z'
Subject length lower bound = 4

/(|c?)[ab]xyz/I
Capture group count = 1
Starting code units: a b c 
Last code unit = 'z'
Subject length lower bound = 4

/(d?|c?)[ab]xyz/I
Capture group count = 1
Starting code units: a b c d 
Last code unit = 'z'
Subject length lower bound = 4

/(d?|c)[ab]xyz/I
Capture group count = 1
Starting code units: a b c d 
Last code unit = 'z'
Subject length lower bound = 4

/^a*b\d/IB
------------------------------------------------------------------
        Bra
        ^
        a*+
        b
        \d
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Compile options: <none>
Overall options: anchored
Starting code units: a b 
Last code unit = 'b'
Subject length lower bound = 2

/^a*+b\d/IB
------------------------------------------------------------------
        Bra
        ^
        a*+
        b
        \d
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Compile options: <none>
Overall options: anchored
Starting code units: a b 
Last code unit = 'b'
Subject length lower bound = 2

/^a*?b\d/IB
------------------------------------------------------------------
        Bra
        ^
        a*+
        b
        \d
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Compile options: <none>
Overall options: anchored
Starting code units: a b 
Last code unit = 'b'
Subject length lower bound = 2

/^a+A\d/IB
------------------------------------------------------------------
        Bra
        ^
        a++
        A
        \d
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Compile options: <none>
Overall options: anchored
First code unit = 'a'
Last code unit = 'A'
Subject length lower bound = 3
    aaaA5
 0: aaaA5
\= Expect no match
    aaaa5
No match

/^a*A\d/IBi
------------------------------------------------------------------
        Bra
        ^
     /i a*
     /i A
        \d
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Compile options: caseless
Overall options: anchored caseless
Starting code units: A a 
Last code unit = 'A' (caseless)
Subject length lower bound = 2
    aaaA5
 0: aaaA5
    aaaa5
 0: aaaa5
    a5 
 0: a5

/(a*|b*)[cd]/I
Capture group count = 1
Starting code units: a b c d 
Subject length lower bound = 1

/(a+|b*)[cd]/I
Capture group count = 1
Starting code units: a b c d 
Subject length lower bound = 1

/(a*|b+)[cd]/I
Capture group count = 1
Starting code units: a b c d 
Subject length lower bound = 1

/(a+|b+)[cd]/I
Capture group count = 1
Starting code units: a b 
Subject length lower bound = 2

/((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
 ((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((
 (((
 a
 ))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
 ))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
 )))
/Ix
Capture group count = 203
Options: extended
First code unit = 'a'
Subject length lower bound = 1
  large nest
Matched, but too many substrings
 0: a
 1: a
 2: a
 3: a
 4: a
 5: a
 6: a
 7: a
 8: a
 9: a
10: a
11: a
12: a
13: a
14: a

/a*\d/B
------------------------------------------------------------------
        Bra
        a*+
        \d
        Ket
        End
------------------------------------------------------------------

/a*\D/B
------------------------------------------------------------------
        Bra
        a*
        \D
        Ket
        End
------------------------------------------------------------------

/0*\d/B
------------------------------------------------------------------
        Bra
        0*
        \d
        Ket
        End
------------------------------------------------------------------

/0*\D/B
------------------------------------------------------------------
        Bra
        0*+
        \D
        Ket
        End
------------------------------------------------------------------

/a*\s/B
------------------------------------------------------------------
        Bra
        a*+
        \s
        Ket
        End
------------------------------------------------------------------

/a*\S/B
------------------------------------------------------------------
        Bra
        a*
        \S
        Ket
        End
------------------------------------------------------------------

/ *\s/B
------------------------------------------------------------------
        Bra
         *
        \s
        Ket
        End
------------------------------------------------------------------

/ *\S/B
------------------------------------------------------------------
        Bra
         *+
        \S
        Ket
        End
------------------------------------------------------------------

/a*\w/B
------------------------------------------------------------------
        Bra
        a*
        \w
        Ket
        End
------------------------------------------------------------------

/a*\W/B
------------------------------------------------------------------
        Bra
        a*+
        \W
        Ket
        End
------------------------------------------------------------------

/=*\w/B
------------------------------------------------------------------
        Bra
        =*+
        \w
        Ket
        End
------------------------------------------------------------------

/=*\W/B
------------------------------------------------------------------
        Bra
        =*
        \W
        Ket
        End
------------------------------------------------------------------

/\d*a/B
------------------------------------------------------------------
        Bra
        \d*+
        a
        Ket
        End
------------------------------------------------------------------

/\d*2/B
------------------------------------------------------------------
        Bra
        \d*
        2
        Ket
        End
------------------------------------------------------------------

/\d*\d/B
------------------------------------------------------------------
        Bra
        \d*
        \d
        Ket
        End
------------------------------------------------------------------

/\d*\D/B
------------------------------------------------------------------
        Bra
        \d*+
        \D
        Ket
        End
------------------------------------------------------------------

/\d*\s/B
------------------------------------------------------------------
        Bra
        \d*+
        \s
        Ket
        End
------------------------------------------------------------------

/\d*\S/B
------------------------------------------------------------------
        Bra
        \d*
        \S
        Ket
        End
------------------------------------------------------------------

/\d*\w/B
------------------------------------------------------------------
        Bra
        \d*
        \w
        Ket
        End
------------------------------------------------------------------

/\d*\W/B
------------------------------------------------------------------
        Bra
        \d*+
        \W
        Ket
        End
------------------------------------------------------------------

/\D*a/B
------------------------------------------------------------------
        Bra
        \D*
        a
        Ket
        End
------------------------------------------------------------------

/\D*2/B
------------------------------------------------------------------
        Bra
        \D*+
        2
        Ket
        End
------------------------------------------------------------------

/\D*\d/B
------------------------------------------------------------------
        Bra
        \D*+
        \d
        Ket
        End
------------------------------------------------------------------

/\D*\D/B
------------------------------------------------------------------
        Bra
        \D*
        \D
        Ket
        End
------------------------------------------------------------------

/\D*\s/B
------------------------------------------------------------------
        Bra
        \D*
        \s
        Ket
        End
------------------------------------------------------------------

/\D*\S/B
------------------------------------------------------------------
        Bra
        \D*
        \S
        Ket
        End
------------------------------------------------------------------

/\D*\w/B
------------------------------------------------------------------
        Bra
        \D*
        \w
        Ket
        End
------------------------------------------------------------------

/\D*\W/B
------------------------------------------------------------------
        Bra
        \D*
        \W
        Ket
        End
------------------------------------------------------------------

/\s*a/B
------------------------------------------------------------------
        Bra
        \s*+
        a
        Ket
        End
------------------------------------------------------------------

/\s*2/B
------------------------------------------------------------------
        Bra
        \s*+
        2
        Ket
        End
------------------------------------------------------------------

/\s*\d/B
------------------------------------------------------------------
        Bra
        \s*+
        \d
        Ket
        End
------------------------------------------------------------------

/\s*\D/B
------------------------------------------------------------------
        Bra
        \s*
        \D
        Ket
        End
------------------------------------------------------------------

/\s*\s/B
------------------------------------------------------------------
        Bra
        \s*
        \s
        Ket
        End
------------------------------------------------------------------

/\s*\S/B
------------------------------------------------------------------
        Bra
        \s*+
        \S
        Ket
        End
------------------------------------------------------------------

/\s*\w/B
------------------------------------------------------------------
        Bra
        \s*+
        \w
        Ket
        End
------------------------------------------------------------------

/\s*\W/B
------------------------------------------------------------------
        Bra
        \s*
        \W
        Ket
        End
------------------------------------------------------------------

/\S*a/B
------------------------------------------------------------------
        Bra
        \S*
        a
        Ket
        End
------------------------------------------------------------------

/\S*2/B
------------------------------------------------------------------
        Bra
        \S*
        2
        Ket
        End
------------------------------------------------------------------

/\S*\d/B
------------------------------------------------------------------
        Bra
        \S*
        \d
        Ket
        End
------------------------------------------------------------------

/\S*\D/B
------------------------------------------------------------------
        Bra
        \S*
        \D
        Ket
        End
------------------------------------------------------------------

/\S*\s/B
------------------------------------------------------------------
        Bra
        \S*+
        \s
        Ket
        End
------------------------------------------------------------------

/\S*\S/B
------------------------------------------------------------------
        Bra
        \S*
        \S
        Ket
        End
------------------------------------------------------------------

/\S*\w/B
------------------------------------------------------------------
        Bra
        \S*
        \w
        Ket
        End
------------------------------------------------------------------

/\S*\W/B
------------------------------------------------------------------
        Bra
        \S*
        \W
        Ket
        End
------------------------------------------------------------------

/\w*a/B
------------------------------------------------------------------
        Bra
        \w*
        a
        Ket
        End
------------------------------------------------------------------

/\w*2/B
------------------------------------------------------------------
        Bra
        \w*
        2
        Ket
        End
------------------------------------------------------------------

/\w*\d/B
------------------------------------------------------------------
        Bra
        \w*
        \d
        Ket
        End
------------------------------------------------------------------

/\w*\D/B
------------------------------------------------------------------
        Bra
        \w*
        \D
        Ket
        End
------------------------------------------------------------------

/\w*\s/B
------------------------------------------------------------------
        Bra
        \w*+
        \s
        Ket
        End
------------------------------------------------------------------

/\w*\S/B
------------------------------------------------------------------
        Bra
        \w*
        \S
        Ket
        End
------------------------------------------------------------------

/\w*\w/B
------------------------------------------------------------------
        Bra
        \w*
        \w
        Ket
        End
------------------------------------------------------------------

/\w*\W/B
------------------------------------------------------------------
        Bra
        \w*+
        \W
        Ket
        End
------------------------------------------------------------------

/\W*a/B
------------------------------------------------------------------
        Bra
        \W*+
        a
        Ket
        End
------------------------------------------------------------------

/\W*2/B
------------------------------------------------------------------
        Bra
        \W*+
        2
        Ket
        End
------------------------------------------------------------------

/\W*\d/B
------------------------------------------------------------------
        Bra
        \W*+
        \d
        Ket
        End
------------------------------------------------------------------

/\W*\D/B
------------------------------------------------------------------
        Bra
        \W*
        \D
        Ket
        End
------------------------------------------------------------------

/\W*\s/B
------------------------------------------------------------------
        Bra
        \W*
        \s
        Ket
        End
------------------------------------------------------------------

/\W*\S/B
------------------------------------------------------------------
        Bra
        \W*
        \S
        Ket
        End
------------------------------------------------------------------

/\W*\w/B
------------------------------------------------------------------
        Bra
        \W*+
        \w
        Ket
        End
------------------------------------------------------------------

/\W*\W/B
------------------------------------------------------------------
        Bra
        \W*
        \W
        Ket
        End
------------------------------------------------------------------

/[^a]+a/B
------------------------------------------------------------------
        Bra
        [^a]++
        a
        Ket
        End
------------------------------------------------------------------

/[^a]+a/Bi
------------------------------------------------------------------
        Bra
     /i [^a]++
     /i a
        Ket
        End
------------------------------------------------------------------

/[^a]+A/Bi
------------------------------------------------------------------
        Bra
     /i [^a]++
     /i A
        Ket
        End
------------------------------------------------------------------

/[^a]+b/B
------------------------------------------------------------------
        Bra
        [^a]+
        b
        Ket
        End
------------------------------------------------------------------

/[^a]+\d/B
------------------------------------------------------------------
        Bra
        [^a]+
        \d
        Ket
        End
------------------------------------------------------------------

/a*[^a]/B
------------------------------------------------------------------
        Bra
        a*+
        [^a]
        Ket
        End
------------------------------------------------------------------

/(?P<abc>x)(?P<xyz>y)/I
Capture group count = 2
Named capture groups:
  abc   1
  xyz   2
First code unit = 'x'
Last code unit = 'y'
Subject length lower bound = 2
    xy\=copy=abc,copy=xyz
 0: xy
 1: x
 2: y
  C x (1) abc (group 1)
  C y (1) xyz (group 2)

/(?<abc>x)(?'xyz'y)/I
Capture group count = 2
Named capture groups:
  abc   1
  xyz   2
First code unit = 'x'
Last code unit = 'y'
Subject length lower bound = 2
    xy\=copy=abc,copy=xyz
 0: xy
 1: x
 2: y
  C x (1) abc (group 1)
  C y (1) xyz (group 2)

/(?<abc'x)(?'xyz'y)/I
Failed: error 142 at offset 6: syntax error in subpattern name (missing terminator?)

/(?<abc>x)(?'xyz>y)/I
Failed: error 142 at offset 15: syntax error in subpattern name (missing terminator?)

/(?P'abc'x)(?P<xyz>y)/I
Failed: error 141 at offset 3: unrecognized character after (?P

/^(?:(?(ZZ)a|b)(?<ZZ>X))+/
    bXaX
 0: bXaX
 1: X
    bXbX
 0: bX
 1: X
\= Expect no match
    aXaX
No match
    aXbX
No match

/^(?P>abc)(?<abcd>xxx)/
Failed: error 115 at offset 5: reference to non-existent subpattern

/^(?P>abc)(?<abc>x|y)/
    xx
 0: xx
 1: x
    xy
 0: xy
 1: y
    yy
 0: yy
 1: y
    yx
 0: yx
 1: x

/^(?P>abc)(?P<abc>x|y)/
    xx
 0: xx
 1: x
    xy
 0: xy
 1: y
    yy
 0: yy
 1: y
    yx
 0: yx
 1: x

/^((?(abc)a|b)(?<abc>x|y))+/
    bxay
 0: bxay
 1: ay
 2: y
    bxby
 0: bx
 1: bx
 2: x
\= Expect no match
    axby
No match

/^(((?P=abc)|X)(?<abc>x|y))+/
    XxXxxx
 0: XxXxxx
 1: xx
 2: x
 3: x
    XxXyyx
 0: XxXyyx
 1: yx
 2: y
 3: x
    XxXyxx
 0: XxXy
 1: Xy
 2: X
 3: y
\= Expect no match
    x
No match

/^(?1)(abc)/
    abcabc
 0: abcabc
 1: abc

/^(?:(?:\1|X)(a|b))+/
    Xaaa
 0: Xaaa
 1: a
    Xaba
 0: Xa
 1: a

/^[\E\Qa\E-\Qz\E]+/B
------------------------------------------------------------------
        Bra
        ^
        [a-z]++
        Ket
        End
------------------------------------------------------------------

/^[a\Q]bc\E]/B
------------------------------------------------------------------
        Bra
        ^
        [\]a-c]
        Ket
        End
------------------------------------------------------------------

/^[a-\Q\E]/B
------------------------------------------------------------------
        Bra
        ^
        [\-a]
        Ket
        End
------------------------------------------------------------------

/^(?P>abc)[()](?<abc>)/B
------------------------------------------------------------------
        Bra
        ^
        Recurse
        [()]
        CBra 1
        Ket
        Ket
        End
------------------------------------------------------------------

/^((?(abc)y)[()](?P<abc>x))+/B
------------------------------------------------------------------
        Bra
        ^
        CBra 1
        Cond
      2 Cond ref
        y
        Ket
        [()]
        CBra 2
        x
        Ket
        KetRmax
        Ket
        End
------------------------------------------------------------------
    (xy)x
 0: (xy)x
 1: y)x
 2: x

/^(?P>abc)\Q()\E(?<abc>)/B
------------------------------------------------------------------
        Bra
        ^
        Recurse
        ()
        CBra 1
        Ket
        Ket
        End
------------------------------------------------------------------

/^(?P>abc)[a\Q(]\E(](?<abc>)/B
------------------------------------------------------------------
        Bra
        ^
        Recurse
        [(\]a]
        CBra 1
        Ket
        Ket
        End
------------------------------------------------------------------

/^(?P>abc) # this is (a comment)
  (?<abc>)/Bx
------------------------------------------------------------------
        Bra
        ^
        Recurse
        CBra 1
        Ket
        Ket
        End
------------------------------------------------------------------

/^\W*(?:(?<one>(?<two>.)\W*(?&one)\W*\k<two>|)|(?<three>(?<four>.)\W*(?&three)\W*\k'four'|\W*.\W*))\W*$/Ii
Capture group count = 4
Max back reference = 4
Named capture groups:
  four    4
  one     1
  three   3
  two     2
May match empty string
Compile options: caseless
Overall options: anchored caseless
Subject length lower bound = 0
    1221
 0: 1221
 1: 1221
 2: 1
    Satan, oscillate my metallic sonatas!
 0: Satan, oscillate my metallic sonatas!
 1: <unset>
 2: <unset>
 3: Satan, oscillate my metallic sonatas
 4: S
    A man, a plan, a canal: Panama!
 0: A man, a plan, a canal: Panama!
 1: <unset>
 2: <unset>
 3: A man, a plan, a canal: Panama
 4: A
    Able was I ere I saw Elba.
 0: Able was I ere I saw Elba.
 1: <unset>
 2: <unset>
 3: Able was I ere I saw Elba
 4: A
\= Expect no match
    The quick brown fox
No match

/(?=(\w+))\1:/I
Capture group count = 1
Max back reference = 1
Starting code units: 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P 
  Q R S T U V W X Y Z _ a b c d e f g h i j k l m n o p q r s t u v w x y z 
Last code unit = ':'
Subject length lower bound = 2
    abcd:
 0: abcd:
 1: abcd

/(?=(?'abc'\w+))\k<abc>:/I
Capture group count = 1
Max back reference = 1
Named capture groups:
  abc   1
Starting code units: 0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P 
  Q R S T U V W X Y Z _ a b c d e f g h i j k l m n o p q r s t u v w x y z 
Last code unit = ':'
Subject length lower bound = 2
    abcd:
 0: abcd:
 1: abcd

/(?'abc'a|b)(?<abc>d|e)\k<abc>{2}/dupnames
    adaa
 0: adaa
 1: a
 2: d
\= Expect no match
    addd
No match
    adbb
No match

/(?'abc'a|b)(?<abc>d|e)(?&abc){2}/dupnames
    bdaa
 0: bdaa
 1: b
 2: d
    bdab
 0: bdab
 1: b
 2: d
\= Expect no match
    bddd
No match

/(?(<bc))/
Failed: error 142 at offset 6: syntax error in subpattern name (missing terminator?)

/(?(''))/
Failed: error 162 at offset 4: subpattern name expected

/(?('R')stuff)/
Failed: error 115 at offset 4: reference to non-existent subpattern

/((abc (?(R) (?(R1)1) (?(R2)2) X  |  (?1)  (?2)   (?R) ))) /x
    abcabc1Xabc2XabcXabcabc
 0: abcabc1Xabc2XabcX
 1: abcabc1Xabc2XabcX
 2: abcabc1Xabc2XabcX

/(?<A> (?'B' abc (?(R) (?(R&A)1) (?(R&B)2) X  |  (?1)  (?2)   (?R) ))) /x
    abcabc1Xabc2XabcXabcabc
 0: abcabc1Xabc2XabcX
 1: abcabc1Xabc2XabcX
 2: abcabc1Xabc2XabcX

/(?<A> (?'B' abc (?(R) (?(R&C)1) (?(R&B)2) X  |  (?1)  (?2)   (?R) ))) /x
Failed: error 115 at offset 27: reference to non-existent subpattern

/^(?(DEFINE) abc | xyz ) /x
Failed: error 154 at offset 4: DEFINE subpattern contains more than one branch

/(?(DEFINE) abc) xyz/Ix
Capture group count = 0
Options: extended
First code unit = 'x'
Last code unit = 'z'
Subject length lower bound = 3

/(a|)*\d/
  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4\=ovector=0
 0: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa4
 1: 
\= Expect no match
  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\=ovector=0
No match

/^a.b/newline=lf
    a\rb
 0: a\x0db
\= Expect no match
    a\nb
No match

/^a.b/newline=cr
    a\nb
 0: a\x0ab
\= Expect no match
    a\rb
No match

/^a.b/newline=anycrlf
    a\x85b
 0: a\x85b
\= Expect no match
    a\rb
No match

/^a.b/newline=any
\= Expect no match
    a\nb
No match
    a\rb
No match
    a\x85b
No match

/^abc./gmx,newline=any
    abc1 \x0aabc2 \x0babc3xx \x0cabc4 \x0dabc5xx \x0d\x0aabc6 \x85abc7 JUNK
 0: abc1
 0: abc2
 0: abc3
 0: abc4
 0: abc5
 0: abc6
 0: abc7

/abc.$/gmx,newline=any
    abc1\x0a abc2\x0b abc3\x0c abc4\x0d abc5\x0d\x0a abc6\x85 abc7 abc9
 0: abc1
 0: abc2
 0: abc3
 0: abc4
 0: abc5
 0: abc6
 0: abc9

/^a\Rb/bsr=unicode
    a\nb
 0: a\x0ab
    a\rb
 0: a\x0db
    a\r\nb
 0: a\x0d\x0ab
    a\x0bb
 0: a\x0bb
    a\x0cb
 0: a\x0cb
    a\x85b
 0: a\x85b
\= Expect no match
    a\n\rb
No match

/^a\R*b/bsr=unicode
    ab
 0: ab
    a\nb
 0: a\x0ab
    a\rb
 0: a\x0db
    a\r\nb
 0: a\x0d\x0ab
    a\x0bb
 0: a\x0bb
    a\x0cb
 0: a\x0cb
    a\x85b
 0: a\x85b
    a\n\rb
 0: a\x0a\x0db
    a\n\r\x85\x0cb
 0: a\x0a\x0d\x85\x0cb

/^a\R+b/bsr=unicode
    a\nb
 0: a\x0ab
    a\rb
 0: a\x0db
    a\r\nb
 0: a\x0d\x0ab
    a\x0bb
 0: a\x0bb
    a\x0cb
 0: a\x0cb
    a\x85b
 0: a\x85b
    a\n\rb
 0: a\x0a\x0db
    a\n\r\x85\x0cb
 0: a\x0a\x0d\x85\x0cb
\= Expect no match
    ab
No match

/^a\R{1,3}b/bsr=unicode
    a\nb
 0: a\x0ab
    a\n\rb
 0: a\x0a\x0db
    a\n\r\x85b
 0: a\x0a\x0d\x85b
    a\r\n\r\nb
 0: a\x0d\x0a\x0d\x0ab
    a\r\n\r\n\r\nb
 0: a\x0d\x0a\x0d\x0a\x0d\x0ab
    a\n\r\n\rb
 0: a\x0a\x0d\x0a\x0db
    a\n\n\r\nb
 0: a\x0a\x0a\x0d\x0ab
\= Expect no match
    a\n\n\n\rb
No match
    a\r
No match

/(?&abc)X(?<abc>P)/I
Capture group count = 1
Named capture groups:
  abc   1
Last code unit = 'P'
Subject length lower bound = 3
    abcPXP123
 0: PXP
 1: P

/(?1)X(?<abc>P)/I
Capture group count = 1
Named capture groups:
  abc   1
Last code unit = 'P'
Subject length lower bound = 3
    abcPXP123
 0: PXP
 1: P

/(?:a(?&abc)b)*(?<abc>x)/
    123axbaxbaxbx456
 0: axbaxbaxbx
 1: x
    123axbaxbaxb456
 0: x
 1: x

/(?:a(?&abc)b){1,5}(?<abc>x)/
    123axbaxbaxbx456
 0: axbaxbaxbx
 1: x

/(?:a(?&abc)b){2,5}(?<abc>x)/
    123axbaxbaxbx456
 0: axbaxbaxbx
 1: x

/(?:a(?&abc)b){2,}(?<abc>x)/
    123axbaxbaxbx456
 0: axbaxbaxbx
 1: x

/(abc)(?i:(?1))/
    defabcabcxyz
 0: abcabc
 1: abc
\= Expect no match
    DEFabcABCXYZ
No match

/(abc)(?:(?i)(?1))/
    defabcabcxyz
 0: abcabc
 1: abc
\= Expect no match
    DEFabcABCXYZ
No match

/^(a)\g-2/
Failed: error 115 at offset 8: reference to non-existent subpattern

/^(a)\g/
Failed: error 157 at offset 6: \g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number

/^(a)\g{0}/
Failed: error 115 at offset 9: reference to non-existent subpattern

/^(a)\g{3/
Failed: error 157 at offset 6: \g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number

/^(a)\g{aa}/
Failed: error 115 at offset 7: reference to non-existent subpattern

/^a.b/newline=lf
    a\rb
 0: a\x0db
\= Expect no match
    a\nb
No match

/.+foo/
    afoo
 0: afoo
\= Expect no match
    \r\nfoo
No match
    \nfoo
No match

/.+foo/newline=crlf
    afoo
 0: afoo
    \nfoo
 0: \x0afoo
\= Expect no match
    \r\nfoo
No match

/.+foo/newline=any
    afoo
 0: afoo
\= Expect no match
    \nfoo
No match
    \r\nfoo
No match

/.+foo/s
    afoo
 0: afoo
    \r\nfoo
 0: \x0d\x0afoo
    \nfoo
 0: \x0afoo

/^$/gm,newline=any
    abc\r\rxyz
 0: 
    abc\n\rxyz
 0: 
\= Expect no match
    abc\r\nxyz
No match

/(?m)^$/g,newline=any,aftertext
    abc\r\n\r\n
 0: 
 0+ \x0d\x0a

/(?m)^$|^\r\n/g,newline=any,aftertext
    abc\r\n\r\n
 0: 
 0+ \x0d\x0a
 0: \x0d\x0a
 0+ 

/(?m)$/g,newline=any,aftertext
    abc\r\n\r\n
 0: 
 0+ \x0d\x0a\x0d\x0a
 0: 
 0+ \x0d\x0a
 0: 
 0+ 

/abc.$/gmx,newline=anycrlf
    abc1\x0a abc2\x0b abc3\x0c abc4\x0d abc5\x0d\x0a abc6\x85 abc9
 0: abc1
 0: abc4
 0: abc5
 0: abc9

/^X/m
    XABC
 0: X
\= Expect no match
    XABC\=notbol
No match

/(ab|c)(?-1)/B
------------------------------------------------------------------
        Bra
        CBra 1
        ab
        Alt
        c
        Ket
        Recurse
        Ket
        End
------------------------------------------------------------------
    abc
 0: abc
 1: ab

/xy(?+1)(abc)/B
------------------------------------------------------------------
        Bra
        xy
        Recurse
        CBra 1
        abc
        Ket
        Ket
        End
------------------------------------------------------------------
    xyabcabc
 0: xyabcabc
 1: abc
\= Expect no match
    xyabc
No match

/x(?-0)y/
Failed: error 126 at offset 5: a relative value of zero is not allowed

/x(?-1)y/
Failed: error 115 at offset 5: reference to non-existent subpattern

/x(?+0)y/
Failed: error 126 at offset 5: a relative value of zero is not allowed

/x(?+1)y/
Failed: error 115 at offset 5: reference to non-existent subpattern

/^(abc)?(?(-1)X|Y)/B
------------------------------------------------------------------
        Bra
        ^
        Brazero
        CBra 1
        abc
        Ket
        Cond
      1 Cond ref
        X
        Alt
        Y
        Ket
        Ket
        End
------------------------------------------------------------------
    abcX
 0: abcX
 1: abc
    Y
 0: Y
\= Expect no match
    abcY
No match

/^((?(+1)X|Y)(abc))+/B
------------------------------------------------------------------
        Bra
        ^
        CBra 1
        Cond
      2 Cond ref
        X
        Alt
        Y
        Ket
        CBra 2
        abc
        Ket
        KetRmax
        Ket
        End
------------------------------------------------------------------
    YabcXabc
 0: YabcXabc
 1: Xabc
 2: abc
    YabcXabcXabc
 0: YabcXabcXabc
 1: Xabc
 2: abc
\= Expect no match
    XabcXabc
No match

/(?(-1)a)/B
Failed: error 115 at offset 5: reference to non-existent subpattern

/((?(-1)a))/B
------------------------------------------------------------------
        Bra
        CBra 1
        Cond
      1 Cond ref
        a
        Ket
        Ket
        Ket
        End
------------------------------------------------------------------

/((?(-2)a))/B
Failed: error 115 at offset 6: reference to non-existent subpattern

/^(?(+1)X|Y)(.)/B
------------------------------------------------------------------
        Bra
        ^
        Cond
      1 Cond ref
        X
        Alt
        Y
        Ket
        CBra 1
        Any
        Ket
        Ket
        End
------------------------------------------------------------------
    Y!
 0: Y!
 1: !

/(?<A>tom|bon)-\k{A}/
    tom-tom
 0: tom-tom
 1: tom
    bon-bon
 0: bon-bon
 1: bon
\= Expect no match
    tom-bon
No match

/\g{A/
Failed: error 142 at offset 4: syntax error in subpattern name (missing terminator?)

/(?|(abc)|(xyz))/B
------------------------------------------------------------------
        Bra
        Bra
        CBra 1
        abc
        Ket
        Alt
        CBra 1
        xyz
        Ket
        Ket
        Ket
        End
------------------------------------------------------------------
   >abc<
 0: abc
 1: abc
   >xyz<
 0: xyz
 1: xyz

/(x)(?|(abc)|(xyz))(x)/B
------------------------------------------------------------------
        Bra
        CBra 1
        x
        Ket
        Bra
        CBra 2
        abc
        Ket
        Alt
        CBra 2
        xyz
        Ket
        Ket
        CBra 3
        x
        Ket
        Ket
        End
------------------------------------------------------------------
    xabcx
 0: xabcx
 1: x
 2: abc
 3: x
    xxyzx
 0: xxyzx
 1: x
 2: xyz
 3: x

/(x)(?|(abc)(pqr)|(xyz))(x)/B
------------------------------------------------------------------
        Bra
        CBra 1
        x
        Ket
        Bra
        CBra 2
        abc
        Ket
        CBra 3
        pqr
        Ket
        Alt
        CBra 2
        xyz
        Ket
        Ket
        CBra 4
        x
        Ket
        Ket
        End
------------------------------------------------------------------
    xabcpqrx
 0: xabcpqrx
 1: x
 2: abc
 3: pqr
 4: x
    xxyzx
 0: xxyzx
 1: x
 2: xyz
 3: <unset>
 4: x

/\H++X/B
------------------------------------------------------------------
        Bra
        \H++
        X
        Ket
        End
------------------------------------------------------------------
\= Expect no match
    XXXX
No match

/\H+\hY/B
------------------------------------------------------------------
        Bra
        \H++
        \h
        Y
        Ket
        End
------------------------------------------------------------------
    XXXX Y
 0: XXXX Y

/\H+ Y/B
------------------------------------------------------------------
        Bra
        \H++
         Y
        Ket
        End
------------------------------------------------------------------

/\h+A/B
------------------------------------------------------------------
        Bra
        \h++
        A
        Ket
        End
------------------------------------------------------------------

/\v*B/B
------------------------------------------------------------------
        Bra
        \v*+
        B
        Ket
        End
------------------------------------------------------------------

/\V+\x0a/B
------------------------------------------------------------------
        Bra
        \V++
        \x0a
        Ket
        End
------------------------------------------------------------------

/A+\h/B
------------------------------------------------------------------
        Bra
        A++
        \h
        Ket
        End
------------------------------------------------------------------

/ *\H/B
------------------------------------------------------------------
        Bra
         *+
        \H
        Ket
        End
------------------------------------------------------------------

/A*\v/B
------------------------------------------------------------------
        Bra
        A*+
        \v
        Ket
        End
------------------------------------------------------------------

/\x0b*\V/B
------------------------------------------------------------------
        Bra
        \x0b*+
        \V
        Ket
        End
------------------------------------------------------------------

/\d+\h/B
------------------------------------------------------------------
        Bra
        \d++
        \h
        Ket
        End
------------------------------------------------------------------

/\d*\v/B
------------------------------------------------------------------
        Bra
        \d*+
        \v
        Ket
        End
------------------------------------------------------------------

/S+\h\S+\v/B
------------------------------------------------------------------
        Bra
        S++
        \h
        \S++
        \v
        Ket
        End
------------------------------------------------------------------

/\w{3,}\h\w+\v/B
------------------------------------------------------------------
        Bra
        \w{3}
        \w*+
        \h
        \w++
        \v
        Ket
        End
------------------------------------------------------------------

/\h+\d\h+\w\h+\S\h+\H/B
------------------------------------------------------------------
        Bra
        \h++
        \d
        \h++
        \w
        \h++
        \S
        \h++
        \H
        Ket
        End
------------------------------------------------------------------

/\v+\d\v+\w\v+\S\v+\V/B
------------------------------------------------------------------
        Bra
        \v++
        \d
        \v++
        \w
        \v++
        \S
        \v++
        \V
        Ket
        End
------------------------------------------------------------------

/\H+\h\H+\d/B
------------------------------------------------------------------
        Bra
        \H++
        \h
        \H+
        \d
        Ket
        End
------------------------------------------------------------------

/\V+\v\V+\w/B
------------------------------------------------------------------
        Bra
        \V++
        \v
        \V+
        \w
        Ket
        End
------------------------------------------------------------------

/\( (?: [^()]* | (?R) )* \)/x
(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(00)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)\=jitstack=1024
 0: (0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(0(00)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)0)

/[\E]AAA/
Failed: error 106 at offset 7: missing terminating ] for character class

/[\Q\E]AAA/
Failed: error 106 at offset 9: missing terminating ] for character class

/[^\E]AAA/
Failed: error 106 at offset 8: missing terminating ] for character class

/[^\Q\E]AAA/
Failed: error 106 at offset 10: missing terminating ] for character class

/[\E^]AAA/
Failed: error 106 at offset 8: missing terminating ] for character class

/[\Q\E^]AAA/
Failed: error 106 at offset 10: missing terminating ] for character class

/A(*PRUNE)B(*SKIP)C(*THEN)D(*COMMIT)E(*F)F(*FAIL)G(?!)H(*ACCEPT)I/B
------------------------------------------------------------------
        Bra
        A
        *PRUNE
        B
        *SKIP
        C
        *THEN
        D
        *COMMIT
        E
        *FAIL
        F
        *FAIL
        G
        *FAIL
        H
        *ACCEPT
        I
        Ket
        End
------------------------------------------------------------------

/^a+(*FAIL)/auto_callout
\= Expect no match
    aaaaaa
--->aaaaaa
 +0 ^          ^
 +1 ^          a+
 +3 ^     ^    (*FAIL)
 +3 ^    ^     (*FAIL)
 +3 ^   ^      (*FAIL)
 +3 ^  ^       (*FAIL)
 +3 ^ ^        (*FAIL)
 +3 ^^         (*FAIL)
No match

/a+b?c+(*FAIL)/auto_callout
\= Expect no match
    aaabccc
--->aaabccc
 +0 ^           a+
 +2 ^  ^        b?
 +4 ^   ^       c+
 +6 ^      ^    (*FAIL)
 +6 ^     ^     (*FAIL)
 +6 ^    ^      (*FAIL)
 +0  ^          a+
 +2  ^ ^        b?
 +4  ^  ^       c+
 +6  ^     ^    (*FAIL)
 +6  ^    ^     (*FAIL)
 +6  ^   ^      (*FAIL)
 +0   ^         a+
 +2   ^^        b?
 +4   ^ ^       c+
 +6   ^    ^    (*FAIL)
 +6   ^   ^     (*FAIL)
 +6   ^  ^      (*FAIL)
No match

/a+b?(*PRUNE)c+(*FAIL)/auto_callout
\= Expect no match
    aaabccc
--->aaabccc
 +0 ^           a+
 +2 ^  ^        b?
 +4 ^   ^       (*PRUNE)
+12 ^   ^       c+
+14 ^      ^    (*FAIL)
+14 ^     ^     (*FAIL)
+14 ^    ^      (*FAIL)
 +0  ^          a+
 +2  ^ ^        b?
 +4  ^  ^       (*PRUNE)
+12  ^  ^       c+
+14  ^     ^    (*FAIL)
+14  ^    ^     (*FAIL)
+14  ^   ^      (*FAIL)
 +0   ^         a+
 +2   ^^        b?
 +4   ^ ^       (*PRUNE)
+12   ^ ^       c+
+14   ^    ^    (*FAIL)
+14   ^   ^     (*FAIL)
+14   ^  ^      (*FAIL)
No match

/a+b?(*COMMIT)c+(*FAIL)/auto_callout
\= Expect no match
    aaabccc
--->aaabccc
 +0 ^           a+
 +2 ^  ^        b?
 +4 ^   ^       (*COMMIT)
+13 ^   ^       c+
+15 ^      ^    (*FAIL)
+15 ^     ^     (*FAIL)
+15 ^    ^      (*FAIL)
No match

/a+b?(*SKIP)c+(*FAIL)/auto_callout
\= Expect no match
    aaabcccaaabccc
--->aaabcccaaabccc
 +0 ^                  a+
 +2 ^  ^               b?
 +4 ^   ^              (*SKIP)
+11 ^   ^              c+
+13 ^      ^           (*FAIL)
+13 ^     ^            (*FAIL)
+13 ^    ^             (*FAIL)
 +0        ^           a+
 +2        ^  ^        b?
 +4        ^   ^       (*SKIP)
+11        ^   ^       c+
+13        ^      ^    (*FAIL)
+13        ^     ^     (*FAIL)
+13        ^    ^      (*FAIL)
No match

/a+b?(*THEN)c+(*FAIL)/auto_callout
\= Expect no match
    aaabccc
--->aaabccc
 +0 ^           a+
 +2 ^  ^        b?
 +4 ^   ^       (*THEN)
+11 ^   ^       c+
+13 ^      ^    (*FAIL)
+13 ^     ^     (*FAIL)
+13 ^    ^      (*FAIL)
 +0  ^          a+
 +2  ^ ^        b?
 +4  ^  ^       (*THEN)
+11  ^  ^       c+
+13  ^     ^    (*FAIL)
+13  ^    ^     (*FAIL)
+13  ^   ^      (*FAIL)
 +0   ^         a+
 +2   ^^        b?
 +4   ^ ^       (*THEN)
+11   ^ ^       c+
+13   ^    ^    (*FAIL)
+13   ^   ^     (*FAIL)
+13   ^  ^      (*FAIL)
No match

/a(*MARK)b/
Failed: error 166 at offset 7: (*MARK) must have an argument

/\g6666666666/
Failed: error 161 at offset 7: subpattern number is too big

/[\g6666666666]/B
------------------------------------------------------------------
        Bra
        [6g]
        Ket
        End
------------------------------------------------------------------

/(?1)\c[/
Failed: error 115 at offset 3: reference to non-existent subpattern

/.+A/newline=crlf
\= Expect no match
    \r\nA
No match

/\nA/newline=crlf
    \r\nA
 0: \x0aA

/[\r\n]A/newline=crlf
    \r\nA
 0: \x0aA

/(\r|\n)A/newline=crlf
    \r\nA
 0: \x0aA
 1: \x0a

/a(*CR)b/
Failed: error 160 at offset 5: (*VERB) not recognized or malformed

/(*CR)a.b/
    a\nb
 0: a\x0ab
\= Expect no match
    a\rb
No match

/(*CR)a.b/newline=lf
    a\nb
 0: a\x0ab
\= Expect no match
    a\rb
No match

/(*LF)a.b/newline=CRLF
    a\rb
 0: a\x0db
\= Expect no match
    a\nb
No match

/(*CRLF)a.b/
    a\rb
 0: a\x0db
    a\nb
 0: a\x0ab
\= Expect no match
    a\r\nb
No match

/(*ANYCRLF)a.b/newline=CR
\= Expect no match
    a\rb
No match
    a\nb
No match
    a\r\nb
No match

/(*ANY)a.b/newline=cr
\= Expect no match
    a\rb
No match
    a\nb
No match
    a\r\nb
No match
    a\x85b
No match

/(*ANY).*/g
    abc\r\ndef
 0: abc
 0: 
 0: def
 0: 

/(*ANYCRLF).*/g
    abc\r\ndef
 0: abc
 0: 
 0: def
 0: 

/(*CRLF).*/g
    abc\r\ndef
 0: abc
 0: 
 0: def
 0: 

/(*NUL)^.*/
    a\nb\x00ccc
 0: a\x0ab

/(*NUL)^.*/s
    a\nb\x00ccc
 0: a\x0ab\x00ccc

/^x/m,newline=NUL
    ab\x00xy
 0: x

/'#comment' 0d 0a 00 '^x\' 0a 'y'/x,newline=nul,hex
    x\nyz
 0: x\x0ay

/(*NUL)^X\NY/
    X\nY
 0: X\x0aY
    X\rY
 0: X\x0dY
\= Expect no match
    X\x00Y
No match

/a\Rb/I,bsr=anycrlf
Capture group count = 0
\R matches CR, LF, or CRLF
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 3
    a\rb
 0: a\x0db
    a\nb
 0: a\x0ab
    a\r\nb
 0: a\x0d\x0ab
\= Expect no match
    a\x85b
No match
    a\x0bb
No match

/a\Rb/I,bsr=unicode
Capture group count = 0
\R matches any Unicode newline
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 3
    a\rb
 0: a\x0db
    a\nb
 0: a\x0ab
    a\r\nb
 0: a\x0d\x0ab
    a\x85b
 0: a\x85b
    a\x0bb
 0: a\x0bb

/a\R?b/I,bsr=anycrlf
Capture group count = 0
\R matches CR, LF, or CRLF
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 2
    a\rb
 0: a\x0db
    a\nb
 0: a\x0ab
    a\r\nb
 0: a\x0d\x0ab
\= Expect no match
    a\x85b
No match
    a\x0bb
No match

/a\R?b/I,bsr=unicode
Capture group count = 0
\R matches any Unicode newline
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 2
    a\rb
 0: a\x0db
    a\nb
 0: a\x0ab
    a\r\nb
 0: a\x0d\x0ab
    a\x85b
 0: a\x85b
    a\x0bb
 0: a\x0bb

/a\R{2,4}b/I,bsr=anycrlf
Capture group count = 0
\R matches CR, LF, or CRLF
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 4
    a\r\n\nb
 0: a\x0d\x0a\x0ab
    a\n\r\rb
 0: a\x0a\x0d\x0db
    a\r\n\r\n\r\n\r\nb
 0: a\x0d\x0a\x0d\x0a\x0d\x0a\x0d\x0ab
\= Expect no match
    a\x85\x85b
No match
    a\x0b\x0bb
No match

/a\R{2,4}b/I,bsr=unicode
Capture group count = 0
\R matches any Unicode newline
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 4
    a\r\rb
 0: a\x0d\x0db
    a\n\n\nb
 0: a\x0a\x0a\x0ab
    a\r\n\n\r\rb
 0: a\x0d\x0a\x0a\x0d\x0db
    a\x85\x85b
 0: a\x85\x85b
    a\x0b\x0bb
 0: a\x0b\x0bb
\= Expect no match
    a\r\r\r\r\rb
No match

/(*BSR_ANYCRLF)a\Rb/I
Capture group count = 0
\R matches CR, LF, or CRLF
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 3
    a\nb
 0: a\x0ab
    a\rb
 0: a\x0db

/(*BSR_UNICODE)a\Rb/I
Capture group count = 0
\R matches any Unicode newline
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 3
    a\x85b
 0: a\x85b

/(*BSR_ANYCRLF)(*CRLF)a\Rb/I
Capture group count = 0
\R matches CR, LF, or CRLF
Forced newline is CRLF
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 3
    a\nb
 0: a\x0ab
    a\rb
 0: a\x0db

/(*CRLF)(*BSR_UNICODE)a\Rb/I
Capture group count = 0
\R matches any Unicode newline
Forced newline is CRLF
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 3
    a\x85b
 0: a\x85b

/(*CRLF)(*BSR_ANYCRLF)(*CR)ab/I
Capture group count = 0
\R matches CR, LF, or CRLF
Forced newline is CR
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 2

/(?<a>)(?&)/
Failed: error 162 at offset 9: subpattern name expected

/(?<abc>)(?&a)/
Failed: error 115 at offset 11: reference to non-existent subpattern

/(?<a>)(?&aaaaaaaaaaaaaaaaaaaaaaa)/
Failed: error 115 at offset 9: reference to non-existent subpattern

/(?+-a)/
Failed: error 129 at offset 2: digit expected after (?+ or (?-

/(?-+a)/
Failed: error 111 at offset 3: unrecognized character after (? or (?-

/(?(-1))/
Failed: error 115 at offset 5: reference to non-existent subpattern

/(?(+10))/
Failed: error 115 at offset 4: reference to non-existent subpattern

/(?(10))/
Failed: error 115 at offset 3: reference to non-existent subpattern

/(?(+2))()()/

/(?(2))()()/

/\k''/
Failed: error 162 at offset 3: subpattern name expected

/\k<>/
Failed: error 162 at offset 3: subpattern name expected

/\k{}/
Failed: error 162 at offset 3: subpattern name expected

/\k/
Failed: error 169 at offset 2: \k is not followed by a braced, angle-bracketed, or quoted name

/\kabc/
Failed: error 169 at offset 2: \k is not followed by a braced, angle-bracketed, or quoted name

/(?P=)/
Failed: error 162 at offset 4: subpattern name expected

/(?P>)/
Failed: error 162 at offset 4: subpattern name expected

/[[:foo:]]/
Failed: error 130 at offset 3: unknown POSIX class name

/[[:1234:]]/
Failed: error 130 at offset 3: unknown POSIX class name

/[[:f\oo:]]/
Failed: error 130 at offset 3: unknown POSIX class name

/[[: :]]/
Failed: error 130 at offset 3: unknown POSIX class name

/[[:...:]]/
Failed: error 130 at offset 3: unknown POSIX class name

/[[:l\ower:]]/
Failed: error 130 at offset 3: unknown POSIX class name

/[[:abc\:]]/
Failed: error 130 at offset 3: unknown POSIX class name

/[abc[:x\]pqr:]]/
Failed: error 130 at offset 6: unknown POSIX class name

/[[:a\dz:]]/
Failed: error 130 at offset 3: unknown POSIX class name

/(^(a|b\g<-1'c))/
Failed: error 157 at offset 8: \g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number

/^(?+1)(?<a>x|y){0}z/
    xzxx
 0: xz
    yzyy
 0: yz
\= Expect no match
    xxz
No match

/(\3)(\1)(a)/
\= Expect no match
    cat
No match

/(\3)(\1)(a)/allow_empty_class,match_unset_backref,dupnames
    cat
 0: a
 1: 
 2: 
 3: a

/TA]/
    The ACTA] comes
 0: TA]

/TA]/allow_empty_class,match_unset_backref,dupnames
    The ACTA] comes
 0: TA]

/(?2)[]a()b](abc)/
Failed: error 115 at offset 3: reference to non-existent subpattern
    abcbabc

/(?2)[^]a()b](abc)/
Failed: error 115 at offset 3: reference to non-existent subpattern
    abcbabc

/(?1)[]a()b](abc)/
    abcbabc
 0: abcbabc
 1: abc
\= Expect no match
    abcXabc
No match

/(?1)[^]a()b](abc)/
    abcXabc
 0: abcXabc
 1: abc
\= Expect no match
    abcbabc
No match

/(?2)[]a()b](abc)(xyz)/
    xyzbabcxyz
 0: xyzbabcxyz
 1: abc
 2: xyz

/(?&N)[]a(?<N>)](?<M>abc)/
Failed: error 115 at offset 3: reference to non-existent subpattern
   abc<abc

/(?&N)[]a(?<N>)](abc)/
Failed: error 115 at offset 3: reference to non-existent subpattern
   abc<abc

/a[]b/
Failed: error 106 at offset 4: missing terminating ] for character class

/a[^]b/
Failed: error 106 at offset 5: missing terminating ] for character class

/a[]b/allow_empty_class,match_unset_backref,dupnames
\= Expect no match
    ab
No match

/a[]+b/allow_empty_class,match_unset_backref,dupnames
\= Expect no match
    ab
No match

/a[]*+b/allow_empty_class,match_unset_backref,dupnames
\= Expect no match
    ab
No match

/a[^]b/allow_empty_class,match_unset_backref,dupnames
    aXb
 0: aXb
    a\nb
 0: a\x0ab
\= Expect no match
    ab
No match

/a[^]+b/allow_empty_class,match_unset_backref,dupnames
    aXb
 0: aXb
    a\nX\nXb
 0: a\x0aX\x0aXb
\= Expect no match
    ab
No match

/a(?!)b/B
------------------------------------------------------------------
        Bra
        a
        *FAIL
        b
        Ket
        End
------------------------------------------------------------------

/(?!)?a/B
------------------------------------------------------------------
        Bra
        Brazero
        Assert not
        Ket
        a
        Ket
        End
------------------------------------------------------------------
    ab
 0: a

/a(*FAIL)+b/
Failed: error 109 at offset 8: quantifier does not follow a repeatable item

/(abc|pqr|123){0}[xyz]/I
Capture group count = 1
Starting code units: x y z 
Subject length lower bound = 1

/(?(?=.*b)b|^)/I,auto_callout
Capture group count = 0
May match empty string
Options: auto_callout
Subject length lower bound = 0
   adc
--->adc
 +0 ^       (?
 +2 ^       (?=
 +5 ^       .*
 +7 ^  ^    b
 +7 ^ ^     b
 +7 ^^      b
 +7 ^       b
+11 ^       ^
+12 ^       )
+13 ^       End of pattern
 0: 
   abc
--->abc
 +0 ^       (?
 +2 ^       (?=
 +5 ^       .*
 +7 ^  ^    b
 +7 ^ ^     b
 +7 ^^      b
 +8 ^ ^     )
 +9 ^       b
 +0  ^      (?
 +2  ^      (?=
 +5  ^      .*
 +7  ^ ^    b
 +7  ^^     b
 +7  ^      b
 +8  ^^     )
 +9  ^      b
+10  ^^     |
+13  ^^     End of pattern
 0: b

/(?(?=b).*b|^d)/I
Capture group count = 0
Subject length lower bound = 1

/(?(?=.*b).*b|^d)/I
Capture group count = 0
Subject length lower bound = 1

/xyz/auto_callout
  xyz
--->xyz
 +0 ^       x
 +1 ^^      y
 +2 ^ ^     z
 +3 ^  ^    End of pattern
 0: xyz
  abcxyz
--->abcxyz
 +0    ^       x
 +1    ^^      y
 +2    ^ ^     z
 +3    ^  ^    End of pattern
 0: xyz
\= Expect no match
  abc
No match
  abcxypqr
No match

/xyz/auto_callout,no_start_optimize
  abcxyz
--->abcxyz
 +0 ^          x
 +0  ^         x
 +0   ^        x
 +0    ^       x
 +1    ^^      y
 +2    ^ ^     z
 +3    ^  ^    End of pattern
 0: xyz
\= Expect no match
  abc
--->abc
 +0 ^       x
 +0  ^      x
 +0   ^     x
 +0    ^    x
No match
  abcxypqr
--->abcxypqr
 +0 ^            x
 +0  ^           x
 +0   ^          x
 +0    ^         x
 +1    ^^        y
 +2    ^ ^       z
 +0     ^        x
 +0      ^       x
 +0       ^      x
 +0        ^     x
 +0         ^    x
No match

/(*NO_START_OPT)xyz/auto_callout
  abcxyz
--->abcxyz
+15 ^          x
+15  ^         x
+15   ^        x
+15    ^       x
+16    ^^      y
+17    ^ ^     z
+18    ^  ^    End of pattern
 0: xyz

/(*NO_AUTO_POSSESS)a+b/B
------------------------------------------------------------------
        Bra
        a+
        b
        Ket
        End
------------------------------------------------------------------

/xyz/auto_callout,no_start_optimize
  abcxyz
--->abcxyz
 +0 ^          x
 +0  ^         x
 +0   ^        x
 +0    ^       x
 +1    ^^      y
 +2    ^ ^     z
 +3    ^  ^    End of pattern
 0: xyz

/^"((?(?=[a])[^"])|b)*"$/auto_callout
    "ab"
--->"ab"
 +0 ^        ^
 +1 ^        "
 +2 ^^       (
 +3 ^^       (?
 +5 ^^       (?=
 +8 ^^       [a]
+11 ^ ^      )
+12 ^^       [^"]
+16 ^ ^      )
+17 ^ ^      |
 +3 ^ ^      (?
 +5 ^ ^      (?=
 +8 ^ ^      [a]
+17 ^ ^      |
+21 ^ ^      "
+18 ^ ^      b
+19 ^  ^     )*
 +3 ^  ^     (?
 +5 ^  ^     (?=
 +8 ^  ^     [a]
+17 ^  ^     |
+21 ^  ^     "
+22 ^   ^    $
+23 ^   ^    End of pattern
 0: "ab"
 1: 

/^"((?(?=[a])[^"])|b)*"$/
    "ab"
 0: "ab"
 1: 

/^X(?5)(a)(?|(b)|(q))(c)(d)Y/
Failed: error 115 at offset 5: reference to non-existent subpattern
    XYabcdY

/^X(?&N)(a)(?|(b)|(q))(c)(d)(?<N>Y)/
    XYabcdY
 0: XYabcdY
 1: a
 2: b
 3: c
 4: d
 5: Y

/Xa{2,4}b/
    X\=ps
Partial match: X
    Xa\=ps
Partial match: Xa
    Xaa\=ps
Partial match: Xaa
    Xaaa\=ps
Partial match: Xaaa
    Xaaaa\=ps
Partial match: Xaaaa

/Xa{2,4}?b/
    X\=ps
Partial match: X
    Xa\=ps
Partial match: Xa
    Xaa\=ps
Partial match: Xaa
    Xaaa\=ps
Partial match: Xaaa
    Xaaaa\=ps
Partial match: Xaaaa

/Xa{2,4}+b/
    X\=ps
Partial match: X
    Xa\=ps
Partial match: Xa
    Xaa\=ps
Partial match: Xaa
    Xaaa\=ps
Partial match: Xaaa
    Xaaaa\=ps
Partial match: Xaaaa

/X\d{2,4}b/
    X\=ps
Partial match: X
    X3\=ps
Partial match: X3
    X33\=ps
Partial match: X33
    X333\=ps
Partial match: X333
    X3333\=ps
Partial match: X3333

/X\d{2,4}?b/
    X\=ps
Partial match: X
    X3\=ps
Partial match: X3
    X33\=ps
Partial match: X33
    X333\=ps
Partial match: X333
    X3333\=ps
Partial match: X3333

/X\d{2,4}+b/
    X\=ps
Partial match: X
    X3\=ps
Partial match: X3
    X33\=ps
Partial match: X33
    X333\=ps
Partial match: X333
    X3333\=ps
Partial match: X3333

/X\D{2,4}b/
    X\=ps
Partial match: X
    Xa\=ps
Partial match: Xa
    Xaa\=ps
Partial match: Xaa
    Xaaa\=ps
Partial match: Xaaa
    Xaaaa\=ps
Partial match: Xaaaa

/X\D{2,4}?b/
    X\=ps
Partial match: X
    Xa\=ps
Partial match: Xa
    Xaa\=ps
Partial match: Xaa
    Xaaa\=ps
Partial match: Xaaa
    Xaaaa\=ps
Partial match: Xaaaa

/X\D{2,4}+b/
    X\=ps
Partial match: X
    Xa\=ps
Partial match: Xa
    Xaa\=ps
Partial match: Xaa
    Xaaa\=ps
Partial match: Xaaa
    Xaaaa\=ps
Partial match: Xaaaa

/X[abc]{2,4}b/
    X\=ps
Partial match: X
    Xa\=ps
Partial match: Xa
    Xaa\=ps
Partial match: Xaa
    Xaaa\=ps
Partial match: Xaaa
    Xaaaa\=ps
Partial match: Xaaaa

/X[abc]{2,4}?b/
    X\=ps
Partial match: X
    Xa\=ps
Partial match: Xa
    Xaa\=ps
Partial match: Xaa
    Xaaa\=ps
Partial match: Xaaa
    Xaaaa\=ps
Partial match: Xaaaa

/X[abc]{2,4}+b/
    X\=ps
Partial match: X
    Xa\=ps
Partial match: Xa
    Xaa\=ps
Partial match: Xaa
    Xaaa\=ps
Partial match: Xaaa
    Xaaaa\=ps
Partial match: Xaaaa

/X[^a]{2,4}b/
    X\=ps
Partial match: X
    Xz\=ps
Partial match: Xz
    Xzz\=ps
Partial match: Xzz
    Xzzz\=ps
Partial match: Xzzz
    Xzzzz\=ps
Partial match: Xzzzz

/X[^a]{2,4}?b/
    X\=ps
Partial match: X
    Xz\=ps
Partial match: Xz
    Xzz\=ps
Partial match: Xzz
    Xzzz\=ps
Partial match: Xzzz
    Xzzzz\=ps
Partial match: Xzzzz

/X[^a]{2,4}+b/
    X\=ps
Partial match: X
    Xz\=ps
Partial match: Xz
    Xzz\=ps
Partial match: Xzz
    Xzzz\=ps
Partial match: Xzzz
    Xzzzz\=ps
Partial match: Xzzzz

/(Y)X\1{2,4}b/
    YX\=ps
Partial match: YX
    YXY\=ps
Partial match: YXY
    YXYY\=ps
Partial match: YXYY
    YXYYY\=ps
Partial match: YXYYY
    YXYYYY\=ps
Partial match: YXYYYY

/(Y)X\1{2,4}?b/
    YX\=ps
Partial match: YX
    YXY\=ps
Partial match: YXY
    YXYY\=ps
Partial match: YXYY
    YXYYY\=ps
Partial match: YXYYY
    YXYYYY\=ps
Partial match: YXYYYY

/(Y)X\1{2,4}+b/
    YX\=ps
Partial match: YX
    YXY\=ps
Partial match: YXY
    YXYY\=ps
Partial match: YXYY
    YXYYY\=ps
Partial match: YXYYY
    YXYYYY\=ps
Partial match: YXYYYY

/\++\KZ|\d+X|9+Y/startchar
    ++++123999\=ps
Partial match: 123999
    ++++123999Y\=ps
 0: 999Y
    ++++Z1234\=ps
 0: ++++Z
    ^^^^

/Z(*F)/
\= Expect no match
    Z\=ps
No match
    ZA\=ps
No match

/Z(?!)/
\= Expect no match
    Z\=ps
No match
    ZA\=ps
No match

/dog(sbody)?/
    dogs\=ps
 0: dog
    dogs\=ph
Partial match: dogs

/dog(sbody)??/
    dogs\=ps
 0: dog
    dogs\=ph
 0: dog

/dog|dogsbody/
    dogs\=ps
 0: dog
    dogs\=ph
 0: dog

/dogsbody|dog/
    dogs\=ps
 0: dog
    dogs\=ph
Partial match: dogs

/\bthe cat\b/
    the cat\=ps
 0: the cat
    the cat\=ph
Partial match: the cat

/abc/
   abc\=ps
 0: abc
   abc\=ph
 0: abc

/abc\K123/startchar
    xyzabc123pqr
 0: abc123
    ^^^
    xyzabc12\=ps
Partial match: abc12
    xyzabc12\=ph
Partial match: abc12

/(?<=abc)123/
    xyzabc123pqr
 0: 123
    xyzabc12\=ps
Partial match: 12
    xyzabc12\=ph
Partial match: 12

/\babc\b/
    +++abc+++
 0: abc
    +++ab\=ps
Partial match: ab
    +++ab\=ph
Partial match: ab

/(?&word)(?&element)(?(DEFINE)(?<element><[^m][^>]>[^<])(?<word>\w*+))/B
------------------------------------------------------------------
        Bra
        Recurse
        Recurse
        Cond
        Cond false
        CBra 1
        <
        [^m]
        [^>]
        >
        [^<]
        Ket
        CBra 2
        \w*+
        Ket
        Ket
        Ket
        End
------------------------------------------------------------------

/(?&word)(?&element)(?(DEFINE)(?<element><[^\d][^>]>[^<])(?<word>\w*+))/B
------------------------------------------------------------------
        Bra
        Recurse
        Recurse
        Cond
        Cond false
        CBra 1
        <
        [\x00-/:-\xff] (neg)
        [^>]
        >
        [^<]
        Ket
        CBra 2
        \w*+
        Ket
        Ket
        Ket
        End
------------------------------------------------------------------

/(ab)(x(y)z(cd(*ACCEPT)))pq/B
------------------------------------------------------------------
        Bra
        CBra 1
        ab
        Ket
        CBra 2
        x
        CBra 3
        y
        Ket
        z
        CBra 4
        cd
        Close 4
        Close 2
        *ACCEPT
        Ket
        Ket
        pq
        Ket
        End
------------------------------------------------------------------

/abc\K/aftertext,startchar
    abcdef
 0: abc
    ^^^
 0+ def
    abcdef\=notempty_atstart
 0: abc
    ^^^
 0+ def
    xyzabcdef\=notempty_atstart
 0: abc
    ^^^
 0+ def
\= Expect no match
    abcdef\=notempty
No match
    xyzabcdef\=notempty
No match

/^(?:(?=abc)|abc\K)/aftertext,startchar
    abcdef
 0: 
 0+ abcdef
    abcdef\=notempty_atstart
 0: abc
    ^^^
 0+ def
\= Expect no match
    abcdef\=notempty
No match

/a?b?/aftertext
    xyz
 0: 
 0+ xyz
    xyzabc
 0: 
 0+ xyzabc
    xyzabc\=notempty
 0: ab
 0+ c
    xyzabc\=notempty_atstart
 0: 
 0+ yzabc
    xyz\=notempty_atstart
 0: 
 0+ yz
\= Expect no match
    xyz\=notempty
No match

/^a?b?/aftertext
    xyz
 0: 
 0+ xyz
    xyzabc
 0: 
 0+ xyzabc
\= Expect no match
    xyzabc\=notempty
No match
    xyzabc\=notempty_atstart
No match
    xyz\=notempty_atstart
No match
    xyz\=notempty
No match

/^(?<name>a|b\g<name>c)/
    aaaa
 0: a
 1: a
    bacxxx
 0: bac
 1: bac
    bbaccxxx
 0: bbacc
 1: bbacc
    bbbacccxx
 0: bbbaccc
 1: bbbaccc

/^(?<name>a|b\g'name'c)/
    aaaa
 0: a
 1: a
    bacxxx
 0: bac
 1: bac
    bbaccxxx
 0: bbacc
 1: bbacc
    bbbacccxx
 0: bbbaccc
 1: bbbaccc

/^(a|b\g<1>c)/
    aaaa
 0: a
 1: a
    bacxxx
 0: bac
 1: bac
    bbaccxxx
 0: bbacc
 1: bbacc
    bbbacccxx
 0: bbbaccc
 1: bbbaccc

/^(a|b\g'1'c)/
    aaaa
 0: a
 1: a
    bacxxx
 0: bac
 1: bac
    bbaccxxx
 0: bbacc
 1: bbacc
    bbbacccxx
 0: bbbaccc
 1: bbbaccc

/^(a|b\g'-1'c)/
    aaaa
 0: a
 1: a
    bacxxx
 0: bac
 1: bac
    bbaccxxx
 0: bbacc
 1: bbacc
    bbbacccxx
 0: bbbaccc
 1: bbbaccc

/(^(a|b\g<-1>c))/
    aaaa
 0: a
 1: a
 2: a
    bacxxx
 0: bac
 1: bac
 2: bac
    bbaccxxx
 0: bbacc
 1: bbacc
 2: bbacc
    bbbacccxx
 0: bbbaccc
 1: bbbaccc
 2: bbbaccc

/(?-i:\g<name>)(?i:(?<name>a))/
    XaaX
 0: aa
 1: a
    XAAX
 0: AA
 1: A

/(?i:\g<name>)(?-i:(?<name>a))/
    XaaX
 0: aa
 1: a
\= Expect no match
    XAAX
No match

/(?-i:\g<+1>)(?i:(a))/
    XaaX
 0: aa
 1: a
    XAAX
 0: AA
 1: A

/(?=(?<regex>(?#simplesyntax)\$(?<name>[a-zA-Z_\x{7f}-\x{ff}][a-zA-Z0-9_\x{7f}-\x{ff}]*)(?:\[(?<index>[a-zA-Z0-9_\x{7f}-\x{ff}]+|\$\g<name>)\]|->\g<name>(\(.*?\))?)?|(?#simple syntax withbraces)\$\{(?:\g<name>(?<indices>\[(?:\g<index>|'(?:\\.|[^'\\])*'|"(?:\g<regex>|\\.|[^"\\])*")\])?|\g<complex>|\$\{\g<complex>\})\}|(?#complexsyntax)\{(?<complex>\$(?<segment>\g<name>(\g<indices>*|\(.*?\))?)(?:->\g<segment>)*|\$\g<complex>|\$\{\g<complex>\})\}))\{/

/(?<n>a|b|c)\g<n>*/
   abc
 0: abc
 1: a
   accccbbb
 0: accccbbb
 1: a

/^X(?7)(a)(?|(b)|(q)(r)(s))(c)(d)(Y)/
    XYabcdY
 0: XYabcdY
 1: a
 2: b
 3: <unset>
 4: <unset>
 5: c
 6: d
 7: Y

/(?<=b(?1)|zzz)(a)/
    xbaax
 0: a
 1: a
    xzzzax
 0: a
 1: a

/(a)(?<=b\1)/

/(a)(?<=b+(?1))/
Failed: error 125 at offset 3: lookbehind assertion is not fixed length

/(a+)(?<=b(?1))/
Failed: error 125 at offset 4: lookbehind assertion is not fixed length

/(a(?<=b(?1)))/
Failed: error 125 at offset 2: lookbehind assertion is not fixed length

/(?<=b(?1))xyz/
Failed: error 115 at offset 8: reference to non-existent subpattern

/(?<=b(?1))xyz(b+)pqrstuvew/
Failed: error 125 at offset 0: lookbehind assertion is not fixed length

/(a|bc)\1/I
Capture group count = 1
Max back reference = 1
Starting code units: a b 
Subject length lower bound = 2

/(a|bc)\1{2,3}/I
Capture group count = 1
Max back reference = 1
Starting code units: a b 
Subject length lower bound = 3

/(a|bc)(?1)/I
Capture group count = 1
Starting code units: a b 
Subject length lower bound = 2

/(a|b\1)(a|b\1)/I
Capture group count = 2
Max back reference = 1
Starting code units: a b 
Subject length lower bound = 2

/(a|b\1){2}/I
Capture group count = 1
Max back reference = 1
Starting code units: a b 
Subject length lower bound = 2

/(a|bbbb\1)(a|bbbb\1)/I
Capture group count = 2
Max back reference = 1
Starting code units: a b 
Subject length lower bound = 2

/(a|bbbb\1){2}/I
Capture group count = 1
Max back reference = 1
Starting code units: a b 
Subject length lower bound = 2

/^From +([^ ]+) +[a-zA-Z][a-zA-Z][a-zA-Z] +[a-zA-Z][a-zA-Z][a-zA-Z] +[0-9]?[0-9] +[0-9][0-9]:[0-9][0-9]/I
Capture group count = 1
Compile options: <none>
Overall options: anchored
First code unit = 'F'
Last code unit = ':'
Subject length lower bound = 22

/<tr([\w\W\s\d][^<>]{0,})><TD([\w\W\s\d][^<>]{0,})>([\d]{0,}\.)(.*)((<BR>([\w\W\s\d][^<>]{0,})|[\s]{0,}))<\/a><\/TD><TD([\w\W\s\d][^<>]{0,})>([\w\W\s\d][^<>]{0,})<\/TD><TD([\w\W\s\d][^<>]{0,})>([\w\W\s\d][^<>]{0,})<\/TD><\/TR>/Iis
Capture group count = 11
Options: caseless dotall
First code unit = '<'
Last code unit = '>'
Subject length lower bound = 47

"(?>.*/)foo"I
Capture group count = 0
Last code unit = 'o'
Subject length lower bound = 4

/(?(?=[^a-z]+[a-z])  \d{2}-[a-z]{3}-\d{2}  |  \d{2}-\d{2}-\d{2} ) /Ix
Capture group count = 0
Options: extended
Last code unit = '-'
Subject length lower bound = 8

/(?:(?:(?:(?:(?:(?:(?:(?:(?:(a|b|c))))))))))/Ii
Capture group count = 1
Options: caseless
Starting code units: A B C a b c 
Subject length lower bound = 1

/(?:c|d)(?:)(?:aaaaaaaa(?:)(?:bbbbbbbb)(?:bbbbbbbb(?:))(?:bbbbbbbb(?:)(?:bbbbbbbb)))/I
Capture group count = 0
Starting code units: c d 
Last code unit = 'b'
Subject length lower bound = 41

/<a[\s]+href[\s]*=[\s]*          # find <a href=
 ([\"\'])?                       # find single or double quote
 (?(1) (.*?)\1 | ([^\s]+))       # if quote found, match up to next matching
                                 # quote, otherwise match up to next space
/Iisx
Capture group count = 3
Max back reference = 1
Options: caseless dotall extended
First code unit = '<'
Last code unit = '='
Subject length lower bound = 9

/^(?!:)                       # colon disallowed at start
  (?:                         # start of item
    (?: [0-9a-f]{1,4} |       # 1-4 hex digits or
    (?(1)0 | () ) )           # if null previously matched, fail; else null
    :                         # followed by colon
  ){1,7}                      # end item; 1-7 of them required
  [0-9a-f]{1,4} $             # final hex number at end of string
  (?(1)|.)                    # check that there was an empty component
  /Iix
Capture group count = 1
Max back reference = 1
Compile options: caseless extended
Overall options: anchored caseless extended
Last code unit = ':'
Subject length lower bound = 2

/(?|(?<a>A)|(?<a>B))/I
Capture group count = 1
Named capture groups:
  a   1
Starting code units: A B 
Subject length lower bound = 1
    AB\=copy=a
 0: A
 1: A
  C A (1) a (group 1)
    BA\=copy=a
 0: B
 1: B
  C B (1) a (group 1)

/(?|(?<a>A)|(?<b>B))/
Failed: error 165 at offset 16: different names for subpatterns of the same number are not allowed

/(?:a(?<quote> (?<apostrophe>')|(?<realquote>")) |
    b(?<quote> (?<apostrophe>')|(?<realquote>")) )
    (?('quote')[a-z]+|[0-9]+)/Ix,dupnames
Capture group count = 6
Max back reference = 4
Named capture groups:
  apostrophe   2
  apostrophe   5
  quote        1
  quote        4
  realquote    3
  realquote    6
Options: dupnames extended
Starting code units: a b 
Subject length lower bound = 3
    a"aaaaa
 0: a"aaaaa
 1: "
 2: <unset>
 3: "
    b"aaaaa
 0: b"aaaaa
 1: <unset>
 2: <unset>
 3: <unset>
 4: "
 5: <unset>
 6: "
\= Expect no match
    b"11111
No match
    a"11111
No match

/^(?|(a)(b)(c)(?<D>d)|(?<D>e)) (?('D')X|Y)/IBx,dupnames
------------------------------------------------------------------
        Bra
        ^
        Bra
        CBra 1
        a
        Ket
        CBra 2
        b
        Ket
        CBra 3
        c
        Ket
        CBra 4
        d
        Ket
        Alt
        CBra 1
        e
        Ket
        Ket
        Cond
        Cond ref <D>2
        X
        Alt
        Y
        Ket
        Ket
        End
------------------------------------------------------------------
Capture group count = 4
Max back reference = 4
Named capture groups:
  D   4
  D   1
Compile options: dupnames extended
Overall options: anchored dupnames extended
Starting code units: a e 
Subject length lower bound = 2
    abcdX
 0: abcdX
 1: a
 2: b
 3: c
 4: d
    eX
 0: eX
 1: e
\= Expect no match
    abcdY
No match
    ey
No match

/(?<A>a) (b)(c)  (?<A>d  (?(R&A)$ | (?4)) )/IBx,dupnames
------------------------------------------------------------------
        Bra
        CBra 1
        a
        Ket
        CBra 2
        b
        Ket
        CBra 3
        c
        Ket
        CBra 4
        d
        Cond
        Cond recurse <A>2
        $
        Alt
        Recurse
        Ket
        Ket
        Ket
        End
------------------------------------------------------------------
Capture group count = 4
Max back reference = 4
Named capture groups:
  A   1
  A   4
Options: dupnames extended
First code unit = 'a'
Last code unit = 'd'
Subject length lower bound = 4
    abcdd
 0: abcdd
 1: a
 2: b
 3: c
 4: dd
\= Expect no match
    abcdde
No match

/abcd*/
    xxxxabcd\=ps
 0: abcd
    xxxxabcd\=ph
Partial match: abcd

/abcd*/i
    xxxxabcd\=ps
 0: abcd
    xxxxabcd\=ph
Partial match: abcd
    XXXXABCD\=ps
 0: ABCD
    XXXXABCD\=ph
Partial match: ABCD

/abc\d*/
    xxxxabc1\=ps
 0: abc1
    xxxxabc1\=ph
Partial match: abc1

/(a)bc\1*/
    xxxxabca\=ps
 0: abca
 1: a
    xxxxabca\=ph
Partial match: abca

/abc[de]*/
    xxxxabcde\=ps
 0: abcde
    xxxxabcde\=ph
Partial match: abcde

/(\3)(\1)(a)/allow_empty_class,match_unset_backref,dupnames
    cat
 0: a
 1: 
 2: 
 3: a

/(\3)(\1)(a)/I,allow_empty_class,match_unset_backref,dupnames
Capture group count = 3
Max back reference = 3
Options: allow_empty_class dupnames match_unset_backref
Last code unit = 'a'
Subject length lower bound = 1
    cat
 0: a
 1: 
 2: 
 3: a

/(\3)(\1)(a)/I
Capture group count = 3
Max back reference = 3
Last code unit = 'a'
Subject length lower bound = 3
\= Expect no match
    cat
No match

/i(?(DEFINE)(?<s>a))/I
Capture group count = 1
Named capture groups:
  s   1
First code unit = 'i'
Subject length lower bound = 1
    i
 0: i

/()i(?(1)a)/I
Capture group count = 1
Max back reference = 1
First code unit = 'i'
Subject length lower bound = 1
    ia
 0: ia
 1: 

/(?i)a(?-i)b|c/B
------------------------------------------------------------------
        Bra
     /i a
        b
        Alt
        c
        Ket
        End
------------------------------------------------------------------
    XabX
 0: ab
    XAbX
 0: Ab
    CcC
 0: c
\= Expect no match
    XABX
No match

/(?i)a(?s)b|c/B
------------------------------------------------------------------
        Bra
     /i ab
        Alt
     /i c
        Ket
        End
------------------------------------------------------------------

/(?i)a(?s-i)b|c/B
------------------------------------------------------------------
        Bra
     /i a
        b
        Alt
        c
        Ket
        End
------------------------------------------------------------------

/^(ab(c\1)d|x){2}$/B
------------------------------------------------------------------
        Bra
        ^
        CBra 1
        ab
        CBra 2
        c
        \1
        Ket
        d
        Alt
        x
        Ket
        CBra 1
        ab
        CBra 2
        c
        \1
        Ket
        d
        Alt
        x
        Ket
        $
        Ket
        End
------------------------------------------------------------------
    xabcxd
 0: xabcxd
 1: abcxd
 2: cx

/^(?&t)*+(?(DEFINE)(?<t>.))$/B
------------------------------------------------------------------
        Bra
        ^
        Braposzero
        SBraPos
        Recurse
        KetRpos
        Cond
        Cond false
        CBra 1
        Any
        Ket
        Ket
        $
        Ket
        End
------------------------------------------------------------------

/^(?&t)*(?(DEFINE)(?<t>.))$/B
------------------------------------------------------------------
        Bra
        ^
        Brazero
        SBra
        Recurse
        KetRmax
        Cond
        Cond false
        CBra 1
        Any
        Ket
        Ket
        $
        Ket
        End
------------------------------------------------------------------

# This one is here because Perl gives the match as "b" rather than "ab". I
# believe this to be a Perl bug.

/(?>a\Kb)z|(ab)/
    ab\=startchar
 0: ab
 1: ab

/(?P<L1>(?P<L2>0|)|(?P>L2)(?P>L1))/
    abcd
 0: 
 1: 
 2: 
    0abc
 0: 0
 1: 0
 2: 0

/abc(*MARK:)pqr/
Failed: error 166 at offset 10: (*MARK) must have an argument

/abc(*:)pqr/
Failed: error 166 at offset 6: (*MARK) must have an argument

/(*COMMIT:X)/B
------------------------------------------------------------------
        Bra
        *COMMIT X
        Ket
        End
------------------------------------------------------------------

# This should, and does, fail. In Perl, it does not, which I think is a
# bug because replacing the B in the pattern by (B|D) does make it fail.
# Turning off Perl's optimization by inserting (??{""}) also makes it fail.

/A(*COMMIT)B/aftertext,mark
\= Expect no match
    ACABX
No match

# These should be different, but in Perl they are not, which I think
# is a bug in Perl.

/A(*THEN)B|A(*THEN)C/mark
    AC
 0: AC

/A(*PRUNE)B|A(*PRUNE)C/mark
\= Expect no match
    AC
No match

# Mark names can be duplicated. Perl doesn't give a mark for this one,
# though PCRE2 does.

/^A(*:A)B|^X(*:A)Y/mark
\= Expect no match
    XAQQ
No match, mark = A

# COMMIT at the start of a pattern should be the same as an anchor. Perl
# optimizations defeat this. So does the PCRE2 optimization unless we disable
# it.

/(*COMMIT)ABC/
    ABCDEFG
 0: ABC

/(*COMMIT)ABC/no_start_optimize
\= Expect no match
    DEFGABC
No match

/^(ab (c+(*THEN)cd) | xyz)/x
\= Expect no match
    abcccd
No match

/^(ab (c+(*PRUNE)cd) | xyz)/x
\= Expect no match
    abcccd
No match

/^(ab (c+(*FAIL)cd) | xyz)/x
\= Expect no match
    abcccd
No match

# Perl gets some of these wrong

/(?>.(*ACCEPT))*?5/
    abcde
 0: a

/(.(*ACCEPT))*?5/
    abcde
 0: a
 1: a

/(.(*ACCEPT))5/
    abcde
 0: a
 1: a

/(.(*ACCEPT))*5/
    abcde
 0: a
 1: a

/A\NB./B
------------------------------------------------------------------
        Bra
        A
        Any
        B
        Any
        Ket
        End
------------------------------------------------------------------
    ACBD
 0: ACBD
\= Expect no match
    A\nB
No match
    ACB\n
No match

/A\NB./Bs
------------------------------------------------------------------
        Bra
        A
        Any
        B
        AllAny
        Ket
        End
------------------------------------------------------------------
    ACBD
 0: ACBD
    ACB\n
 0: ACB\x0a
\= Expect no match
    A\nB
No match

/A\NB/newline=crlf
    A\nB
 0: A\x0aB
    A\rB
 0: A\x0dB
\= Expect no match
    A\r\nB
No match

/\R+b/B
------------------------------------------------------------------
        Bra
        \R++
        b
        Ket
        End
------------------------------------------------------------------

/\R+\n/B
------------------------------------------------------------------
        Bra
        \R+
        \x0a
        Ket
        End
------------------------------------------------------------------

/\R+\d/B
------------------------------------------------------------------
        Bra
        \R++
        \d
        Ket
        End
------------------------------------------------------------------

/\d*\R/B
------------------------------------------------------------------
        Bra
        \d*+
        \R
        Ket
        End
------------------------------------------------------------------

/\s*\R/B
------------------------------------------------------------------
        Bra
        \s*
        \R
        Ket
        End
------------------------------------------------------------------
    \x20\x0a
 0:  \x0a
    \x20\x0d
 0:  \x0d
    \x20\x0d\x0a
 0:  \x0d\x0a

/\S*\R/B
------------------------------------------------------------------
        Bra
        \S*+
        \R
        Ket
        End
------------------------------------------------------------------
    a\x0a
 0: a\x0a

/X\h*\R/B
------------------------------------------------------------------
        Bra
        X
        \h*+
        \R
        Ket
        End
------------------------------------------------------------------
    X\x20\x0a
 0: X \x0a

/X\H*\R/B
------------------------------------------------------------------
        Bra
        X
        \H*
        \R
        Ket
        End
------------------------------------------------------------------
    X\x0d\x0a
 0: X\x0d\x0a

/X\H+\R/B
------------------------------------------------------------------
        Bra
        X
        \H+
        \R
        Ket
        End
------------------------------------------------------------------
    X\x0d\x0a
 0: X\x0d\x0a

/X\H++\R/B
------------------------------------------------------------------
        Bra
        X
        \H++
        \R
        Ket
        End
------------------------------------------------------------------
\= Expect no match
    X\x0d\x0a
No match

/(?<=abc)def/
    abc\=ph
Partial match: 

/abc$/
    abc
 0: abc
    abc\=ps
 0: abc
    abc\=ph
Partial match: abc

/abc$/m
    abc
 0: abc
    abc\n
 0: abc
    abc\=ph
Partial match: abc
    abc\n\=ph
 0: abc
    abc\=ps
 0: abc
    abc\n\=ps
 0: abc

/abc\z/
    abc
 0: abc
    abc\=ps
 0: abc
    abc\=ph
Partial match: abc

/abc\Z/
    abc
 0: abc
    abc\=ps
 0: abc
    abc\=ph
Partial match: abc

/abc\b/
    abc
 0: abc
    abc\=ps
 0: abc
    abc\=ph
Partial match: abc

/abc\B/
    abc\=ps
Partial match: abc
    abc\=ph
Partial match: abc
\= Expect no match
    abc
No match

/.+/
\= Bad offsets
    abc\=offset=4
Failed: error -33: bad offset value
    abc\=offset=-4
** Invalid value in 'offset=-4'
\= Valid data
    abc\=offset=0
 0: abc
    abc\=offset=1
 0: bc
    abc\=offset=2
 0: c
\= Expect no match
    abc\=offset=3
No match

/^\c/
Failed: error 168 at offset 3: \c must be followed by a printable ASCII character

/(?P<abn>(?P=abn)xxx)/B
------------------------------------------------------------------
        Bra
        CBra 1
        \1
        xxx
        Ket
        Ket
        End
------------------------------------------------------------------

/(a\1z)/B
------------------------------------------------------------------
        Bra
        CBra 1
        a
        \1
        z
        Ket
        Ket
        End
------------------------------------------------------------------

/(?P<abn>(?P=abn)(?<badstufxxx)/B
Failed: error 142 at offset 29: syntax error in subpattern name (missing terminator?)

/(?P<abn>(?P=axn)xxx)/B
Failed: error 115 at offset 12: reference to non-existent subpattern

/(?P<abn>(?P=axn)xxx)(?<axn>yy)/B
------------------------------------------------------------------
        Bra
        CBra 1
        \2
        xxx
        Ket
        CBra 2
        yy
        Ket
        Ket
        End
------------------------------------------------------------------

# These tests are here because Perl gets the first one wrong.

/(\R*)(.)/s
    \r\n
 0: \x0d
 1: 
 2: \x0d
    \r\r\n\n\r
 0: \x0d\x0d\x0a\x0a\x0d
 1: \x0d\x0d\x0a\x0a
 2: \x0d
    \r\r\n\n\r\n
 0: \x0d\x0d\x0a\x0a\x0d
 1: \x0d\x0d\x0a\x0a
 2: \x0d

/(\R)*(.)/s
    \r\n
 0: \x0d
 1: <unset>
 2: \x0d
    \r\r\n\n\r
 0: \x0d\x0d\x0a\x0a\x0d
 1: \x0a
 2: \x0d
    \r\r\n\n\r\n
 0: \x0d\x0d\x0a\x0a\x0d
 1: \x0a
 2: \x0d

/((?>\r\n|\n|\x0b|\f|\r|\x85)*)(.)/s
    \r\n
 0: \x0d
 1: 
 2: \x0d
    \r\r\n\n\r
 0: \x0d\x0d\x0a\x0a\x0d
 1: \x0d\x0d\x0a\x0a
 2: \x0d
    \r\r\n\n\r\n
 0: \x0d\x0d\x0a\x0a\x0d
 1: \x0d\x0d\x0a\x0a
 2: \x0d

# -------------

/^abc$/B
------------------------------------------------------------------
        Bra
        ^
        abc
        $
        Ket
        End
------------------------------------------------------------------

/^abc$/Bm
------------------------------------------------------------------
        Bra
     /m ^
        abc
     /m $
        Ket
        End
------------------------------------------------------------------

/^(a)*+(\w)/
    aaaaX
 0: aaaaX
 1: a
 2: X
\= Expect no match
    aaaa
No match

/^(?:a)*+(\w)/
    aaaaX
 0: aaaaX
 1: X
\= Expect no match
    aaaa
No match

/(a)++1234/IB
------------------------------------------------------------------
        Bra
        CBraPos 1
        a
        KetRpos
        1234
        Ket
        End
------------------------------------------------------------------
Capture group count = 1
First code unit = 'a'
Last code unit = '4'
Subject length lower bound = 5

/([abc])++1234/I
Capture group count = 1
Starting code units: a b c 
Last code unit = '4'
Subject length lower bound = 5

/(?<=(abc)+)X/
Failed: error 125 at offset 0: lookbehind assertion is not fixed length

/(^ab)/I
Capture group count = 1
Compile options: <none>
Overall options: anchored
First code unit = 'a'
Subject length lower bound = 2

/(^ab)++/I
Capture group count = 1
Compile options: <none>
Overall options: anchored
First code unit = 'a'
Subject length lower bound = 2

/(^ab|^)+/I
Capture group count = 1
May match empty string
Compile options: <none>
Overall options: anchored
Subject length lower bound = 0

/(^ab|^)++/I
Capture group count = 1
May match empty string
Compile options: <none>
Overall options: anchored
Subject length lower bound = 0

/(?:^ab)/I
Capture group count = 0
Compile options: <none>
Overall options: anchored
First code unit = 'a'
Subject length lower bound = 2

/(?:^ab)++/I
Capture group count = 0
Compile options: <none>
Overall options: anchored
First code unit = 'a'
Subject length lower bound = 2

/(?:^ab|^)+/I
Capture group count = 0
May match empty string
Compile options: <none>
Overall options: anchored
Subject length lower bound = 0

/(?:^ab|^)++/I
Capture group count = 0
May match empty string
Compile options: <none>
Overall options: anchored
Subject length lower bound = 0

/(.*ab)/I
Capture group count = 1
First code unit at start or follows newline
Last code unit = 'b'
Subject length lower bound = 2

/(.*ab)++/I
Capture group count = 1
First code unit at start or follows newline
Last code unit = 'b'
Subject length lower bound = 2

/(.*ab|.*)+/I
Capture group count = 1
May match empty string
First code unit at start or follows newline
Subject length lower bound = 0

/(.*ab|.*)++/I
Capture group count = 1
May match empty string
First code unit at start or follows newline
Subject length lower bound = 0

/(?:.*ab)/I
Capture group count = 0
First code unit at start or follows newline
Last code unit = 'b'
Subject length lower bound = 2

/(?:.*ab)++/I
Capture group count = 0
First code unit at start or follows newline
Last code unit = 'b'
Subject length lower bound = 2

/(?:.*ab|.*)+/I
Capture group count = 0
May match empty string
First code unit at start or follows newline
Subject length lower bound = 0

/(?:.*ab|.*)++/I
Capture group count = 0
May match empty string
First code unit at start or follows newline
Subject length lower bound = 0

/(?=a)[bcd]/I
Capture group count = 0
First code unit = 'a'
Subject length lower bound = 1

/((?=a))[bcd]/I
Capture group count = 1
First code unit = 'a'
Subject length lower bound = 1

/((?=a))+[bcd]/I
Capture group count = 1
First code unit = 'a'
Subject length lower bound = 1

/((?=a))++[bcd]/I
Capture group count = 1
First code unit = 'a'
Subject length lower bound = 1

/(?=a+)[bcd]/Ii
Capture group count = 0
Options: caseless
First code unit = 'a' (caseless)
Subject length lower bound = 1

/(?=a+?)[bcd]/Ii
Capture group count = 0
Options: caseless
First code unit = 'a' (caseless)
Subject length lower bound = 1

/(?=a++)[bcd]/Ii
Capture group count = 0
Options: caseless
First code unit = 'a' (caseless)
Subject length lower bound = 1

/(?=a{3})[bcd]/Ii
Capture group count = 0
Options: caseless
First code unit = 'a' (caseless)
Last code unit = 'a' (caseless)
Subject length lower bound = 2

/(abc)\1+/

# Perl doesn't get these right IMO (the 3rd is PCRE2-specific)

/(?1)(?:(b(*ACCEPT))){0}/
    b
 0: b

/(?1)(?:(b(*ACCEPT))){0}c/
    bc
 0: bc
\= Expect no match
    b
No match

/(?1)(?:((*ACCEPT))){0}c/
    c
 0: c
    c\=notempty
 0: c

/^.*?(?(?=a)a|b(*THEN)c)/
\= Expect no match
    ba
No match

/^.*?(?(?=a)a|bc)/
    ba
 0: ba

/^.*?(?(?=a)a(*THEN)b|c)/
\= Expect no match
    ac
No match

/^.*?(?(?=a)a(*THEN)b)c/
\= Expect no match
    ac
No match

/^.*?(a(*THEN)b)c/
\= Expect no match
    aabc
No match

/^.*? (?1) c (?(DEFINE)(a(*THEN)b))/x
    aabc
 0: aabc

/^.*?(a(*THEN)b|z)c/
    aabc
 0: aabc
 1: ab

/^.*?(z|a(*THEN)b)c/
    aabc
 0: aabc
 1: ab

# These are here because they are not Perl-compatible; the studying means the
# mark is not seen.

/(*MARK:A)(*SKIP:B)(C|X)/mark
    C
 0: C
 1: C
MK: A
\= Expect no match
    D
No match, mark = A

/(*:A)A+(*SKIP:A)(B|Z)/mark
\= Expect no match
    AAAC
No match, mark = A

# ----------------------------

"(?=a*(*ACCEPT)b)c"
    c
 0: c
    c\=notempty
 0: c

/(?1)c(?(DEFINE)((*ACCEPT)b))/
    c
 0: c
    c\=notempty
 0: c

/(?>(*ACCEPT)b)c/
    c
 0: 
\= Expect no match
    c\=notempty
No match

/(?:(?>(a)))+a%/allaftertext
    %aa%
 0: aa%
 0+ 
 1: a
 1+ a%

/(a)b|ac/allaftertext
    ac\=ovector=1
 0: ac
 0+ 

/(a)(b)x|abc/allaftertext
     abc\=ovector=2
 0: abc
 0+ 

/(a)bc|(a)(b)\2/
    abc\=ovector=1
Matched, but too many substrings
 0: abc
    abc\=ovector=2
 0: abc
 1: a
    aba\=ovector=1
Matched, but too many substrings
 0: aba
    aba\=ovector=2
Matched, but too many substrings
 0: aba
 1: <unset>
    aba\=ovector=3
Matched, but too many substrings
 0: aba
 1: <unset>
 2: a
    aba\=ovector=4
 0: aba
 1: <unset>
 2: a
 3: b

/(?(DEFINE)(a(?2)|b)(b(?1)|a))(?:(?1)|(?2))/I
Capture group count = 2
May match empty string
Subject length lower bound = 0

/(a(?2)|b)(b(?1)|a)(?:(?1)|(?2))/I
Capture group count = 2
Starting code units: a b 
Subject length lower bound = 3

/(a(?2)|b)(b(?1)|a)(?1)(?2)/I
Capture group count = 2
Starting code units: a b 
Subject length lower bound = 4

/(abc)(?1)/I
Capture group count = 1
First code unit = 'a'
Last code unit = 'c'
Subject length lower bound = 6

/(?:(foo)|(bar)|(baz))X/allcaptures
    bazfooX
 0: fooX
 1: foo
 2: <unset>
 3: <unset>
    foobazbarX
 0: barX
 1: <unset>
 2: bar
 3: <unset>
    barfooX
 0: fooX
 1: foo
 2: <unset>
 3: <unset>
    bazX
 0: bazX
 1: <unset>
 2: <unset>
 3: baz
    foobarbazX
 0: bazX
 1: <unset>
 2: <unset>
 3: baz
    bazfooX\=ovector=0
 0: fooX
 1: foo
 2: <unset>
 3: <unset>
    bazfooX\=ovector=1
Matched, but too many substrings
 0: fooX
    bazfooX\=ovector=2
 0: fooX
 1: foo
    bazfooX\=ovector=3
 0: fooX
 1: foo
 2: <unset>

/(?=abc){3}abc/B
------------------------------------------------------------------
        Bra
        Assert
        abc
        Ket
        Assert
        abc
        Ket
        Assert
        abc
        Ket
        abc
        Ket
        End
------------------------------------------------------------------

/(?=abc)+abc/B
------------------------------------------------------------------
        Bra
        Assert
        abc
        Ket
        Brazero
        Assert
        abc
        Ket
        abc
        Ket
        End
------------------------------------------------------------------

/(?=abc)++abc/B
------------------------------------------------------------------
        Bra
        Once
        Assert
        abc
        Ket
        Brazero
        Assert
        abc
        Ket
        Ket
        abc
        Ket
        End
------------------------------------------------------------------

/(?=abc){0}xyz/B
------------------------------------------------------------------
        Bra
        Skip zero
        Assert
        abc
        Ket
        xyz
        Ket
        End
------------------------------------------------------------------

/(?=(a))?./B
------------------------------------------------------------------
        Bra
        Brazero
        Assert
        CBra 1
        a
        Ket
        Ket
        Any
        Ket
        End
------------------------------------------------------------------

/(?=(a))??./B
------------------------------------------------------------------
        Bra
        Braminzero
        Assert
        CBra 1
        a
        Ket
        Ket
        Any
        Ket
        End
------------------------------------------------------------------

/^(?=(a)){0}b(?1)/B
------------------------------------------------------------------
        Bra
        ^
        Skip zero
        Assert
        CBra 1
        a
        Ket
        Ket
        b
        Recurse
        Ket
        End
------------------------------------------------------------------

/(?(DEFINE)(a))?b(?1)/B
------------------------------------------------------------------
        Bra
        Cond
        Cond false
        CBra 1
        a
        Ket
        Ket
        b
        Recurse
        Ket
        End
------------------------------------------------------------------

/^(?=(?1))?[az]([abc])d/B
------------------------------------------------------------------
        Bra
        ^
        Brazero
        Assert
        Recurse
        Ket
        [az]
        CBra 1
        [a-c]
        Ket
        d
        Ket
        End
------------------------------------------------------------------

/^(?!a){0}\w+/B
------------------------------------------------------------------
        Bra
        ^
        Skip zero
        Assert not
        a
        Ket
        \w++
        Ket
        End
------------------------------------------------------------------

/(?<=(abc))?xyz/B
------------------------------------------------------------------
        Bra
        Brazero
        Assert back
        Reverse
        CBra 1
        abc
        Ket
        Ket
        xyz
        Ket
        End
------------------------------------------------------------------

/[:a[:abc]b:]/B
------------------------------------------------------------------
        Bra
        [:[a-c]
        b:]
        Ket
        End
------------------------------------------------------------------

/^(a(*:A)(d|e(*:B))z|aeq)/auto_callout
    adz
--->adz
 +0 ^       ^
 +1 ^       (
 +2 ^       a
 +3 ^^      (*:A)
 +8 ^^      (
Latest Mark: A
 +9 ^^      d
+10 ^ ^     |
+18 ^ ^     z
+19 ^  ^    |
+24 ^  ^    End of pattern
 0: adz
 1: adz
 2: d
    aez
--->aez
 +0 ^       ^
 +1 ^       (
 +2 ^       a
 +3 ^^      (*:A)
 +8 ^^      (
Latest Mark: A
 +9 ^^      d
+11 ^^      e
+12 ^ ^     (*:B)
+17 ^ ^     )
Latest Mark: B
+18 ^ ^     z
+19 ^  ^    |
+24 ^  ^    End of pattern
 0: aez
 1: aez
 2: e
    aeqwerty
--->aeqwerty
 +0 ^            ^
 +1 ^            (
 +2 ^            a
 +3 ^^           (*:A)
 +8 ^^           (
Latest Mark: A
 +9 ^^           d
+11 ^^           e
+12 ^ ^          (*:B)
+17 ^ ^          )
Latest Mark: B
+18 ^ ^          z
+20 ^            a
+21 ^^           e
+22 ^ ^          q
+23 ^  ^         )
+24 ^  ^         End of pattern
 0: aeq
 1: aeq

/.(*F)/
\= Expect no match
    abc\=ph
No match

/\btype\b\W*?\btext\b\W*?\bjavascript\b/I
Capture group count = 0
Max lookbehind = 1
First code unit = 't'
Last code unit = 't'
Subject length lower bound = 18

/\btype\b\W*?\btext\b\W*?\bjavascript\b|\burl\b\W*?\bshell:|<input\b.*?\btype\b\W*?\bimage\b|\bonkeyup\b\W*?\=/I
Capture group count = 0
Max lookbehind = 1
Starting code units: < o t u 
Subject length lower bound = 8

/a(*SKIP)c|b(*ACCEPT)|/I,aftertext
Capture group count = 0
May match empty string
Subject length lower bound = 0
    a
 0: 
 0+ 

/a(*SKIP)c|b(*ACCEPT)cd(*ACCEPT)|x/I
Capture group count = 0
Starting code units: a b x 
Subject length lower bound = 1
    ax
 0: x

'a*(*ACCEPT)b'aftertext
    abc\=notempty_atstart
 0: a
 0+ bc
    bbb\=notempty_atstart
 0: 
 0+ bb
\= Expect no match
    \=notempty_atstart
No match

/(*ACCEPT)a/I,aftertext
Capture group count = 0
May match empty string
Subject length lower bound = 0
    bax
 0: 
 0+ bax

/z(*ACCEPT)a/I,aftertext
Capture group count = 0
First code unit = 'z'
Subject length lower bound = 1
    baxzbx
 0: z
 0+ bx

/^(?>a+)(?>(z+))\w/B
------------------------------------------------------------------
        Bra
        ^
        Once
        a++
        Ket
        Once
        CBra 1
        z++
        Ket
        Ket
        \w
        Ket
        End
------------------------------------------------------------------
    aaaazzzzb
 0: aaaazzzzb
 1: zzzz
\= Expect no match
    aazz
No match

/(.)(\1|a(?2))/
    bab
 0: bab
 1: b
 2: ab

/\1|(.)(?R)\1/
    cbbbc
 0: cbbbc
 1: c

/(.)((?(1)c|a)|a(?2))/
\= Expect no match
    baa
No match

/(?P<abn>(?P=abn)xxx)/B
------------------------------------------------------------------
        Bra
        CBra 1
        \1
        xxx
        Ket
        Ket
        End
------------------------------------------------------------------

/(a\1z)/B
------------------------------------------------------------------
        Bra
        CBra 1
        a
        \1
        z
        Ket
        Ket
        End
------------------------------------------------------------------

/^a\x41z/alt_bsux,allow_empty_class,match_unset_backref,dupnames
    aAz
 0: aAz
\= Expect no match
    ax41z
No match

/^a[m\x41]z/alt_bsux,allow_empty_class,match_unset_backref,dupnames
    aAz
 0: aAz

/^a\x1z/alt_bsux,allow_empty_class,match_unset_backref,dupnames
    ax1z
 0: ax1z

/^a\u0041z/alt_bsux,allow_empty_class,match_unset_backref,dupnames
    aAz
 0: aAz
\= Expect no match
    au0041z
No match

/^a[m\u0041]z/alt_bsux,allow_empty_class,match_unset_backref,dupnames
    aAz
 0: aAz

/^a\u041z/alt_bsux,allow_empty_class,match_unset_backref,dupnames
    au041z
 0: au041z
\= Expect no match
    aAz
No match

/^a\U0041z/alt_bsux,allow_empty_class,match_unset_backref,dupnames
    aU0041z
 0: aU0041z
\= Expect no match
    aAz
No match
    
/^\u{7a}/alt_bsux
    u{7a}
 0: u{7a}
\= Expect no match
    zoo 
No match

/^\u{7a}/extra_alt_bsux
    zoo 
 0: z

/(?(?=c)c|d)++Y/B
------------------------------------------------------------------
        Bra
        BraPos
        Cond
        Assert
        c
        Ket
        c
        Alt
        d
        Ket
        KetRpos
        Y
        Ket
        End
------------------------------------------------------------------

/(?(?=c)c|d)*+Y/B
------------------------------------------------------------------
        Bra
        Braposzero
        BraPos
        Cond
        Assert
        c
        Ket
        c
        Alt
        d
        Ket
        KetRpos
        Y
        Ket
        End
------------------------------------------------------------------

/a[\NB]c/
Failed: error 171 at offset 4: \N is not supported in a class
    aNc

/a[B-\Nc]/
Failed: error 150 at offset 6: invalid range in character class

/a[B\Nc]/
Failed: error 171 at offset 5: \N is not supported in a class

/(a)(?2){0,1999}?(b)/

/(a)(?(DEFINE)(b))(?2){0,1999}?(?2)/

# This test, with something more complicated than individual letters, causes
# different behaviour in Perl. Perhaps it disables some optimization; no tag is
# passed back for the failures, whereas in PCRE2 there is a tag.

/(A|P)(*:A)(B|P) | (X|P)(X|P)(*:B)(Y|P)/x,mark
    AABC
 0: AB
 1: A
 2: B
MK: A
    XXYZ
 0: XXY
 1: <unset>
 2: <unset>
 3: X
 4: X
 5: Y
MK: B
\= Expect no match
    XAQQ
No match, mark = A
    XAQQXZZ
No match, mark = A
    AXQQQ
No match, mark = A
    AXXQQQ
No match, mark = B

# Perl doesn't give marks for these, though it does if the alternatives are
# replaced by single letters.

/(b|q)(*:m)f|a(*:n)w/mark
    aw
 0: aw
MK: n
\= Expect no match
    abc
No match, mark = m

/(q|b)(*:m)f|a(*:n)w/mark
    aw
 0: aw
MK: n
\= Expect no match
    abc
No match, mark = m

# After a partial match, the behaviour is as for a failure.

/^a(*:X)bcde/mark
   abc\=ps
Partial match, mark=X: abc

# These are here because Perl doesn't return a mark, except for the first.

/(?=(*:x))(q|)/aftertext,mark
    abc
 0: 
 0+ abc
 1: 
MK: x

/(?=(*:x))((*:y)q|)/aftertext,mark
    abc
 0: 
 0+ abc
 1: 
MK: x

/(?=(*:x))(?:(*:y)q|)/aftertext,mark
    abc
 0: 
 0+ abc
MK: x

/(?=(*:x))(?>(*:y)q|)/aftertext,mark
    abc
 0: 
 0+ abc
MK: x

/(?=a(*:x))(?!a(*:y)c)/aftertext,mark
    ab
 0: 
 0+ ab
MK: x

/(?=a(*:x))(?=a(*:y)c|)/aftertext,mark
    ab
 0: 
 0+ ab
MK: x

/(..)\1/
    ab\=ps
Partial match: ab
    aba\=ps
Partial match: aba
    abab\=ps
 0: abab
 1: ab

/(..)\1/i
    ab\=ps
Partial match: ab
    abA\=ps
Partial match: abA
    aBAb\=ps
 0: aBAb
 1: aB

/(..)\1{2,}/
    ab\=ps
Partial match: ab
    aba\=ps
Partial match: aba
    abab\=ps
Partial match: abab
    ababa\=ps
Partial match: ababa
    ababab\=ps
 0: ababab
 1: ab
    ababab\=ph
Partial match: ababab
    abababa\=ps
 0: ababab
 1: ab
    abababa\=ph
Partial match: abababa

/(..)\1{2,}/i
    ab\=ps
Partial match: ab
    aBa\=ps
Partial match: aBa
    aBAb\=ps
Partial match: aBAb
    AbaBA\=ps
Partial match: AbaBA
    abABAb\=ps
 0: abABAb
 1: ab
    aBAbaB\=ph
Partial match: aBAbaB
    abABabA\=ps
 0: abABab
 1: ab
    abaBABa\=ph
Partial match: abaBABa

/(..)\1{2,}?x/i
    ab\=ps
Partial match: ab
    abA\=ps
Partial match: abA
    aBAb\=ps
Partial match: aBAb
    abaBA\=ps
Partial match: abaBA
    abAbaB\=ps
Partial match: abAbaB
    abaBabA\=ps
Partial match: abaBabA
    abAbABaBx\=ps
 0: abAbABaBx
 1: ab

/^(..)\1/
    aba\=ps
Partial match: aba

/^(..)\1{2,3}x/
    aba\=ps
Partial match: aba
    ababa\=ps
Partial match: ababa
    ababa\=ph
Partial match: ababa
    abababx
 0: abababx
 1: ab
    ababababx
 0: ababababx
 1: ab

/^(..)\1{2,3}?x/
    aba\=ps
Partial match: aba
    ababa\=ps
Partial match: ababa
    ababa\=ph
Partial match: ababa
    abababx
 0: abababx
 1: ab
    ababababx
 0: ababababx
 1: ab

/^(..)(\1{2,3})ab/
    abababab
 0: abababab
 1: ab
 2: abab

/^\R/
    \r\=ps
 0: \x0d
    \r\=ph
Partial match: \x0d

/^\R{2,3}x/
    \r\=ps
Partial match: \x0d
    \r\=ph
Partial match: \x0d
    \r\r\=ps
Partial match: \x0d\x0d
    \r\r\=ph
Partial match: \x0d\x0d
    \r\r\r\=ps
Partial match: \x0d\x0d\x0d
    \r\r\r\=ph
Partial match: \x0d\x0d\x0d
    \r\rx
 0: \x0d\x0dx
    \r\r\rx
 0: \x0d\x0d\x0dx

/^\R{2,3}?x/
    \r\=ps
Partial match: \x0d
    \r\=ph
Partial match: \x0d
    \r\r\=ps
Partial match: \x0d\x0d
    \r\r\=ph
Partial match: \x0d\x0d
    \r\r\r\=ps
Partial match: \x0d\x0d\x0d
    \r\r\r\=ph
Partial match: \x0d\x0d\x0d
    \r\rx
 0: \x0d\x0dx
    \r\r\rx
 0: \x0d\x0d\x0dx

/^\R?x/
    \r\=ps
Partial match: \x0d
    \r\=ph
Partial match: \x0d
    x
 0: x
    \rx
 0: \x0dx

/^\R+x/
    \r\=ps
Partial match: \x0d
    \r\=ph
Partial match: \x0d
    \r\n\=ps
Partial match: \x0d\x0a
    \r\n\=ph
Partial match: \x0d\x0a
    \rx
 0: \x0dx

/^a$/newline=crlf
    a\r\=ps
Partial match: a\x0d
    a\r\=ph
Partial match: a\x0d

/^a$/m,newline=crlf
    a\r\=ps
Partial match: a\x0d
    a\r\=ph
Partial match: a\x0d

/^(a$|a\r)/newline=crlf
    a\r\=ps
 0: a\x0d
 1: a\x0d
    a\r\=ph
Partial match: a\x0d

/^(a$|a\r)/m,newline=crlf
    a\r\=ps
 0: a\x0d
 1: a\x0d
    a\r\=ph
Partial match: a\x0d

/./newline=crlf
    \r\=ps
 0: \x0d
    \r\=ph
Partial match: \x0d

/.{2,3}/newline=crlf
    \r\=ps
Partial match: \x0d
    \r\=ph
Partial match: \x0d
    \r\r\=ps
 0: \x0d\x0d
    \r\r\=ph
Partial match: \x0d\x0d
    \r\r\r\=ps
 0: \x0d\x0d\x0d
    \r\r\r\=ph
Partial match: \x0d\x0d\x0d

/.{2,3}?/newline=crlf
    \r\=ps
Partial match: \x0d
    \r\=ph
Partial match: \x0d
    \r\r\=ps
 0: \x0d\x0d
    \r\r\=ph
Partial match: \x0d\x0d
    \r\r\r\=ps
 0: \x0d\x0d
    \r\r\r\=ph
 0: \x0d\x0d

"AB(C(D))(E(F))?(?(?=\2)(?=\4))"
    ABCDGHI\=ovector=01
Matched, but too many substrings
 0: ABCD

# These are all run as real matches in test 1; here we are just checking the
# settings of the anchored and startline bits.

/(?>.*?a)(?<=ba)/I
Capture group count = 0
Max lookbehind = 2
Last code unit = 'a'
Subject length lower bound = 1

/(?:.*?a)(?<=ba)/I
Capture group count = 0
Max lookbehind = 2
First code unit at start or follows newline
Last code unit = 'a'
Subject length lower bound = 1

/.*?a(*PRUNE)b/I
Capture group count = 0
Last code unit = 'b'
Subject length lower bound = 2

/.*?a(*PRUNE)b/Is
Capture group count = 0
Options: dotall
Last code unit = 'b'
Subject length lower bound = 2

/^a(*PRUNE)b/Is
Capture group count = 0
Compile options: dotall
Overall options: anchored dotall
First code unit = 'a'
Subject length lower bound = 2

/.*?a(*SKIP)b/I
Capture group count = 0
Last code unit = 'b'
Subject length lower bound = 2

/(?>.*?a)b/Is
Capture group count = 0
Options: dotall
Last code unit = 'b'
Subject length lower bound = 2

/(?>.*?a)b/I
Capture group count = 0
Last code unit = 'b'
Subject length lower bound = 2

/(?>^a)b/Is
Capture group count = 0
Compile options: dotall
Overall options: anchored dotall
First code unit = 'a'
Subject length lower bound = 2

/(?>.*?)(?<=(abcd)|(wxyz))/I
Capture group count = 2
Max lookbehind = 4
May match empty string
Subject length lower bound = 0

/(?>.*)(?<=(abcd)|(wxyz))/I
Capture group count = 2
Max lookbehind = 4
May match empty string
Subject length lower bound = 0

"(?>.*)foo"I
Capture group count = 0
Last code unit = 'o'
Subject length lower bound = 3

"(?>.*?)foo"I
Capture group count = 0
Last code unit = 'o'
Subject length lower bound = 3

/(?>^abc)/Im
Capture group count = 0
Options: multiline
First code unit at start or follows newline
Last code unit = 'c'
Subject length lower bound = 3

/(?>.*abc)/Im
Capture group count = 0
Options: multiline
Last code unit = 'c'
Subject length lower bound = 3

/(?:.*abc)/Im
Capture group count = 0
Options: multiline
First code unit at start or follows newline
Last code unit = 'c'
Subject length lower bound = 3

/(?:(a)+(?C1)bb|aa(?C2)b)/
    aab\=callout_capture
Callout 1: last capture = 1
 1: a
--->aab
    ^ ^     b
Callout 1: last capture = 1
 1: a
--->aab
    ^^      b
Callout 2: last capture = 0
--->aab
    ^ ^     b
 0: aab

/(?:(a)++(?C1)bb|aa(?C2)b)/
    aab\=callout_capture
Callout 1: last capture = 1
 1: a
--->aab
    ^ ^     b
Callout 2: last capture = 0
--->aab
    ^ ^     b
 0: aab

/(?:(?>(a))(?C1)bb|aa(?C2)b)/
    aab\=callout_capture
Callout 1: last capture = 1
 1: a
--->aab
    ^^      b
Callout 2: last capture = 0
--->aab
    ^ ^     b
 0: aab

/(?:(?1)(?C1)x|ab(?C2))((a)){0}/
    aab\=callout_capture
Callout 1: last capture = 0
--->aab
    ^^      x
Callout 1: last capture = 0
--->aab
     ^^     x
Callout 2: last capture = 0
--->aab
     ^ ^    )
 0: ab

/(?1)(?C1)((a)(?C2)){0}/
    aab\=callout_capture
Callout 2: last capture = 2
 1: <unset>
 2: a
--->aab
    ^^      ){0}
Callout 1: last capture = 0
--->aab
    ^^      (
 0: a

/(?:(a)+(?C1)bb|aa(?C2)b)++/
    aab\=callout_capture
Callout 1: last capture = 1
 1: a
--->aab
    ^ ^     b
Callout 1: last capture = 1
 1: a
--->aab
    ^^      b
Callout 2: last capture = 0
--->aab
    ^ ^     b
 0: aab
    aab\=callout_capture,ovector=1
Callout 1: last capture = 1
 1: a
--->aab
    ^ ^     b
Callout 1: last capture = 1
 1: a
--->aab
    ^^      b
Callout 2: last capture = 0
--->aab
    ^ ^     b
 0: aab

/(ab)x|ab/
    ab\=ovector=0
 0: ab
    ab\=ovector=1
 0: ab

/(?<=123)(*MARK:xx)abc/mark
    xxxx123a\=ph
Partial match, mark=xx: a
    xxxx123a\=ps
Partial match, mark=xx: a

/123\Kabc/startchar
    xxxx123a\=ph
Partial match: 123a
    xxxx123a\=ps
Partial match: 123a

/^(?(?=a)aa|bb)/auto_callout
    bb
--->bb
 +0 ^      ^
 +1 ^      (?
 +3 ^      (?=
 +6 ^      a
+11 ^      b
+12 ^^     b
+13 ^ ^    )
+14 ^ ^    End of pattern
 0: bb

/(?C1)^(?C2)(?(?C99)(?=(?C3)a(?C4))(?C5)a(?C6)a(?C7)|(?C8)b(?C9)b(?C10))(?C11)/
    bb
--->bb
  1 ^      ^
  2 ^      (?
 99 ^      (?=
  3 ^      a
  8 ^      b
  9 ^^     b
 10 ^ ^    )
 11 ^ ^    End of pattern
 0: bb

# Perl seems to have a bug with this one.

/aaaaa(*COMMIT)(*PRUNE)b|a+c/
    aaaaaac
 0: aaaac

# Here are some that Perl treats differently because of the way it handles
# backtracking verbs.

/(?!a(*COMMIT)b)ac|ad/
     ac
 0: ac
     ad
 0: ad

/^(?!a(*THEN)b|ac)../
     ad
 0: ad
\= Expect no match
     ac
No match

/^(?=a(*THEN)b|ac)/
    ac
 0: 

/\A.*?(?:a|b(*THEN)c)/
    ba
 0: ba

/\A.*?(?:a|b(*THEN)c)++/
    ba
 0: ba

/\A.*?(?:a|b(*THEN)c|d)/
    ba
 0: ba

/(?:(a(*MARK:X)a+(*SKIP:X)b)){0}(?:(?1)|aac)/
    aac
 0: aac

/\A.*?(a|b(*THEN)c)/
    ba
 0: ba
 1: a

/^(A(*THEN)B|A(*THEN)D)/
    AD
 0: AD
 1: AD

/(?!b(*THEN)a)bn|bnn/
    bnn
 0: bn

/(?(?=b(*SKIP)a)bn|bnn)/
    bnn
 0: bnn

/(?=b(*THEN)a|)bn|bnn/
    bnn
 0: bn

# This test causes a segfault with Perl 5.18.0

/^(?=(a)){0}b(?1)/
    backgammon
 0: ba

/(?|(?<n>f)|(?<n>b))/I,dupnames
Capture group count = 1
Named capture groups:
  n   1
Options: dupnames
Starting code units: b f 
Subject length lower bound = 1

/(?<a>abc)(?<a>z)\k<a>()/IB,dupnames
------------------------------------------------------------------
        Bra
        CBra 1
        abc
        Ket
        CBra 2
        z
        Ket
        \k<a>2
        CBra 3
        Ket
        Ket
        End
------------------------------------------------------------------
Capture group count = 3
Max back reference = 2
Named capture groups:
  a   1
  a   2
Options: dupnames
First code unit = 'a'
Last code unit = 'z'
Subject length lower bound = 5

/a*[bcd]/B
------------------------------------------------------------------
        Bra
        a*+
        [b-d]
        Ket
        End
------------------------------------------------------------------

/[bcd]*a/B
------------------------------------------------------------------
        Bra
        [b-d]*+
        a
        Ket
        End
------------------------------------------------------------------

# A complete set of tests for auto-possessification of character types, but
# omitting \C because it might be disabled (it has its own tests).

/\D+\D \D+\d \D+\S \D+\s \D+\W \D+\w \D+. \D+\R \D+\H \D+\h \D+\V \D+\v \D+\Z \D+\z \D+$/Bx
------------------------------------------------------------------
        Bra
        \D+
        \D
        \D++
        \d
        \D+
        \S
        \D+
        \s
        \D+
        \W
        \D+
        \w
        \D+
        Any
        \D+
        \R
        \D+
        \H
        \D+
        \h
        \D+
        \V
        \D+
        \v
        \D+
        \Z
        \D++
        \z
        \D+
        $
        Ket
        End
------------------------------------------------------------------

/\d+\D \d+\d \d+\S \d+\s \d+\W \d+\w \d+. \d+\R \d+\H \d+\h \d+\V \d+\v \d+\Z \d+\z \d+$/Bx
------------------------------------------------------------------
        Bra
        \d++
        \D
        \d+
        \d
        \d+
        \S
        \d++
        \s
        \d++
        \W
        \d+
        \w
        \d+
        Any
        \d++
        \R
        \d+
        \H
        \d++
        \h
        \d+
        \V
        \d++
        \v
        \d++
        \Z
        \d++
        \z
        \d++
        $
        Ket
        End
------------------------------------------------------------------

/\S+\D \S+\d \S+\S \S+\s \S+\W \S+\w \S+. \S+\R \S+\H \S+\h \S+\V \S+\v \S+\Z \S+\z \S+$/Bx
------------------------------------------------------------------
        Bra
        \S+
        \D
        \S+
        \d
        \S+
        \S
        \S++
        \s
        \S+
        \W
        \S+
        \w
        \S+
        Any
        \S++
        \R
        \S+
        \H
        \S++
        \h
        \S+
        \V
        \S++
        \v
        \S++
        \Z
        \S++
        \z
        \S++
        $
        Ket
        End
------------------------------------------------------------------

/\s+\D \s+\d \s+\S \s+\s \s+\W \s+\w \s+. \s+\R \s+\H \s+\h \s+\V \s+\v \s+\Z \s+\z \s+$/Bx
------------------------------------------------------------------
        Bra
        \s+
        \D
        \s++
        \d
        \s++
        \S
        \s+
        \s
        \s+
        \W
        \s++
        \w
        \s+
        Any
        \s+
        \R
        \s+
        \H
        \s+
        \h
        \s+
        \V
        \s+
        \v
        \s+
        \Z
        \s++
        \z
        \s+
        $
        Ket
        End
------------------------------------------------------------------

/\W+\D \W+\d \W+\S \W+\s \W+\W \W+\w \W+. \W+\R \W+\H \W+\h \W+\V \W+\v \W+\Z \W+\z \W+$/Bx
------------------------------------------------------------------
        Bra
        \W+
        \D
        \W++
        \d
        \W+
        \S
        \W+
        \s
        \W+
        \W
        \W++
        \w
        \W+
        Any
        \W+
        \R
        \W+
        \H
        \W+
        \h
        \W+
        \V
        \W+
        \v
        \W+
        \Z
        \W++
        \z
        \W+
        $
        Ket
        End
------------------------------------------------------------------

/\w+\D \w+\d \w+\S \w+\s \w+\W \w+\w \w+. \w+\R \w+\H \w+\h \w+\V \w+\v \w+\Z \w+\z \w+$/Bx
------------------------------------------------------------------
        Bra
        \w+
        \D
        \w+
        \d
        \w+
        \S
        \w++
        \s
        \w++
        \W
        \w+
        \w
        \w+
        Any
        \w++
        \R
        \w+
        \H
        \w++
        \h
        \w+
        \V
        \w++
        \v
        \w++
        \Z
        \w++
        \z
        \w++
        $
        Ket
        End
------------------------------------------------------------------

/\R+\D \R+\d \R+\S \R+\s \R+\W \R+\w \R+. \R+\R \R+\H \R+\h \R+\V \R+\v \R+\Z \R+\z \R+$/Bx
------------------------------------------------------------------
        Bra
        \R+
        \D
        \R++
        \d
        \R+
        \S
        \R++
        \s
        \R+
        \W
        \R++
        \w
        \R++
        Any
        \R+
        \R
        \R+
        \H
        \R++
        \h
        \R+
        \V
        \R+
        \v
        \R+
        \Z
        \R++
        \z
        \R+
        $
        Ket
        End
------------------------------------------------------------------

/\H+\D \H+\d \H+\S \H+\s \H+\W \H+\w \H+. \H+\R \H+\H \H+\h \H+\V \H+\v \H+\Z \H+\z \H+$/Bx
------------------------------------------------------------------
        Bra
        \H+
        \D
        \H+
        \d
        \H+
        \S
        \H+
        \s
        \H+
        \W
        \H+
        \w
        \H+
        Any
        \H+
        \R
        \H+
        \H
        \H++
        \h
        \H+
        \V
        \H+
        \v
        \H+
        \Z
        \H++
        \z
        \H+
        $
        Ket
        End
------------------------------------------------------------------

/\h+\D \h+\d \h+\S \h+\s \h+\W \h+\w \h+. \h+\R \h+\H \h+\h \h+\V \h+\v \h+\Z \h+\z \h+$/Bx
------------------------------------------------------------------
        Bra
        \h+
        \D
        \h++
        \d
        \h++
        \S
        \h+
        \s
        \h+
        \W
        \h++
        \w
        \h+
        Any
        \h++
        \R
        \h++
        \H
        \h+
        \h
        \h+
        \V
        \h++
        \v
        \h+
        \Z
        \h++
        \z
        \h+
        $
        Ket
        End
------------------------------------------------------------------

/\V+\D \V+\d \V+\S \V+\s \V+\W \V+\w \V+. \V+\R \V+\H \V+\h \V+\V \V+\v \V+\Z \V+\z \V+$/Bx
------------------------------------------------------------------
        Bra
        \V+
        \D
        \V+
        \d
        \V+
        \S
        \V+
        \s
        \V+
        \W
        \V+
        \w
        \V+
        Any
        \V++
        \R
        \V+
        \H
        \V+
        \h
        \V+
        \V
        \V++
        \v
        \V+
        \Z
        \V++
        \z
        \V+
        $
        Ket
        End
------------------------------------------------------------------

/\v+\D \v+\d \v+\S \v+\s \v+\W \v+\w \v+. \v+\R \v+\H \v+\h \v+\V \v+\v \v+\Z \v+\z \v+$/Bx
------------------------------------------------------------------
        Bra
        \v+
        \D
        \v++
        \d
        \v++
        \S
        \v+
        \s
        \v+
        \W
        \v++
        \w
        \v+
        Any
        \v+
        \R
        \v+
        \H
        \v++
        \h
        \v++
        \V
        \v+
        \v
        \v+
        \Z
        \v++
        \z
        \v+
        $
        Ket
        End
------------------------------------------------------------------

/ a+\D  a+\d  a+\S  a+\s  a+\W  a+\w  a+.  a+\R  a+\H  a+\h  a+\V  a+\v  a+\Z  a+\z  a+$/Bx
------------------------------------------------------------------
        Bra
        a+
        \D
        a++
        \d
        a+
        \S
        a++
        \s
        a++
        \W
        a+
        \w
        a+
        Any
        a++
        \R
        a+
        \H
        a++
        \h
        a+
        \V
        a++
        \v
        a++
        \Z
        a++
        \z
        a++
        $
        Ket
        End
------------------------------------------------------------------

/\n+\D \n+\d \n+\S \n+\s \n+\W \n+\w \n+. \n+\R \n+\H \n+\h \n+\V \n+\v \n+\Z \n+\z \n+$/Bx
------------------------------------------------------------------
        Bra
        \x0a+
        \D
        \x0a++
        \d
        \x0a++
        \S
        \x0a+
        \s
        \x0a+
        \W
        \x0a++
        \w
        \x0a+
        Any
        \x0a+
        \R
        \x0a+
        \H
        \x0a++
        \h
        \x0a++
        \V
        \x0a+
        \v
        \x0a+
        \Z
        \x0a++
        \z
        \x0a+
        $
        Ket
        End
------------------------------------------------------------------

/ .+\D  .+\d  .+\S  .+\s  .+\W  .+\w  .+.  .+\R  .+\H  .+\h  .+\V  .+\v  .+\Z  .+\z  .+$/Bx
------------------------------------------------------------------
        Bra
        Any+
        \D
        Any+
        \d
        Any+
        \S
        Any+
        \s
        Any+
        \W
        Any+
        \w
        Any+
        Any
        Any++
        \R
        Any+
        \H
        Any+
        \h
        Any+
        \V
        Any+
        \v
        Any+
        \Z
        Any++
        \z
        Any+
        $
        Ket
        End
------------------------------------------------------------------

/ .+\D  .+\d  .+\S  .+\s  .+\W  .+\w  .+.  .+\R  .+\H  .+\h  .+\V  .+\v  .+\Z  .+\z  .+$/Bsx
------------------------------------------------------------------
        Bra
        AllAny+
        \D
        AllAny+
        \d
        AllAny+
        \S
        AllAny+
        \s
        AllAny+
        \W
        AllAny+
        \w
        AllAny+
        AllAny
        AllAny+
        \R
        AllAny+
        \H
        AllAny+
        \h
        AllAny+
        \V
        AllAny+
        \v
        AllAny+
        \Z
        AllAny++
        \z
        AllAny+
        $
        Ket
        End
------------------------------------------------------------------

/ \D+$  \d+$  \S+$  \s+$  \W+$  \w+$  \R+$  \H+$  \h+$  \V+$ \v+$  a+$   \n+$  .+$  .+$/Bmx
------------------------------------------------------------------
        Bra
        \D+
     /m $
        \d++
     /m $
        \S++
     /m $
        \s+
     /m $
        \W+
     /m $
        \w++
     /m $
        \R+
     /m $
        \H+
     /m $
        \h+
     /m $
        \V+
     /m $
        \v+
     /m $
        a+
     /m $
        \x0a+
     /m $
        Any+
     /m $
        Any+
     /m $
        Ket
        End
------------------------------------------------------------------

/(?=a+)a(a+)++a/B
------------------------------------------------------------------
        Bra
        Assert
        a++
        Ket
        a
        CBraPos 1
        a+
        KetRpos
        a
        Ket
        End
------------------------------------------------------------------

/a+(bb|cc)a+(?:bb|cc)a+(?>bb|cc)a+(?:bb|cc)+a+(aa)a+(?:bb|aa)/B
------------------------------------------------------------------
        Bra
        a++
        CBra 1
        bb
        Alt
        cc
        Ket
        a++
        Bra
        bb
        Alt
        cc
        Ket
        a++
        Once
        bb
        Alt
        cc
        Ket
        a++
        Bra
        bb
        Alt
        cc
        KetRmax
        a+
        CBra 2
        aa
        Ket
        a+
        Bra
        bb
        Alt
        aa
        Ket
        Ket
        End
------------------------------------------------------------------

/a+(bb|cc)?#a+(?:bb|cc)??#a+(?:bb|cc)?+#a+(?:bb|cc)*#a+(bb|cc)?a#a+(?:aa)?/B
------------------------------------------------------------------
        Bra
        a++
        Brazero
        CBra 1
        bb
        Alt
        cc
        Ket
        #
        a++
        Braminzero
        Bra
        bb
        Alt
        cc
        Ket
        #
        a++
        Once
        Brazero
        Bra
        bb
        Alt
        cc
        Ket
        Ket
        #
        a++
        Brazero
        Bra
        bb
        Alt
        cc
        KetRmax
        #
        a+
        Brazero
        CBra 2
        bb
        Alt
        cc
        Ket
        a#
        a+
        Brazero
        Bra
        aa
        Ket
        Ket
        End
------------------------------------------------------------------

/a+(?:bb)?a#a+(?:|||)#a+(?:|b)a#a+(?:|||)?a/B
------------------------------------------------------------------
        Bra
        a+
        Brazero
        Bra
        bb
        Ket
        a#
        a++
        Bra
        Alt
        Alt
        Alt
        Ket
        #
        a+
        Bra
        Alt
        b
        Ket
        a#
        a+
        Brazero
        Bra
        Alt
        Alt
        Alt
        Ket
        a
        Ket
        End
------------------------------------------------------------------

/[ab]*/B
------------------------------------------------------------------
        Bra
        [ab]*+
        Ket
        End
------------------------------------------------------------------
    aaaa
 0: aaaa

/[ab]*?/B
------------------------------------------------------------------
        Bra
        [ab]*?
        Ket
        End
------------------------------------------------------------------
    aaaa
 0: 

/[ab]?/B
------------------------------------------------------------------
        Bra
        [ab]?+
        Ket
        End
------------------------------------------------------------------
    aaaa
 0: a

/[ab]??/B
------------------------------------------------------------------
        Bra
        [ab]??
        Ket
        End
------------------------------------------------------------------
    aaaa
 0: 

/[ab]+/B
------------------------------------------------------------------
        Bra
        [ab]++
        Ket
        End
------------------------------------------------------------------
    aaaa
 0: aaaa

/[ab]+?/B
------------------------------------------------------------------
        Bra
        [ab]+?
        Ket
        End
------------------------------------------------------------------
    aaaa
 0: a

/[ab]{2,3}/B
------------------------------------------------------------------
        Bra
        [ab]{2,3}+
        Ket
        End
------------------------------------------------------------------
    aaaa
 0: aaa

/[ab]{2,3}?/B
------------------------------------------------------------------
        Bra
        [ab]{2,3}?
        Ket
        End
------------------------------------------------------------------
    aaaa
 0: aa

/[ab]{2,}/B
------------------------------------------------------------------
        Bra
        [ab]{2,}+
        Ket
        End
------------------------------------------------------------------
    aaaa
 0: aaaa

/[ab]{2,}?/B
------------------------------------------------------------------
        Bra
        [ab]{2,}?
        Ket
        End
------------------------------------------------------------------
    aaaa
 0: aa

/\d+\s{0,5}=\s*\S?=\w{0,4}\W*/B
------------------------------------------------------------------
        Bra
        \d++
        \s{0,5}+
        =
        \s*+
        \S?
        =
        \w{0,4}+
        \W*+
        Ket
        End
------------------------------------------------------------------

/[a-d]{5,12}[e-z0-9]*#[^a-z]+[b-y]*a[2-7]?[^0-9a-z]+/B
------------------------------------------------------------------
        Bra
        [a-d]{5,12}+
        [0-9e-z]*+
        #
        [\x00-`{-\xff] (neg)++
        [b-y]*+
        a
        [2-7]?+
        [\x00-/:-`{-\xff] (neg)++
        Ket
        End
------------------------------------------------------------------

/[a-z]*\s#[ \t]?\S#[a-c]*\S#[C-G]+?\d#[4-8]*\D#[4-9,]*\D#[!$]{0,5}\w#[M-Xf-l]+\W#[a-c,]?\W/B
------------------------------------------------------------------
        Bra
        [a-z]*+
        \s
        #
        [\x09 ]?+
        \S
        #
        [a-c]*
        \S
        #
        [C-G]++
        \d
        #
        [4-8]*+
        \D
        #
        [,4-9]*
        \D
        #
        [!$]{0,5}+
        \w
        #
        [M-Xf-l]++
        \W
        #
        [,a-c]?
        \W
        Ket
        End
------------------------------------------------------------------

/a+(aa|bb)*c#a*(bb|cc)*a#a?(bb|cc)*d#[a-f]*(g|hh)*f/B
------------------------------------------------------------------
        Bra
        a+
        Brazero
        CBra 1
        aa
        Alt
        bb
        KetRmax
        c#
        a*
        Brazero
        CBra 2
        bb
        Alt
        cc
        KetRmax
        a#
        a?+
        Brazero
        CBra 3
        bb
        Alt
        cc
        KetRmax
        d#
        [a-f]*
        Brazero
        CBra 4
        g
        Alt
        hh
        KetRmax
        f
        Ket
        End
------------------------------------------------------------------

/[a-f]*(g|hh|i)*i#[a-x]{4,}(y{0,6})*y#[a-k]+(ll|mm)+n/B
------------------------------------------------------------------
        Bra
        [a-f]*+
        Brazero
        CBra 1
        g
        Alt
        hh
        Alt
        i
        KetRmax
        i#
        [a-x]{4,}
        Brazero
        SCBra 2
        y{0,6}
        KetRmax
        y#
        [a-k]++
        CBra 3
        ll
        Alt
        mm
        KetRmax
        n
        Ket
        End
------------------------------------------------------------------

/[a-f]*(?>gg|hh)+#[a-f]*(?>gg|hh)?#[a-f]*(?>gg|hh)*a#[a-f]*(?>gg|hh)*h/B
------------------------------------------------------------------
        Bra
        [a-f]*+
        Once
        gg
        Alt
        hh
        KetRmax
        #
        [a-f]*+
        Brazero
        Once
        gg
        Alt
        hh
        Ket
        #
        [a-f]*
        Brazero
        Once
        gg
        Alt
        hh
        KetRmax
        a#
        [a-f]*+
        Brazero
        Once
        gg
        Alt
        hh
        KetRmax
        h
        Ket
        End
------------------------------------------------------------------

/[a-c]*d/IB
------------------------------------------------------------------
        Bra
        [a-c]*+
        d
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Starting code units: a b c d 
Last code unit = 'd'
Subject length lower bound = 1

/[a-c]+d/IB
------------------------------------------------------------------
        Bra
        [a-c]++
        d
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Starting code units: a b c 
Last code unit = 'd'
Subject length lower bound = 2

/[a-c]?d/IB
------------------------------------------------------------------
        Bra
        [a-c]?+
        d
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Starting code units: a b c d 
Last code unit = 'd'
Subject length lower bound = 1

/[a-c]{4,6}d/IB
------------------------------------------------------------------
        Bra
        [a-c]{4,6}+
        d
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Starting code units: a b c 
Last code unit = 'd'
Subject length lower bound = 5

/[a-c]{0,6}d/IB
------------------------------------------------------------------
        Bra
        [a-c]{0,6}+
        d
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Starting code units: a b c d 
Last code unit = 'd'
Subject length lower bound = 1

# End of special auto-possessive tests

/^A\o{1239}B/
Failed: error 164 at offset 8: non-octal character in \o{} (closing brace missing?)
    A\123B

/^A\oB/
Failed: error 155 at offset 4: missing opening brace after \o

/^A\x{zz}B/
Failed: error 167 at offset 5: non-hex character in \x{} (closing brace missing?)

/^A\x{12Z/
Failed: error 167 at offset 7: non-hex character in \x{} (closing brace missing?)

/^A\x{/
Failed: error 178 at offset 5: digits missing in \x{} or \o{} or \N{U+}

/[ab]++/B,no_auto_possess
------------------------------------------------------------------
        Bra
        [ab]++
        Ket
        End
------------------------------------------------------------------

/[^ab]*+/B,no_auto_possess
------------------------------------------------------------------
        Bra
        [\x00-`c-\xff] (neg)*+
        Ket
        End
------------------------------------------------------------------

/a{4}+/B,no_auto_possess
------------------------------------------------------------------
        Bra
        a{4}
        Ket
        End
------------------------------------------------------------------

/a{4}+/Bi,no_auto_possess
------------------------------------------------------------------
        Bra
     /i a{4}
        Ket
        End
------------------------------------------------------------------

/[a-[:digit:]]+/
Failed: error 150 at offset 4: invalid range in character class

/[A-[:digit:]]+/
Failed: error 150 at offset 4: invalid range in character class

/[a-[.xxx.]]+/
Failed: error 150 at offset 4: invalid range in character class

/[a-[=xxx=]]+/
Failed: error 150 at offset 4: invalid range in character class

/[a-[!xxx!]]+/
Failed: error 108 at offset 3: range out of order in character class

/[A-[!xxx!]]+/
    A]]]
 0: A]]]

/[a-\d]+/
Failed: error 150 at offset 5: invalid range in character class

/(?<0abc>xx)/
Failed: error 144 at offset 3: subpattern name must start with a non-digit

/(?&1abc)xx(?<1abc>y)/
Failed: error 144 at offset 3: subpattern name must start with a non-digit

/(?<ab-cd>xx)/
Failed: error 142 at offset 5: syntax error in subpattern name (missing terminator?)

/(?'0abc'xx)/
Failed: error 144 at offset 3: subpattern name must start with a non-digit

/(?P<0abc>xx)/
Failed: error 144 at offset 4: subpattern name must start with a non-digit

/\k<5ghj>/
Failed: error 144 at offset 3: subpattern name must start with a non-digit

/\k'5ghj'/
Failed: error 144 at offset 3: subpattern name must start with a non-digit

/\k{2fgh}/
Failed: error 144 at offset 3: subpattern name must start with a non-digit

/(?P=8yuki)/
Failed: error 144 at offset 4: subpattern name must start with a non-digit

/\g{4df}/
Failed: error 157 at offset 2: \g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number

/(?&1abc)xx(?<1abc>y)/
Failed: error 144 at offset 3: subpattern name must start with a non-digit

/(?P>1abc)xx(?<1abc>y)/
Failed: error 144 at offset 4: subpattern name must start with a non-digit

/\g'3gh'/
Failed: error 157 at offset 2: \g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number

/\g<5fg>/
Failed: error 157 at offset 2: \g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number

/(?(<4gh>)abc)/
Failed: error 144 at offset 4: subpattern name must start with a non-digit

/(?('4gh')abc)/
Failed: error 144 at offset 4: subpattern name must start with a non-digit

/(?(4gh)abc)/
Failed: error 124 at offset 4: missing closing parenthesis for condition

/(?(R&6yh)abc)/
Failed: error 144 at offset 5: subpattern name must start with a non-digit

/(((a\2)|(a*)\g<-1>))*a?/B
------------------------------------------------------------------
        Bra
        Brazero
        SCBra 1
        CBra 2
        CBra 3
        a
        \2
        Ket
        Alt
        CBra 4
        a*
        Ket
        Recurse
        Ket
        KetRmax
        a?+
        Ket
        End
------------------------------------------------------------------

# Test the ugly "start or end of word" compatibility syntax.

/[[:<:]]red[[:>:]]/B
------------------------------------------------------------------
        Bra
        \b
        Assert
        \w
        Ket
        red
        \b
        Assert back
        Reverse
        \w
        Ket
        Ket
        End
------------------------------------------------------------------
    little red riding hood
 0: red
    a /red/ thing
 0: red
    red is a colour
 0: red
    put it all on red
 0: red
\= Expect no match
    no reduction
No match
    Alfred Winifred
No match

/[a[:<:]] should give error/
Failed: error 130 at offset 4: unknown POSIX class name

/(?=ab\K)/aftertext
    abcd\=startchar
Start of matched string is beyond its end - displaying from end to start.
 0: ab
 0+ abcd

/abcd/newline=lf,firstline
\= Expect no match
    xx\nxabcd
No match

# Test stack guard external calls.

/(((a)))/stackguard=1
Failed: error 133 at offset 7: parentheses are too deeply nested (stack check)

/(((a)))/stackguard=2
Failed: error 133 at offset 7: parentheses are too deeply nested (stack check)

/(((a)))/stackguard=3

/(((((a)))))/

# End stack guard tests

/^\w+(?>\s*)(?<=\w)/B
------------------------------------------------------------------
        Bra
        ^
        \w+
        Once
        \s*+
        Ket
        Assert back
        Reverse
        \w
        Ket
        Ket
        End
------------------------------------------------------------------

/\othing/
Failed: error 155 at offset 2: missing opening brace after \o

/\o{}/
Failed: error 178 at offset 3: digits missing in \x{} or \o{} or \N{U+}

/\o{whatever}/
Failed: error 164 at offset 3: non-octal character in \o{} (closing brace missing?)

/\xthing/

/\x{}/
Failed: error 178 at offset 3: digits missing in \x{} or \o{} or \N{U+}

/\x{whatever}/
Failed: error 167 at offset 3: non-hex character in \x{} (closing brace missing?)

/A\8B/
Failed: error 115 at offset 2: reference to non-existent subpattern

/A\9B/
Failed: error 115 at offset 2: reference to non-existent subpattern

# This one is here because Perl fails to match "12" for this pattern when the $
# is present.

/^(?(?=abc)\w{3}:|\d\d)$/
    abc:
 0: abc:
    12
 0: 12
\= Expect no match
    123
No match
    xyz
No match

# Perl gets this one wrong, giving "a" as the after text for ca and failing to
# match for cd.

/(?(?=ab)ab)/aftertext
    abxxx
 0: ab
 0+ xxx
    ca
 0: 
 0+ ca
    cd
 0: 
 0+ cd

# This should test both paths for processing OP_RECURSE.

/(?(R)a+|(?R)b)/
    aaaabcde
 0: aaaab
    aaaabcde\=ovector=100
 0: aaaab

/a*?b*?/
    ab
 0: 

/(*NOTEMPTY)a*?b*?/
    ab
 0: a
    ba
 0: b
    cb
 0: b

/(*NOTEMPTY_ATSTART)a*?b*?/aftertext
    ab
 0: a
 0+ b
    cdab
 0: 
 0+ dab

/(?(VERSION>=10.0)yes|no)/I
Capture group count = 0
Subject length lower bound = 2
    yesno
 0: yes

/(?(VERSION>=10.04)yes|no)/
    yesno
 0: yes

/(?(VERSION=8)yes){3}/BI,aftertext
------------------------------------------------------------------
        Bra
        Cond
        Cond false
        yes
        Ket
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
May match empty string
Subject length lower bound = 0
    yesno
 0: 
 0+ yesno

/(?(VERSION=8)yes|no){3}/I
Capture group count = 0
Subject length lower bound = 6
    yesnononoyes
 0: nonono
\= Expect no match
    yesno
No match

/(?:(?<VERSION>abc)|xyz)(?(VERSION)yes|no)/I
Capture group count = 1
Max back reference = 1
Named capture groups:
  VERSION   1
Starting code units: a x 
Subject length lower bound = 5
    abcyes
 0: abcyes
 1: abc
    xyzno
 0: xyzno
\= Expect no match
    abcno
No match
    xyzyes
No match

/(?(VERSION<10)yes|no)/
Failed: error 179 at offset 10: syntax error or number too big in (?(VERSION condition

/(?(VERSION>10)yes|no)/
Failed: error 179 at offset 11: syntax error or number too big in (?(VERSION condition

/(?(VERSION>=10.0.0)yes|no)/
Failed: error 179 at offset 16: syntax error or number too big in (?(VERSION condition

/(?(VERSION=10.101)yes|no)/
Failed: error 179 at offset 16: syntax error or number too big in (?(VERSION condition

/abcd/I
Capture group count = 0
First code unit = 'a'
Last code unit = 'd'
Subject length lower bound = 4

/abcd/I,no_start_optimize
Capture group count = 0
Options: no_start_optimize

/(|ab)*?d/I
Capture group count = 1
Starting code units: a d 
Last code unit = 'd'
Subject length lower bound = 1
   abd
 0: abd
 1: ab
   xyd
 0: d

/(|ab)*?d/I,no_start_optimize
Capture group count = 1
Options: no_start_optimize
   abd
 0: abd
 1: ab
   xyd
 0: d

/\k<A>*(?<A>aa)(?<A>bb)/match_unset_backref,dupnames
    aabb
 0: aabb
 1: aa
 2: bb

/(((((a)))))/parens_nest_limit=2
Failed: error 119 at offset 3: parentheses are too deeply nested

/abc/replace=XYZ
    123123
 0: 123123
    123abc123
 1: 123XYZ123
    123abc123abc123
 1: 123XYZ123abc123
    123123\=zero_terminate
 0: 123123
    123abc123\=zero_terminate
 1: 123XYZ123
    123abc123abc123\=zero_terminate
 1: 123XYZ123abc123

/abc/g,replace=XYZ
    123abc123
 1: 123XYZ123
    123abc123abc123
 2: 123XYZ123XYZ123

/abc/replace=X$$Z
    123abc123
 1: 123X$Z123

/abc/g,replace=X$$Z
    123abc123abc123
 2: 123X$Z123X$Z123

/a(b)c(d)e/replace=X$1Y${2}Z
    "abcde"
 1: "XbYdZ"

/a(b)c(d)e/replace=X$1Y${2}Z,global
    "abcde-abcde"
 2: "XbYdZ-XbYdZ"

/a(?<ONE>b)c(?<TWO>d)e/replace=X$ONE+${TWO}Z
    "abcde"
 1: "Xb+dZ"

/a(?<ONE>b)c(?<TWO>d)e/g,replace=X$ONE+${TWO}Z
    "abcde-abcde-"
 2: "Xb+dZ-Xb+dZ-"

/abc/replace=a$++
    123abc
Failed: error -35 at offset 2 in replacement: invalid replacement string

/abc/replace=a$bad
    123abc
Failed: error -49 at offset 5 in replacement: unknown substring

/abc/replace=a${A234567890123456789_123456789012}z
    123abc
Failed: error -49 at offset 36 in replacement: unknown substring

/abc/replace=a${A23456789012345678901234567890123}z
    123abc
Failed: error -35 at offset 35 in replacement: invalid replacement string

/abc/replace=a${bcd
    123abc
Failed: error -58 at offset 6 in replacement: expected closing curly bracket in replacement string

/abc/replace=a${b+d}z
    123abc
Failed: error -58 at offset 4 in replacement: expected closing curly bracket in replacement string

/abc/replace=[10]XYZ
    123abc123
 1: 123XYZ123

/abc/replace=[9]XYZ
    123abc123
Failed: error -48: no more memory

/abc/replace=xyz
    1abc2\=partial_hard
Failed: error -34: bad option value

/abc/replace=xyz
    123abc456
 1: 123xyz456
    123abc456\=replace=pqr
 1: 123pqr456
    123abc456abc789
 1: 123xyz456abc789
    123abc456abc789\=g
 2: 123xyz456xyz789

/(?<=abc)(|def)/g,replace=<$0>
    123abcxyzabcdef789abcpqr
 4: 123abc<>xyzabc<><def>789abc<>pqr

/./replace=$0
    a
 1: a

/(.)(.)/replace=$2+$1
    abc
 1: b+ac

/(?<A>.)(?<B>.)/replace=$B+$A
    abc
 1: b+ac

/(.)(.)/g,replace=$2$1
    abcdefgh
 4: badcfehg

/(*:pear)apple|(*:orange)lemon|(*:strawberry)blackberry/g,replace=${*MARK}
    apple lemon blackberry
 3: pear orange strawberry
    apple strudel
 1: pear strudel
    fruitless
 0: fruitless

/(*:pear)apple|(*:orange)lemon|(*:strawberry)blackberry/replace=${*MARK} sauce,
    apple lemon blackberry
 1: pear sauce lemon blackberry

/(*:pear)apple|(*:orange)lemon|(*:strawberry)blackberry/g,replace=<$*MARK>
    apple lemon blackberry
 3: <pear> <orange> <strawberry>
    apple strudel
 1: <pear> strudel
    fruitless
 0: fruitless

/(*:pear)apple/g,replace=${*MARKING}
    apple lemon blackberry
Failed: error -35 at offset 11 in replacement: invalid replacement string

/(*:pear)apple/g,replace=${*MARK-time
    apple lemon blackberry
Failed: error -58 at offset 7 in replacement: expected closing curly bracket in replacement string

/(*:pear)apple/g,replace=${*mark}
    apple lemon blackberry
Failed: error -35 at offset 8 in replacement: invalid replacement string

/(*:pear)apple|(*:orange)lemon|(*:strawberry)blackberry/g,replace=<$*MARKET>
    apple lemon blackberry
Failed: error -35 at offset 9 in replacement: invalid replacement string

/(*:pear)apple|(*:orange)lemon|(*:strawberry)blackberry/g,replace=[22]${*MARK}
    apple lemon blackberry
Failed: error -48: no more memory
    apple lemon blackberry\=substitute_overflow_length
Failed: error -48: no more memory: 23 code units are needed

/(*:pear)apple|(*:orange)lemon|(*:strawberry)blackberry/g,replace=[23]${*MARK}
    apple lemon blackberry
 3: pear orange strawberry

/abc/
    123abc123\=replace=[9]XYZ
Failed: error -48: no more memory
    123abc123\=substitute_overflow_length,replace=[9]XYZ
Failed: error -48: no more memory: 10 code units are needed
    123abc123\=substitute_overflow_length,replace=[6]XYZ
Failed: error -48: no more memory: 10 code units are needed
    123abc123\=substitute_overflow_length,replace=[1]XYZ
Failed: error -48: no more memory: 10 code units are needed
    123abc123\=substitute_overflow_length,replace=[0]XYZ
Failed: error -48: no more memory: 10 code units are needed

/a(b)c/
    123abc123\=replace=[9]x$1z
Failed: error -48: no more memory
    123abc123\=substitute_overflow_length,replace=[9]x$1z
Failed: error -48: no more memory: 10 code units are needed
    123abc123\=substitute_overflow_length,replace=[6]x$1z
Failed: error -48: no more memory: 10 code units are needed
    123abc123\=substitute_overflow_length,replace=[1]x$1z
Failed: error -48: no more memory: 10 code units are needed
    123abc123\=substitute_overflow_length,replace=[0]x$1z
Failed: error -48: no more memory: 10 code units are needed

"((?=(?(?=(?(?=(?(?=()))))))))"
    a
 0: 
 1: 
 2: 

"(?(?=)==)(((((((((?=)))))))))"
\= Expect no match
    a
No match

/(a)(b)|(c)/
    XcX\=ovector=2,get=1,get=2,get=3,get=4,getall
Matched, but too many substrings
 0: c
 1: <unset>
Get substring 1 failed (-55): requested value is not set
Get substring 2 failed (-54): requested value is not available
Get substring 3 failed (-54): requested value is not available
Get substring 4 failed (-49): unknown substring
 0L c
 1L 

/x(?=ab\K)/
    xab\=get=0
Start of matched string is beyond its end - displaying from end to start.
 0: ab
 0G  (0)
    xab\=copy=0
Start of matched string is beyond its end - displaying from end to start.
 0: ab
 0C  (0)
    xab\=getall
Start of matched string is beyond its end - displaying from end to start.
 0: ab
 0L 

/(?<A>a)|(?<A>b)/dupnames
    a\=ovector=1,copy=A,get=A,get=2
Matched, but too many substrings
 0: a
Copy substring 'A' failed (-54): requested value is not available
Get substring 2 failed (-54): requested value is not available
Get substring 'A' failed (-54): requested value is not available
    a\=ovector=2,copy=A,get=A,get=2
 0: a
 1: a
  C a (1) A (non-unique)
Get substring 2 failed (-54): requested value is not available
  G a (1) A (non-unique)
    b\=ovector=2,copy=A,get=A,get=2
Matched, but too many substrings
 0: b
 1: <unset>
Copy substring 'A' failed (-55): requested value is not set
Get substring 2 failed (-54): requested value is not available
Get substring 'A' failed (-55): requested value is not set

/a(b)c(d)/
    abc\=ph,copy=0,copy=1,getall
Partial match: abc
 0C abc (3)
Copy substring 1 failed (-2): partial match
get substring list failed (-2): partial match

/^abc/info
Capture group count = 0
Compile options: <none>
Overall options: anchored
First code unit = 'a'
Subject length lower bound = 3

/^abc/info,no_dotstar_anchor
Capture group count = 0
Compile options: no_dotstar_anchor
Overall options: anchored no_dotstar_anchor
First code unit = 'a'
Subject length lower bound = 3

/.*\d/info,auto_callout
Capture group count = 0
Options: auto_callout
First code unit at start or follows newline
Subject length lower bound = 1
\= Expect no match
    aaa
--->aaa
 +0 ^       .*
 +2 ^  ^    \d
 +2 ^ ^     \d
 +2 ^^      \d
 +2 ^       \d
No match

/.*\d/info,no_dotstar_anchor,auto_callout
Capture group count = 0
Options: auto_callout no_dotstar_anchor
Subject length lower bound = 1
\= Expect no match
    aaa
--->aaa
 +0 ^       .*
 +2 ^  ^    \d
 +2 ^ ^     \d
 +2 ^^      \d
 +2 ^       \d
 +0  ^      .*
 +2  ^ ^    \d
 +2  ^^     \d
 +2  ^      \d
 +0   ^     .*
 +2   ^^    \d
 +2   ^     \d
No match

/.*\d/dotall,info
Capture group count = 0
Compile options: dotall
Overall options: anchored dotall
Subject length lower bound = 1

/.*\d/dotall,no_dotstar_anchor,info
Capture group count = 0
Options: dotall no_dotstar_anchor
Subject length lower bound = 1

/(*NO_DOTSTAR_ANCHOR)(?s).*\d/info
Capture group count = 0
Compile options: <none>
Overall options: no_dotstar_anchor
Subject length lower bound = 1

'^(?:(a)|b)(?(1)A|B)'
    aA123\=ovector=1
Matched, but too many substrings
 0: aA
    aA123\=ovector=2
 0: aA
 1: a

'^(?:(?<AA>a)|b)(?(<AA>)A|B)'
    aA123\=ovector=1
Matched, but too many substrings
 0: aA
    aA123\=ovector=2
 0: aA
 1: a

'^(?<AA>)(?:(?<AA>a)|b)(?(<AA>)A|B)'dupnames
    aA123\=ovector=1
Matched, but too many substrings
 0: aA
    aA123\=ovector=2
Matched, but too many substrings
 0: aA
 1: 
    aA123\=ovector=3
 0: aA
 1: 
 2: a

'^(?:(?<AA>X)|)(?:(?<AA>a)|b)\k{AA}'dupnames
    aa123\=ovector=1
Matched, but too many substrings
 0: aa
    aa123\=ovector=2
Matched, but too many substrings
 0: aa
 1: <unset>
    aa123\=ovector=3
 0: aa
 1: <unset>
 2: a

/(?<N111>(?J)(?<N111>1(111111)11|)1|1|)(?(<N111>)1)/

/(?<N>(?J)(?<N>))(?-J)\k<N>/

# Quantifiers are not allowed on condition assertions, but are otherwise
# OK in conditions.

/(?(?=0)?)+/
Failed: error 109 at offset 7: quantifier does not follow a repeatable item

/(?(?=0)(?=00)?00765)/
     00765
 0: 00765

/(?(?=0)(?=00)?00765|(?!3).56)/
     00765
 0: 00765
     456
 0: 456
\= Expect no match
     356
No match

'^(a)*+(\w)'
    g
 0: g
 1: <unset>
 2: g
    g\=ovector=1
Matched, but too many substrings
 0: g

'^(?:a)*+(\w)'
    g
 0: g
 1: g
    g\=ovector=1
Matched, but too many substrings
 0: g

# These two pattern showeds up compile-time bugs

"((?2){0,1999}())?"

/((?+1)(\1))/B
------------------------------------------------------------------
        Bra
        CBra 1
        Recurse
        CBra 2
        \1
        Ket
        Ket
        Ket
        End
------------------------------------------------------------------

# Callouts with string arguments

/a(?C"/
Failed: error 181 at offset 4: missing terminating delimiter for callout with string argument

/a(?C"a/
Failed: error 181 at offset 4: missing terminating delimiter for callout with string argument

/a(?C"a"/
Failed: error 139 at offset 7: closing parenthesis for (?C expected

/a(?C"a"bcde(?C"b")xyz/
Failed: error 139 at offset 7: closing parenthesis for (?C expected

/a(?C"a)b""c")/B
------------------------------------------------------------------
        Bra
        a
        CalloutStr "a)b"c" 5 13 0
        Ket
        End
------------------------------------------------------------------

/ab(?C" any text with spaces ")cde/B
------------------------------------------------------------------
        Bra
        ab
        CalloutStr " any text with spaces " 6 30 1
        cde
        Ket
        End
------------------------------------------------------------------
    abcde
Callout (6): " any text with spaces "
--->abcde
    ^ ^       c
 0: abcde
    12abcde
Callout (6): " any text with spaces "
--->12abcde
      ^ ^       c
 0: abcde

/^a(b)c(?C1)def/
      abcdef
--->abcdef
  1 ^  ^       d
 0: abcdef
 1: b

/^a(b)c(?C"AB")def/
      abcdef
Callout (10): "AB"
--->abcdef
    ^  ^       d
 0: abcdef
 1: b

/^a(b)c(?C1)def/
      abcdef\=callout_capture
Callout 1: last capture = 1
 1: b
--->abcdef
    ^  ^       d
 0: abcdef
 1: b

/^a(b)c(?C{AB})def/B
------------------------------------------------------------------
        Bra
        ^
        a
        CBra 1
        b
        Ket
        c
        CalloutStr {AB} 10 14 1
        def
        Ket
        End
------------------------------------------------------------------
      abcdef\=callout_capture
Callout (10): {AB} last capture = 1
 1: b
--->abcdef
    ^  ^       d
 0: abcdef
 1: b

/(?C`a``b`)(?C'a''b')(?C"a""b")(?C^a^^b^)(?C%a%%b%)(?C#a##b#)(?C$a$$b$)(?C{a}}b})/B,callout_info
------------------------------------------------------------------
        Bra
        CalloutStr `a`b` 4 10 0
        CalloutStr 'a'b' 14 20 0
        CalloutStr "a"b" 24 30 0
        CalloutStr ^a^b^ 34 40 0
        CalloutStr %a%b% 44 50 0
        CalloutStr #a#b# 54 60 0
        CalloutStr $a$b$ 64 70 0
        CalloutStr {a}b} 74 80 0
        Ket
        End
------------------------------------------------------------------
Callout `a`b`  (
Callout 'a'b'  (
Callout "a"b"  (
Callout ^a^b^  (
Callout %a%b%  (
Callout #a#b#  (
Callout $a$b$  (
Callout {a}b}  

/(?:a(?C`code`)){3}/B
------------------------------------------------------------------
        Bra
        Bra
        a
        CalloutStr `code` 8 14 4
        Ket
        Bra
        a
        CalloutStr `code` 8 14 4
        Ket
        Bra
        a
        CalloutStr `code` 8 14 4
        Ket
        Ket
        End
------------------------------------------------------------------

/^(?(?C25)(?=abc)abcd|xyz)/B,callout_info
------------------------------------------------------------------
        Bra
        ^
        Cond
        Callout 25 9 3
        Assert
        abc
        Ket
        abcd
        Alt
        xyz
        Ket
        Ket
        End
------------------------------------------------------------------
Callout 25  (?=
    abcdefg
--->abcdefg
 25 ^           (?=
 0: abcd
    xyz123
--->xyz123
 25 ^          (?=
 0: xyz

/^(?(?C$abc$)(?=abc)abcd|xyz)/B
------------------------------------------------------------------
        Bra
        ^
        Cond
        CalloutStr $abc$ 7 12 3
        Assert
        abc
        Ket
        abcd
        Alt
        xyz
        Ket
        Ket
        End
------------------------------------------------------------------
    abcdefg
Callout (7): $abc$
--->abcdefg
    ^           (?=
 0: abcd
    xyz123
Callout (7): $abc$
--->xyz123
    ^          (?=
 0: xyz

/^ab(?C'first')cd(?C"second")ef/
    abcdefg
Callout (7): 'first'
--->abcdefg
    ^ ^         c
Callout (20): "second"
--->abcdefg
    ^   ^       e
 0: abcdef

/(?:a(?C`code`)){3}X/
    aaaXY
Callout (8): `code`
--->aaaXY
    ^^        ){3}
Callout (8): `code`
--->aaaXY
    ^ ^       ){3}
Callout (8): `code`
--->aaaXY
    ^  ^      ){3}
 0: aaaX

# Binary zero in callout string
#  a  (  ?  C  '  x     z  '  )  b
/ 61 28 3f 43 27 78 00 7a 27 29 62/hex,callout_info
Callout 'x\x00z'  b
    abcdefgh
Callout (5): 'x\x00z'
--->abcdefgh
    ^^           b
 0: ab

/(?(?!)^)/

/(?(?!)a|b)/
    bbb
 0: b
\= Expect no match
    aaa
No match

# JIT gives a different error message for the infinite recursion

"(*NO_JIT)((?2)+)((?1)){"
    abcd{
Failed: error -52: nested recursion at the same subject position

# Perl fails to diagnose the absence of an assertion

"(?(?<E>.*!.*)?)"
Failed: error 128 at offset 2: assertion expected after (?( or (?(?C)

"X((?2)()*+){2}+"B
------------------------------------------------------------------
        Bra
        X
        Once
        CBra 1
        Recurse
        Braposzero
        SCBraPos 2
        KetRpos
        Ket
        CBra 1
        Recurse
        Braposzero
        SCBraPos 2
        KetRpos
        Ket
        Ket
        Ket
        End
------------------------------------------------------------------

"X((?2)()*+){2}"B
------------------------------------------------------------------
        Bra
        X
        CBra 1
        Recurse
        Braposzero
        SCBraPos 2
        KetRpos
        Ket
        CBra 1
        Recurse
        Braposzero
        SCBraPos 2
        KetRpos
        Ket
        Ket
        End
------------------------------------------------------------------

/(?<=\bABQ(3(?-7)))/
Failed: error 115 at offset 15: reference to non-existent subpattern

/(?<=\bABQ(3(?+7)))/
Failed: error 115 at offset 15: reference to non-existent subpattern

";(?<=()((?3))((?2)))"
Failed: error 125 at offset 1: lookbehind assertion is not fixed length

# Perl loops on this (PCRE2 used to!)

/(?<=\Ka)/g,aftertext
    aaaaa
 0: a
 0+ aaaa
 0: a
 0+ aaa
 0: a
 0+ aa
 0: a
 0+ a
 0: a
 0+ 

/(?<=\Ka)/altglobal,aftertext
    aaaaa
 0: a
 0+ aaaa
 0: a
 0+ aaa
 0: a
 0+ aa
 0: a
 0+ a
 0: a
 0+ 

/((?2){73}(?2))((?1))/info
Capture group count = 2
May match empty string
Subject length lower bound = 0

/abc/
\= Expect no match
    \[9x!xxx(]{9999}
No match

/(abc)*/
    \[abc]{5}
 0: abcabcabcabcabc
 1: abc

/^/gm
    \n\n\n
 0: 
 0: 
 0: 

/^/gm,alt_circumflex
    \n\n\n
 0: 
 0: 
 0: 
 0: 

/((((((((x))))))))\81/
Failed: error 115 at offset 19: reference to non-existent subpattern
    xx1

/((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((x))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\80/
    xx
Matched, but too many substrings
 0: xx
 1: x
 2: x
 3: x
 4: x
 5: x
 6: x
 7: x
 8: x
 9: x
10: x
11: x
12: x
13: x
14: x

/\80/
Failed: error 115 at offset 2: reference to non-existent subpattern

/A\8B\9C/
Failed: error 115 at offset 2: reference to non-existent subpattern
    A8B9C

/(?x:((?'a')) # comment (with parentheses) and | vertical
(?-x:#not a comment (?'b')) # this is a comment ()
(?'c')) # not a comment (?'d')/info
Capture group count = 5
Named capture groups:
  a   2
  b   3
  c   4
  d   5
First code unit = '#'
Last code unit = ' '
Subject length lower bound = 32

/(?|(?'a')(2)(?'b')|(?'a')(?'a')(3))/I,dupnames
Capture group count = 3
Named capture groups:
  a   1
  a   2
  b   3
Options: dupnames
Starting code units: 2 3 
Subject length lower bound = 1
    A23B
 0: 2
 1: 
 2: 2
 3: 
    B32A
 0: 3
 1: 
 2: 
 3: 3

# These are some patterns that used to cause buffer overflows or other errors
# while compiling.

/.((?2)(?R)|\1|$)()/B
------------------------------------------------------------------
        Bra
        Any
        CBra 1
        Recurse
        Recurse
        Alt
        \1
        Alt
        $
        Ket
        CBra 2
        Ket
        Ket
        End
------------------------------------------------------------------

/.((?3)(?R)()(?2)|\1|$)()/B
------------------------------------------------------------------
        Bra
        Any
        CBra 1
        Recurse
        Recurse
        CBra 2
        Ket
        Recurse
        Alt
        \1
        Alt
        $
        Ket
        CBra 3
        Ket
        Ket
        End
------------------------------------------------------------------

/(\9*+(?2);\3++()2|)++{/
Failed: error 115 at offset 2: reference to non-existent subpattern

/\V\x85\9*+((?2)\3++()2)*:2/
Failed: error 115 at offset 7: reference to non-existent subpattern

/(((?(R)){0,2}) (?'x'((?'R')((?'R')))))/dupnames

/(((?(X)){0,2}) (?'x'((?'X')((?'X')))))/dupnames

/(((?(R)){0,2}) (?'x'((?'X')((?'R')))))/

"(?J)(?'d'(?'d'\g{d}))"

"(?=!((?2)(?))({8(?<=(?1){29}8bbbb\x16\xd\xc6^($(\xa9H4){4}h}?1)B))\x15')"
Failed: error 125 at offset 16: lookbehind assertion is not fixed length

/A(?'')Z/
Failed: error 162 at offset 4: subpattern name expected

"(?J:(?|(?'R')(\k'R')|((?'R'))))"

/(?<=|(\,\$(?73591620449005828816)\xa8.{7}){6}\x09)/
Failed: error 161 at offset 17: subpattern number is too big

/^(?:(?(1)x|)+)+$()/B
------------------------------------------------------------------
        Bra
        ^
        SBra
        SCond
      1 Cond ref
        x
        Alt
        KetRmax
        KetRmax
        $
        CBra 1
        Ket
        Ket
        End
------------------------------------------------------------------

/[[:>:]](?<)/
Failed: error 162 at offset 10: subpattern name expected

/((?x)(*:0))#(?'/
Failed: error 162 at offset 15: subpattern name expected

/(?C$[$)(?<]/
Failed: error 162 at offset 10: subpattern name expected

/(?C$)$)(?<]/
Failed: error 162 at offset 10: subpattern name expected

/(?(R))*+/B
------------------------------------------------------------------
        Bra
        Braposzero
        SBraPos
        SCond
        Cond recurse any
        Ket
        KetRpos
        Ket
        End
------------------------------------------------------------------
    abcd
 0: 

/((?x)(?#))#(?'/
Failed: error 162 at offset 14: subpattern name expected

/((?x)(?#))#(?'abc')/I
Capture group count = 2
Named capture groups:
  abc   2
First code unit = '#'
Subject length lower bound = 1

/[[:\\](?<[::]/
Failed: error 162 at offset 9: subpattern name expected

/[[:\\](?'abc')[a:]/I
Capture group count = 1
Named capture groups:
  abc   1
Starting code units: : [ \ 
Subject length lower bound = 2

"[[[.\xe8Nq\xffq\xff\xe0\x2|||::Nq\xffq\xff\xe0\x6\x2|||::[[[:[::::::[[[[[::::::::[:[[[:[:::[[[[[[[[[[[[:::::::::::::::::[[.\xe8Nq\xffq\xff\xe0\x2|||::Nq\xffq\xff\xe0\x6\x2|||::[[[:[::::::[[[[[::::::::[:[[[:[:::[[[[[[[[[[[[[[:::E[[[:[:[[:[:::[[:::E[[[:[:[[:'[:::::E[[[:[::::::[[[:[[[[[[[::E[[[:[::::::[[[:[[[[[[[[:[[::[::::[[:::::::[[:[[[[[[[:[[::[:[[:[~"
Failed: error 106 at offset 353: missing terminating ] for character class

/()(?(R)0)*+/B
------------------------------------------------------------------
        Bra
        CBra 1
        Ket
        Braposzero
        SBraPos
        SCond
        Cond recurse any
        0
        Ket
        KetRpos
        Ket
        End
------------------------------------------------------------------

/(?R-:(?</
Failed: error 158 at offset 3: (?R (recursive pattern call) must be followed by a closing parenthesis

/(?R-:(?<)/
Failed: error 158 at offset 3: (?R (recursive pattern call) must be followed by a closing parenthesis

/(?(?C{\Q})(?!(?'/
Failed: error 162 at offset 16: subpattern name expected

/(?(?C{\Q})(?!(?'abc')))/I
Capture group count = 1
Named capture groups:
  abc   1
May match empty string
Subject length lower bound = 0

/(?1){3918}(((((0(\k'R'))))(?J)(?'R'(?'R'\3){99})))/I
Capture group count = 8
Max back reference = 8
Named capture groups:
  R   7
  R   8
Duplicate name status changes
Last code unit = '0'
Subject length lower bound = 65535

/(?|(aaa)|(b))\g{1}/I
Capture group count = 1
Max back reference = 1
Starting code units: a b 
Subject length lower bound = 1

/(?|(aaa)|(b))(?1)/I
Capture group count = 1
Starting code units: a b 
Subject length lower bound = 4

/(?|(aaa)|(b))/I
Capture group count = 1
Starting code units: a b 
Subject length lower bound = 1

/(?|(?'a'aaa)|(?'a'b))\k'a'/I
Capture group count = 1
Max back reference = 1
Named capture groups:
  a   1
Starting code units: a b 
Subject length lower bound = 1

/(?|(?'a'aaa)|(?'a'b))(?'a'cccc)\k'a'/I,dupnames
Capture group count = 2
Max back reference = 2
Named capture groups:
  a   1
  a   2
Options: dupnames
Starting code units: a b 
Last code unit = 'c'
Subject length lower bound = 5

/ab{3cd/
    ab{3cd
 0: ab{3cd

/ab{3,cd/
    ab{3,cd
 0: ab{3,cd

/ab{3,4a}cd/
    ab{3,4a}cd
 0: ab{3,4a}cd

/{4,5a}bc/
    {4,5a}bc
 0: {4,5a}bc

/\x0{ab}/
    \0{ab}
 0: \x00{ab}

/^(a(b))\1\g1\g{1}\g-1\g{-1}\g{-02}Z/
    ababababbbabZXXXX
 0: ababababbbabZ
 1: ab
 2: b

/.*?a(*PRUNE)b/
    aab
 0: ab

/.*?a(*PRUNE)b/s
    aab
 0: ab

/^a(*PRUNE)b/s
\= Expect no match
    aab
No match

/.*?a(*SKIP)b/
    aab
 0: ab

/(?(8000000000/
Failed: error 161 at offset 8: subpattern number is too big

/((?(R8000000000)))/
Failed: error 161 at offset 9: subpattern number is too big

/0(?0)|(1)(*THEN)(*SKIP:0)(*FAIL)/
\= Expect no match
    01
No match

/(?(1)()\983040\2)/
Failed: error 161 at offset 14: subpattern number is too big

/(*LIMIT_MATCH=)abc/
Failed: error 160 at offset 14: (*VERB) not recognized or malformed

/(*CRLF)(*LIMIT_MATCH=)abc/
Failed: error 160 at offset 21: (*VERB) not recognized or malformed

/(?:ab)?(?:ab)(?:ab)/
    abab
 0: abab
    ababab
 0: ababab
\= Expect no match
    aba
No match

/((*MARK:A))++a(*SKIP:B)b/
\= Expect no match
    aacb
No match

/(*MARK:a\zb)z/alt_verbnames
Failed: error 140 at offset 10: invalid escape sequence in (*VERB) name

/(*:ab\t(d\)c)xxx/
Failed: error 122 at offset 12: unmatched closing parenthesis

/(*:ab\t(d\)c)xxx/alt_verbnames,mark
    cxxxz
 0: xxx
MK: ab\x09(d)c

/(*:A\Qxx)x\EB)x/alt_verbnames,mark
    x
 0: x
MK: Axx)xB

/(*:A\ExxxB)x/alt_verbnames,mark
    x
 0: x
MK: AxxxB

/(*: A \ and #comment
     \ B)x/x,alt_verbnames,mark
    x
 0: x
MK: A and B

/(*: A \ and #comment
     \ B)x/alt_verbnames,mark
    x
 0: x
MK:  A  and #comment\x0a      B

/(*: A \ and #comment
     \ B)x/x,mark
    x
 0: x
MK:  A \ and #comment\x0a     \ B

/(*: A \ and #comment
     \ B)x/mark
    x
 0: x
MK:  A \ and #comment\x0a     \ B

/(*:A
B)x/alt_verbnames,mark
    x
 0: x
MK: A\x0aB

/(*:abc\Qpqr)/alt_verbnames
Failed: error 160 at offset 12: (*VERB) not recognized or malformed

/abc/use_offset_limit
    1234abcde\=offset_limit=100
 0: abc
    1234abcde\=offset_limit=9
 0: abc
    1234abcde\=offset_limit=4
 0: abc
    1234abcde\=offset_limit=4,offset=4
 0: abc
\= Expect no match
    1234abcde\=offset_limit=4,offset=5
No match
    1234abcde\=offset_limit=3
No match

/(?<=abc)/use_offset_limit
    1234abc\=offset_limit=7
 0: 
\= Expect no match
    1234abc\=offset_limit=6
No match

/A/g,replace=-,use_offset_limit
    XAXAXAXAXA\=offset_limit=4
 2: X-X-XAXAXA

/abc/
\= Expect error
    1234abcde\=offset_limit=4
Failed: error -56: offset limit set without PCRE2_USE_OFFSET_LIMIT

/^\w/m,use_offset_limit
    \n..\naa\=offset_limit=3
No match
    \n..\naa\=offset_limit=4
 0: a

/abcd/null_context
    abcd\=null_context
 0: abcd
\= Expect error - not allowed together
    abcd\=null_context,find_limits
** Not allowed together: find_limits null_context
    abcd\=allusedtext,startchar
** Not allowed together: allusedtext startchar

/abcd/replace=w\rx\x82y\o{333}z(\Q12\$34$$\x34\E5$$),substitute_extended
    abcd
 1: w\x0dx\x82y\xdbz(12\$34$$\x345$)

/abcd/replace=w\rx\x82y\o{333}z(\Q12\$34$$\x34\E5$$),substitute_extended,substitute_literal
    >>abcd<<
 1: >>w\rx\x82y\o{333}z(\Q12\$34$$\x34\E5$$)<<
    
/abcd/g,replace=\$1$2\,substitute_literal
    XabcdYabcdZ
 2: X\$1$2\Y\$1$2\Z

/a(bc)(DE)/replace=a\u$1\U$1\E$1\l$2\L$2\Eab\Uab\LYZ\EDone,substitute_extended
    abcDE
 1: aBcBCbcdEdeabAByzDone

/abcd/replace=xy\kz,substitute_extended
    abcd
Failed: error -57 at offset 4 in replacement: bad escape sequence in replacement string

/a(?:(b)|(c))/substitute_extended,replace=X${1:+1:-1}X${2:+2:-2}
    ab
 1: X1X-2
    ac
 1: X-1X2
    ab\=replace=${1:+$1\:$1:$2}
 1: b:b
    ac\=replace=${1:+$1\:$1:$2}
 1: c
    >>ac<<\=replace=${1:+$1\:$1:$2},substitute_literal
 1: >>${1:+$1\:$1:$2}<<

/a(?:(b)|(c))/substitute_extended,replace=X${1:-1:-1}X${2:-2:-2}
    ab
 1: XbX2:-2
    ac
 1: X1:-1Xc

/(a)/substitute_extended,replace=>${1:+\Q$1:{}$$\E+\U$1}<
    a
 1: >$1:{}$$+A<

/X(b)Y/substitute_extended
    XbY\=replace=x${1:+$1\U$1}y
 1: xbBY
    XbY\=replace=\Ux${1:+$1$1}y
 1: XBBY

/a/substitute_extended,replace=${*MARK:+a:b}
    a
Failed: error -58 at offset 7 in replacement: expected closing curly bracket in replacement string

/(abcd)/replace=${1:+xy\kz},substitute_extended
    abcd
Failed: error -57 at offset 8 in replacement: bad escape sequence in replacement string

/(abcd)/
    abcd\=replace=${1:+xy\kz},substitute_extended
Failed: error -57 at offset 8 in replacement: bad escape sequence in replacement string

/abcd/substitute_extended,replace=>$1<
    abcd
Failed: error -49 at offset 3 in replacement: unknown substring

/abcd/substitute_extended,replace=>xxx${xyz}<<<
    abcd
Failed: error -49 at offset 10 in replacement: unknown substring

/(?J)(?:(?<A>a)|(?<A>b))/replace=<$A>
    [a]
 1: [<a>]
    [b]
 1: [<b>]
\= Expect error
    (a)\=ovector=1
Failed: error -54 at offset 3 in replacement: requested value is not available

/(a)|(b)/replace=<$1>
\= Expect error
    b
Failed: error -55 at offset 3 in replacement: requested value is not set

/(aa)(BB)/substitute_extended,replace=\U$1\L$2\E$1..\U$1\l$2$1
    aaBB
 1: AAbbaa..AAbBaa
    
/abcd/replace=wxyz,substitute_matched
    abcd
 1: wxyz
    pqrs 
 0: pqrs

/abcd/g
    >abcd1234abcd5678<\=replace=wxyz,substitute_matched
 2: >wxyz1234wxyz5678<

/^(o(\1{72}{\"{\\{00000059079}\d*){74}}){19}/I
Capture group count = 2
Max back reference = 1
Compile options: <none>
Overall options: anchored
First code unit = 'o'
Last code unit = '}'
Subject length lower bound = 65535

/((p(?'K/
Failed: error 142 at offset 7: syntax error in subpattern name (missing terminator?)

/((p(?'K/no_auto_capture
Failed: error 142 at offset 7: syntax error in subpattern name (missing terminator?)

/abc/replace=A$3123456789Z
    abc
Failed: error -49 at offset 3 in replacement: unknown substring

/(?<!a{65535}a{5})x/I
Failed: error 187 at offset 0: lookbehind assertion is too long

/(?<!a{65535})x/I
Capture group count = 0
Max lookbehind = 65535
First code unit = 'x'
Subject length lower bound = 1

/(?=a\K)/replace=z
    BaCaD
Failed: error -60: match with end before start or start moved backwards is not supported
    
/(?<=\K.)/g,replace=-
    ab
Failed: error -60: match with end before start or start moved backwards is not supported

/(?'abcdefghijklmnopqrstuvwxyzABCDEFG'toolong)/
Failed: error 148 at offset 36: subpattern name is too long (maximum 32 code units)

/(?'abcdefghijklmnopqrstuvwxyzABCDEF'justright)/

# These two use zero-termination
/abcd/max_pattern_length=3
Failed: error 188 at offset 0: pattern string is longer than the limit set by the application

/abc/max_pattern_length=3

# These two, being hex, pass the length
/abcdefab/hex,max_pattern_length=3
Failed: error 188 at offset 0: pattern string is longer than the limit set by the application

/abcdef/hex,max_pattern_length=3

# These patterns used to take a long time to compile

"(.*)
((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))
((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))
((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))"xI
Capture group count = 12
May match empty string
Options: extended
First code unit at start or follows newline
Subject length lower bound = 0

"(?<=a()
((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))
((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))
((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))
a)"xI
Capture group count = 12
Max lookbehind = 2
May match empty string
Options: extended
Subject length lower bound = 0

"(?|()|())(.*)
((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))
((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))
((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))"xI
Capture group count = 13
May match empty string
Options: extended
Subject length lower bound = 0

"(?|()|())(?<=a()
((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))
((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))
((?-2)(?-2))((?-2)(?-2))((?-2)(?-2))
a)"xI
Failed: error 135 at offset 9: lookbehind is too complicated

# Test the use of malloc for caching group information when there are more
# groups than fit into the on-stack workspace.

/\[()]{1024}/I,expand
Expanded: ()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()
Capture group count = 1024
May match empty string
Subject length lower bound = 0

# Test minlength capped at 65535

/(A{65000})\1{65000}/I
Capture group count = 1
Max back reference = 1
First code unit = 'A'
Last code unit = 'A'
Subject length lower bound = 65535

# Test group scans when numbers are not unique

/(?|()+|(a)+)/BI
------------------------------------------------------------------
        Bra
        Bra
        SCBra 1
        KetRmax
        Alt
        CBra 1
        a
        KetRmax
        Ket
        Ket
        End
------------------------------------------------------------------
Capture group count = 1
May match empty string
Subject length lower bound = 0

/(?|(a)+|()+)/BI
------------------------------------------------------------------
        Bra
        Bra
        CBra 1
        a
        KetRmax
        Alt
        SCBra 1
        KetRmax
        Ket
        Ket
        End
------------------------------------------------------------------
Capture group count = 1
May match empty string
Subject length lower bound = 0

/(?|()|(a))/BI
------------------------------------------------------------------
        Bra
        Bra
        CBra 1
        Ket
        Alt
        CBra 1
        a
        Ket
        Ket
        Ket
        End
------------------------------------------------------------------
Capture group count = 1
May match empty string
Subject length lower bound = 0

/(?|(a)|())/BI
------------------------------------------------------------------
        Bra
        Bra
        CBra 1
        a
        Ket
        Alt
        CBra 1
        Ket
        Ket
        Ket
        End
------------------------------------------------------------------
Capture group count = 1
May match empty string
Subject length lower bound = 0

# Test CRLF handling in empty string substitutions

/^$/gm,newline=anycrlf,replace=-
    X\r\n\r\nY
 1: X\x0d\x0a-\x0d\x0aY

/^$/gm,newline=crlf,replace=-
    X\r\n\r\nY
 1: X\x0d\x0a-\x0d\x0aY

/^$/gm,newline=any,replace=-
    X\r\n\r\nY
 1: X\x0d\x0a-\x0d\x0aY

"(*ANYCRLF)(?m)^(.*[^0-9\r\n].*|)$"g,replace=NaN
    15\r\nfoo\r\n20\r\nbar\r\nbaz\r\n\r\n20
 4: 15\x0d\x0aNaN\x0d\x0a20\x0d\x0aNaN\x0d\x0aNaN\x0d\x0aNaN\x0d\x0a20

/a[[:punct:]b]/bincode
------------------------------------------------------------------
        Bra
        a
        [!-/:-@[-`b{-~]
        Ket
        End
------------------------------------------------------------------

/a[b[:punct:]]/bincode
------------------------------------------------------------------
        Bra
        a
        [!-/:-@[-`b{-~]
        Ket
        End
------------------------------------------------------------------

/L(?#(|++<!(2)?/B
------------------------------------------------------------------
        Bra
        L?+
        Ket
        End
------------------------------------------------------------------

/L(?#(|++<!(2)?/B,no_auto_possess
------------------------------------------------------------------
        Bra
        L?
        Ket
        End
------------------------------------------------------------------

/L(?#(|++<!(2)?/B,auto_callout
------------------------------------------------------------------
        Bra
        Callout 255 0 14
        L?+
        Callout 255 14 0
        Ket
        End
------------------------------------------------------------------

/L(?#(|++<!(2)?/B,no_auto_possess,auto_callout
------------------------------------------------------------------
        Bra
        Callout 255 0 14
        L?
        Callout 255 14 0
        Ket
        End
------------------------------------------------------------------

/(A*)\E+/B,auto_callout
------------------------------------------------------------------
        Bra
        Callout 255 0 1
        SCBra 1
        Callout 255 1 2
        A*
        Callout 255 3 4
        KetRmax
        Callout 255 7 0
        Ket
        End
------------------------------------------------------------------

/()\Q\E*]/B,auto_callout
------------------------------------------------------------------
        Bra
        Callout 255 0 1
        Brazero
        SCBra 1
        Callout 255 1 6
        KetRmax
        Callout 255 7 1
        ]
        Callout 255 8 0
        Ket
        End
------------------------------------------------------------------
    a[bc]d
--->a[bc]d
 +0     ^      (
 +1     ^      )\Q\E*
 +7     ^      ]
 +8     ^^     End of pattern
 0: ]
 1: 

/\x8a+f|;T?(*:;.'?`(\xeap ){![^()!y*''C*(?';]{1;(\x08)/B,alt_verbnames,dupnames,extended
------------------------------------------------------------------
        Bra
        \x{8a}++
        f
        Alt
        ;
        T?
        *MARK ;.'?`(\x{ea}p
        {!
        [\x00- "-&+-:<->@-BD-xz-\xff] (neg)
        {1;
        CBra 1
        \x08
        Ket
        Ket
        End
------------------------------------------------------------------

# Tests for NULL characters in comments and verb "names" and callouts

# /A#B\x00C\x0aZ/
/41 23 42 00 43 0a 5a/Bx,hex
------------------------------------------------------------------
        Bra
        AZ
        Ket
        End
------------------------------------------------------------------

# /A+#B\x00C\x0a+/
/41 2b 23 42 00 43 0a 2b/Bx,hex
------------------------------------------------------------------
        Bra
        A++
        Ket
        End
------------------------------------------------------------------

# /A(*:B\x00W#X\00Y\x0aC)Z/
/41 28 2a 3a 42 00 57 23 58 00 59 0a 43 29 5a/Bx,hex,alt_verbnames
------------------------------------------------------------------
        Bra
        A
        *MARK B\x{0}WC
        Z
        Ket
        End
------------------------------------------------------------------

# /A(*:B\x00W#X\00Y\x0aC)Z/
/41 28 2a 3a 42 00 57 23 58 00 59 0a 43 29 5a/Bx,hex
------------------------------------------------------------------
        Bra
        A
        *MARK B\x{0}W#X\x{0}Y\x{a}C
        Z
        Ket
        End
------------------------------------------------------------------

# /A(?C{X\x00Y})B/
/41 28 3f 43 7b 58 00 59 7d 29 42/B,hex
------------------------------------------------------------------
        Bra
        A
        CalloutStr {X\x{0}Y} 5 10 1
        B
        Ket
        End
------------------------------------------------------------------

# /A(?#X\x00Y)B/
/41 28 3f 23 7b 00 7d 29 42/B,hex
------------------------------------------------------------------
        Bra
        AB
        Ket
        End
------------------------------------------------------------------

# Tests for leading comment in extended patterns

/ (?-x):?/extended

/(?-x):?/extended

/0b 28 3f 2d 78 29 3a/hex,extended

/#comment
(?-x):?/extended

/(8(*:6^\x09x\xa6l\)6!|\xd0:[^:|)\x09d\Z\d{85*m(?'(?<1!)*\W[*\xff]!!h\w]*\xbe;/alt_bsux,alt_verbnames,allow_empty_class,dollar_endonly,extended,multiline,never_utf,no_dotstar_anchor,no_start_optimize
Failed: error 162 at offset 49: subpattern name expected

/a|(b)c/replace=>$1<,substitute_unset_empty
    cat
 1: c><t
    xbcom
 1: x>b<om

/a|(b)c/
    cat\=replace=>$1<
Failed: error -55 at offset 3 in replacement: requested value is not set
    cat\=replace=>$1<,substitute_unset_empty
 1: c><t
    xbcom\=replace=>$1<,substitute_unset_empty
 1: x>b<om

/a|(b)c/substitute_extended
    cat\=replace=>${2:-xx}<
Failed: error -49 at offset 9 in replacement: unknown substring
    cat\=replace=>${2:-xx}<,substitute_unknown_unset
 1: c>xx<t
    cat\=replace=>${X:-xx}<,substitute_unknown_unset
 1: c>xx<t

/a|(?'X'b)c/replace=>$X<,substitute_unset_empty
    cat
 1: c><t
    xbcom
 1: x>b<om

/a|(?'X'b)c/replace=>$Y<,substitute_unset_empty
    cat
Failed: error -49 at offset 3 in replacement: unknown substring
    cat\=substitute_unknown_unset
 1: c><t
    cat\=substitute_unknown_unset,-substitute_unset_empty
Failed: error -55 at offset 3 in replacement: requested value is not set

/a|(b)c/replace=>$2<,substitute_unset_empty
    cat
Failed: error -49 at offset 3 in replacement: unknown substring
    cat\=substitute_unknown_unset
 1: c><t
    cat\=substitute_unknown_unset,-substitute_unset_empty
Failed: error -55 at offset 3 in replacement: requested value is not set

/()()()/use_offset_limit
    \=ovector=11000000000
** Invalid value in 'ovector=11000000000'
    \=callout_fail=11000000000
** Invalid value in 'callout_fail=11000000000'
    \=callout_fail=1:11000000000
** Invalid value in 'callout_fail=1:11000000000'
    \=callout_data=11000000000
** Invalid value in 'callout_data=11000000000'
    \=callout_data=-11000000000
** Invalid value in 'callout_data=-11000000000'
    \=offset_limit=1100000000000000000000
** Invalid value in 'offset_limit=1100000000000000000000'
    \=copy=11000000000
** Invalid value in 'copy=11000000000'

/(*MARK:A\x00b)/mark
    abc
 0: 
MK: A\x00b

/(*MARK:A\x00b)/mark,alt_verbnames
    abc
 0: 
MK: A\x00b

/"(*MARK:A" 00 "b)"/mark,hex
    abc
 0: 
MK: A\x00b

/"(*MARK:A" 00 "b)"/mark,hex,alt_verbnames
    abc
 0: 
MK: A\x00b

/efg/hex
** Unexpected non-hex-digit 'g' at offset 2 in hex pattern: quote missing?

/eff/hex
** Odd number of digits in hex pattern

/effg/hex
** Unexpected non-hex-digit 'g' at offset 3 in hex pattern: quote missing?

/(?J)(?'a'))(?'a')/
Failed: error 122 at offset 10: unmatched closing parenthesis

/(?<=((?C)0))/
    9010
--->9010
  0  ^       0
  0   ^      0
 0: 
 1: 0
\= Expect no match
    abc
--->abc
  0  ^      0
  0   ^     0
  0    ^    0
No match

/aaa/
\[abc]{10000000000000000000000000000}
** Repeat count too large
\[a]{3}
 0: aaa

/\[AB]{6000000000000000000000}/expand
** Pattern repeat count too large

# Hex uses pattern length, not zero-terminated. This tests for overrunning
# the given length of a pattern.

/'(*U'/hex
Failed: error 160 at offset 3: (*VERB) not recognized or malformed

/'(*'/hex
Failed: error 109 at offset 1: quantifier does not follow a repeatable item

/'('/hex
Failed: error 114 at offset 1: missing closing parenthesis

//hex

# These tests are here because Perl never allows a back reference in a
# lookbehind. PCRE2 supports some limited cases.

/([ab])...(?<=\1)z/
    a11az
 0: a11az
 1: a
    b11bz
 0: b11bz
 1: b
\= Expect no match
    b11az
No match

/(?|([ab]))...(?<=\1)z/
Failed: error 125 at offset 13: lookbehind assertion is not fixed length

/([ab])(\1)...(?<=\2)z/
    aa11az
 0: aa11az
 1: a
 2: a

/(a\2)(b\1)(?<=\2)/
Failed: error 125 at offset 10: lookbehind assertion is not fixed length

/(?<A>[ab])...(?<=\k'A')z/
    a11az
 0: a11az
 1: a
    b11bz
 0: b11bz
 1: b
\= Expect no match
    b11az
No match

/(?<A>[ab])...(?<=\k'A')(?<A>)z/dupnames
Failed: error 125 at offset 13: lookbehind assertion is not fixed length

# Perl does not support \g+n

/((\g+1X)?([ab]))+/
    aaXbbXa
 0: aaXbbXa
 1: bXa
 2: bX
 3: a

/ab(?C1)c/auto_callout
    abc
--->abc
 +0 ^       a
 +1 ^^      b
  1 ^ ^     c
 +8 ^  ^    End of pattern
 0: abc

/'ab(?C1)c'/hex,auto_callout
    abc
--->abc
 +0 ^       a
 +1 ^^      b
  1 ^ ^     c
 +8 ^  ^    End of pattern
 0: abc

# Perl accepts these, but gives a warning. We can't warn, so give an error.

/[a-[:digit:]]+/
Failed: error 150 at offset 4: invalid range in character class
    a-a9-a

/[A-[:digit:]]+/
Failed: error 150 at offset 4: invalid range in character class
    A-A9-A

/[a-\d]+/
Failed: error 150 at offset 5: invalid range in character class
    a-a9-a

/(?<RA>abc)(?(R)xyz)/B
------------------------------------------------------------------
        Bra
        CBra 1
        abc
        Ket
        Cond
        Cond recurse any
        xyz
        Ket
        Ket
        End
------------------------------------------------------------------

/(?<R>abc)(?(R)xyz)/B
------------------------------------------------------------------
        Bra
        CBra 1
        abc
        Ket
        Cond
      1 Cond ref
        xyz
        Ket
        Ket
        End
------------------------------------------------------------------

/(?=.*[A-Z])/I
Capture group count = 0
May match empty string
Subject length lower bound = 0

/()(?<=(?0))/
Failed: error 125 at offset 2: lookbehind assertion is not fixed length

/(?<!|!(?<!))/

/(?<!|!|!||||||(?<!)||(?<!)!|!||(?<!)!|!(?<!)!|!|!|!||||!!|<!)!|!||||!|/

/{2,2{2,2/use_length

/.>*?\g'0/use_length
Failed: error 157 at offset 6: \g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number

/.>*?\g'0/
Failed: error 157 at offset 6: \g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number

/{{'{22{2{{2{'{22{{22{2{'{22{2{{2{{222{{2{'{22{2{22{2{'{22{2{{2{'{22{2{22{2{'{'{22{2{22{2{'{22{2{{2{'{22{2{22{2{'{222{2{'{22{2{{2{'{22{{11{2{'{22{2{{2{{'{22{2{{2{'{22{{22{1{'{22{2{{2{{222{{2{'{22{2{22{2{'{/auto_callout

//
\=get=i00000000000000000000000000000000
** Group name in 'get' is too long
\=get=i2345678901234567890123456789012,get=i1245678901234567890123456789012
** Too many characters in named 'get' modifiers

"(?(?C))"
Failed: error 128 at offset 6: assertion expected after (?( or (?(?C)

/(?(?(?(?(?(?))))))/
Failed: error 128 at offset 2: assertion expected after (?( or (?(?C)

/(?<=(?1))((?s))/anchored

/(*:ab)*/
Failed: error 109 at offset 6: quantifier does not follow a repeatable item

%(*:(:(svvvvvvvvvv:]*[   Z!*;[]*[^[]*!^[+.+{{2,7}'      _\\\\\\\\\\\\\)?.:..    *w////\\\Q\\\\\\\\\\\\\\\T\\\\\+/?/////'+\\\EEE?/////'+/*+/[^K]?]//(w)%never_backslash_c,alt_verbnames,auto_callout

/./newline=crlf
    \=ph
No match

/(\x0e00\000000\xc)/replace=\P,substitute_extended
    \x0e00\000000\xc
Failed: error -57 at offset 2 in replacement: bad escape sequence in replacement string

//replace=0
    \=offset=7
Failed: error -33: bad offset value

/(?<=\G.)/g,replace=+
    abc
 3: a+b+c+

".+\QX\E+"B,no_auto_possess
------------------------------------------------------------------
        Bra
        Any+
        X+
        Ket
        End
------------------------------------------------------------------

".+\QX\E+"B,auto_callout,no_auto_possess
------------------------------------------------------------------
        Bra
        Callout 255 0 4
        Any+
        Callout 255 4 4
        X+
        Callout 255 8 0
        Ket
        End
------------------------------------------------------------------

# This one is here because Perl gives an 'unmatched )' error which goes away
# if one of the \) sequences is removed - which is weird. PCRE finds it too
# complicated to find a minimum matching length.

"()X|((((((((()))))))((((())))))\2())((((((\2\2)))\2)(\22((((\2\2)2))\2)))(2\ZZZ)+:)Z^|91ZiZZnter(ZZ |91Z(ZZ ZZ(\r2Z( or#(\Z2(Z\Z(\2\2)2))\2Z)Z(\22Z((\Z2(Z\Z(\2\2)2))\2Z+:)Z|91Z(ZZ ZZ(\r2Z( or#(\Z2(Z\Z((Z*(\2(Z\':))\0)i|||||||||||||||loZ\2\2)2))\2Z)Z(\22Z((\Z2(Z\Z(\2\2)2))\2Z)))int \)\0nte!rnal errpr\2\\21r(2\ZZZ)+:)Z!|91Z(ZZ ZZ(\r2Z( or#(\Z2(Z\Z(\2\2)2))\2Z)Z(\22Z((\Z2(Z\Z(\2\2)2))\2Z)))int \)\0(2\ZZZ)+:)Z^|91ZiZZnter(ZZ |91Z(ZZ ZZ(\r2Z( or#(\Z2(Z\Z(\2\2)2))\2Z)Z(\22Z((\Z2(Z\Z(\2\2)2))\2Z)))int \)\0(2\ZZZ)+:)Z^)))int \)\0(2\ZZZ)+:)Z^|91ZiZZnter(ZZernZal ZZ(\r2Z( or#(\Z2(Z\Z(\2\2)2))\2Z)Z(\22Z((\Z2(Z\Z(\2\2)2))\2Z)))int \))\ZZ(\r2Z( or#(\Z2(Z\Z(\2\2)2))\2Z)Z(\22Z((\Z2(Z\Z(\2\2)))\2))))((((((\2\2))))))"I
Capture group count = 108
Max back reference = 22
Contains explicit CR or LF match
Subject length lower bound = 1

# This checks that new code for handling groups that may match an empty string
# works on a very large number of alternatives. This pattern used to provoke a
# complaint that it was too complicated.

/(?:\[A|B|C|D|E|F|G|H|I|J|]{200}Z)/expand

# This one used to compile rubbish instead of a compile error, and then
# behave unpredictably at match time.

/.+(?(?C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'))?!XXXX.=X/
Failed: error 128 at offset 63: assertion expected after (?( or (?(?C)
    .+(?(?C'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'))?!XXXX.=X

/[:[:alnum:]-[[a:lnum:]+/
Failed: error 150 at offset 11: invalid range in character class

/((?(?C'')\QX\E(?!((?(?C'')(?!X=X));=)r*X=X));=)/
Failed: error 128 at offset 11: assertion expected after (?( or (?(?C)

/((?(?C'')\Q\E(?!((?(?C'')(?!X=X));=)r*X=X));=)/

/abcd/auto_callout
    abcd\=callout_error=255:2
--->abcd
 +0 ^        a
 +1 ^^       b
Failed: error -37: callout error code

/()(\g+65534)/
Failed: error 161 at offset 11: subpattern number is too big

/()(\g+65533)/
Failed: error 115 at offset 10: reference to non-existent subpattern

/\x00\x00\x00(\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\2*\x00k\d+\x00\x00\x00\x00\x00\x00\2*\x00\x00\1*.){36}int^\x00\x00\x00(\1{50779}?)J\w2/I
Capture group count = 2
Max back reference = 2
First code unit = \xc1
Last code unit = '2'
Subject length lower bound = 65535

/(a)(b)\2\1\1\1\1/I
Capture group count = 2
Max back reference = 2
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 7

/(?<a>a)(?<b>b)\g{b}\g{a}\g{a}\g{a}\g{a}(?<a>xx)(?<b>zz)/I,dupnames
Capture group count = 4
Max back reference = 4
Named capture groups:
  a   1
  a   3
  b   2
  b   4
Options: dupnames
First code unit = 'a'
Last code unit = 'z'
Subject length lower bound = 11

//
    \=ovector=7777777777
** Invalid value in 'ovector=7777777777'

# This is here because Perl matches, even though a COMMIT is encountered
# outside of the recursion.

/(?1)(A(*COMMIT)|B)D/
    BAXBAD
No match

"(?1){2}(a)"B
------------------------------------------------------------------
        Bra
        Recurse
        Recurse
        CBra 1
        a
        Ket
        Ket
        End
------------------------------------------------------------------

"(?1){2,4}(a)"B
------------------------------------------------------------------
        Bra
        Recurse
        Recurse
        Brazero
        Bra
        Bra
        Recurse
        Ket
        Brazero
        Bra
        Recurse
        Ket
        Ket
        CBra 1
        a
        Ket
        Ket
        End
------------------------------------------------------------------

# This test differs from Perl for the first subject. Perl ends up with
# $1 set to 'B'; PCRE2 has it unset (which I think is right).

/^(?:
(?:A| (?:B|B(*ACCEPT)) (?<=(.)) D)
(Z)
)+$/x
    AZB
 0: AZB
 1: <unset>
 2: Z
    AZBDZ
 0: AZBDZ
 1: B
 2: Z

# The first of these, when run by Perl, gives the mark 'aa', which is wrong.

'(?>a(*:aa))b|ac' mark
    ac
 0: ac

'(?:a(*:aa))b|ac' mark
    ac
 0: ac

/(R?){65}/
    (R?){65}
 0: 
 1: 

/\[(a)]{60}/expand
    aaaa
No match

/(?<!\1((?U)1((?U))))(*F)/never_backslash_c,alt_bsux,anchored,extended

/\g{3/
Failed: error 157 at offset 2: \g is not followed by a braced, angle-bracketed, or quoted name/number or by a plain number

/(a(?C1)(b)(c)d)+/
  abcdabcd\=callout_capture
Callout 1: last capture = 0
--->abcdabcd
    ^^           (
Callout 1: last capture = 1
 1: abcd
 2: b
 3: c
--->abcdabcd
    ^    ^       (
 0: abcdabcd
 1: abcd
 2: b
 3: c

# Perl matches this one, but PCRE does not because (*ACCEPT) clears out any
# pending backtracks in the recursion.

/^ (?(DEFINE) (..(*ACCEPT)|...) ) (?1)$/x
\= Expect no match
    abc
No match

# Perl gives no match for this one

/(a(*MARK:m)(*ACCEPT)){0}(?1)/mark
    abc
 0: a
MK: m

/abc/endanchored
    xyzabc
 0: abc
\= Expect no match
    xyzabcdef
No match
\= Expect error
    xyzabc\=ph
Failed: error -34: bad option value

/abc/
    xyzabc\=endanchored
 0: abc
\= Expect no match
    xyzabcdef\=endanchored
No match
\= Expect error
    xyzabc\=ps,endanchored
Failed: error -34: bad option value

/abc(*ACCEPT)d/endanchored
    xyzabc
 0: abc
\= Expect no match
    xyzabcdef
No match

/abc|bcd/endanchored
    xyzabcd
 0: bcd
\= Expect no match
    xyzabcdef
No match

/a(*ACCEPT)x|aa/endanchored
    aaa
 0: a

# Check auto-anchoring when there is a group that is never obeyed at
# the start of a branch.

/(?(DEFINE)(a))^bc/I
Capture group count = 1
Compile options: <none>
Overall options: anchored
First code unit = 'b'
Subject length lower bound = 2

/(a){0}.*bc/sI
Capture group count = 1
Compile options: dotall
Overall options: anchored dotall
Last code unit = 'c'
Subject length lower bound = 2

# This should be anchored, as the condition is always false and there is
# no alternative branch.

/(?(VERSION>=999)yes)^bc/I
Capture group count = 0
Compile options: <none>
Overall options: anchored
Subject length lower bound = 2

# This should not be anchored.

/(?(VERSION>=999)yes|no)^bc/I
Capture group count = 0
Last code unit = 'c'
Subject length lower bound = 4

/(*LIMIT_HEAP=0)xxx/I
Capture group count = 0
Heap limit = 0
First code unit = 'x'
Last code unit = 'x'
Subject length lower bound = 3

/\d{0,3}(*:abc)(?C1)xxx/callout_info
Callout 1  x

# ----------------------------------------------------------------------

# These are a whole pile of tests that touch lines of code that are not
# used by any other tests (at least when these were created).

/^a+?x/i,no_start_optimize,no_auto_possess
\= Expect no match
    aaa
No match

/^[^a]{3,}?x/i,no_start_optimize,no_auto_possess
\= Expect no match
    bbb
No match
    cc
No match

/^X\S/no_start_optimize,no_auto_possess
\= Expect no match
    X
No match

/^X\W/no_start_optimize,no_auto_possess
\= Expect no match
    X
No match

/^X\H/no_start_optimize,no_auto_possess
\= Expect no match
    X
No match

/^X\h/no_start_optimize,no_auto_possess
\= Expect no match
    X
No match

/^X\V/no_start_optimize,no_auto_possess
\= Expect no match
    X
No match

/^X\v/no_start_optimize,no_auto_possess
\= Expect no match
    X
No match

/^X\h/no_start_optimize,no_auto_possess
\= Expect no match
    XY
No match

/^X\V/no_start_optimize,no_auto_possess
\= Expect no match
    X\n
No match

/^X\v/no_start_optimize,no_auto_possess
\= Expect no match
    XX
No match

/^X.+?/s,no_start_optimize,no_auto_possess
\= Expect no match
    X
No match

/^X\R+?/no_start_optimize,no_auto_possess
\= Expect no match
    XX
No match

/^X\H+?/no_start_optimize,no_auto_possess
\= Expect no match
    X
No match

/^X\h+?/no_start_optimize,no_auto_possess
\= Expect no match
    X
No match

/^X\V+?/no_start_optimize,no_auto_possess
\= Expect no match
    X
No match
    X\n
No match

/^X\D+?/no_start_optimize,no_auto_possess
\= Expect no match
    X
No match
    X9
No match

/^X\S+?/no_start_optimize,no_auto_possess
\= Expect no match
    X
No match
    X\n
No match

/^X\W+?/no_start_optimize,no_auto_possess
\= Expect no match
    X
No match
    XX
No match

/^X.+?Z/no_start_optimize,no_auto_possess
\= Expect no match
    XY\n
No match

/(*CRLF)^X.+?Z/no_start_optimize,no_auto_possess
\= Expect no match
    XY\r\=ps
Partial match: XY\x0d

/^X\R+?Z/no_start_optimize,no_auto_possess
\= Expect no match
    X\nX
No match
    X\n\r\n
No match
    X\n\rY
No match
    X\n\nY
No match
    X\n\x{0c}Y
No match

/(*BSR_ANYCRLF)^X\R+?Z/no_start_optimize,no_auto_possess
\= Expect no match
    X\nX
No match
    X\n\r\n
No match
    X\n\rY
No match
    X\n\nY
No match
    X\n\x{0c}Y
No match

/^X\H+?Z/no_start_optimize,no_auto_possess
\= Expect no match
    XY\t
No match
    XYY
No match

/^X\h+?Z/no_start_optimize,no_auto_possess
\= Expect no match
    X\t\t
No match
    X\tY
No match

/^X\V+?Z/no_start_optimize,no_auto_possess
\= Expect no match
    XY\n
No match
    XYY
No match

/^X\v+?Z/no_start_optimize,no_auto_possess
\= Expect no match
    X\n\n
No match
    X\nY
No match

/^X\D+?Z/no_start_optimize,no_auto_possess
\= Expect no match
    XY9
No match
    XYY
No match

/^X\d+?Z/no_start_optimize,no_auto_possess
\= Expect no match
    X99
No match
    X9Y
No match

/^X\S+?Z/no_start_optimize,no_auto_possess
\= Expect no match
    XY\n
No match
    XYY
No match

/^X\s+?Z/no_start_optimize,no_auto_possess
\= Expect no match
    X\n\n
No match
    X\nY
No match

/^X\W+?Z/no_start_optimize,no_auto_possess
\= Expect no match
    X.A
No match
    X++
No match

/^X\w+?Z/no_start_optimize,no_auto_possess
\= Expect no match
    Xa.
No match
    Xaa
No match

/^X.{1,3}Z/s,no_start_optimize,no_auto_possess
\= Expect no match
    Xa.bd
No match

/^X\h+Z/no_start_optimize,no_auto_possess
\= Expect no match
    X\t\t
No match
    X\tY
No match

/^X\V+Z/no_start_optimize,no_auto_possess
\= Expect no match
    XY\n
No match
    XYY
No match

/^(X(*THEN)Y|AB){0}(?1)/
    ABX
 0: AB
\= Expect no match
    XAB
No match

/^(?!A(?C1)B)C/
    ABC\=callout_error=1,no_jit
No match

/^(?!A(?C1)B)C/no_start_optimize
    ABC\=callout_error=1
--->ABC
  1 ^^      B
Failed: error -37: callout error code

/^(?(?!A(?C1)B)C)/
    ABC\=callout_error=1
--->ABC
  1 ^^      B
Failed: error -37: callout error code

# ----------------------------------------------------------------------

/[a b c]/BxxI
------------------------------------------------------------------
        Bra
        [a-c]
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Options: extended_more
Starting code units: a b c 
Subject length lower bound = 1

/[a b c]/BxxxI
------------------------------------------------------------------
        Bra
        [a-c]
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Options: extended extended_more
Starting code units: a b c 
Subject length lower bound = 1

/[a b c]/B,extended_more
------------------------------------------------------------------
        Bra
        [a-c]
        Ket
        End
------------------------------------------------------------------

/[ a b c ]/B,extended_more
------------------------------------------------------------------
        Bra
        [a-c]
        Ket
        End
------------------------------------------------------------------

/[a b](?xx: [ 12 ] (?-xx:[ 34 ]) )y z/B
------------------------------------------------------------------
        Bra
        [ ab]
        Bra
        [12]
        Bra
        [ 34]
        Ket
        Ket
        y z
        Ket
        End
------------------------------------------------------------------

# Unsetting /x also unsets /xx

/[a b](?xx: [ 12 ] (?-x:[ 34 ]) )y z/B
------------------------------------------------------------------
        Bra
        [ ab]
        Bra
        [12]
        Bra
        [ 34]
        Ket
        Ket
        y z
        Ket
        End
------------------------------------------------------------------

/(a)(?-n:(b))(c)/nB
------------------------------------------------------------------
        Bra
        Bra
        a
        Ket
        Bra
        CBra 1
        b
        Ket
        Ket
        Bra
        c
        Ket
        Ket
        End
------------------------------------------------------------------

# ----------------------------------------------------------------------
# These test the dangerous PCRE2_EXTRA_BAD_ESCAPE_IS_LITERAL option.

/\j\x{z}\o{82}\L\uabcd\u\U\g{\g/B,\bad_escape_is_literal
** Unrecognized modifier '\' in '\bad_escape_is_literal'

/\N{\c/IB,bad_escape_is_literal
------------------------------------------------------------------
        Bra
        N{c
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
Extra options: bad_escape_is_literal
First code unit = 'N'
Last code unit = 'c'
Subject length lower bound = 3

/[\j\x{z}\o\gAb\g]/B,bad_escape_is_literal
------------------------------------------------------------------
        Bra
        [Abgjoxz{}]
        Ket
        End
------------------------------------------------------------------

/[Q-\N]/B,bad_escape_is_literal
Failed: error 150 at offset 5: invalid range in character class

/[\s-_]/bad_escape_is_literal
Failed: error 150 at offset 3: invalid range in character class

/[_-\s]/bad_escape_is_literal
Failed: error 150 at offset 5: invalid range in character class

/[\B\R\X]/B
Failed: error 107 at offset 2: escape sequence is invalid in character class

/[\B\R\X]/B,bad_escape_is_literal
Failed: error 107 at offset 2: escape sequence is invalid in character class

/[A-\BP-\RV-\X]/B
Failed: error 107 at offset 4: escape sequence is invalid in character class

/[A-\BP-\RV-\X]/B,bad_escape_is_literal
Failed: error 107 at offset 4: escape sequence is invalid in character class

# ----------------------------------------------------------------------

/a\b(c/literal
    a\\b(c
 0: a\b(c

/a\b(c/literal,caseless
    a\\b(c
 0: a\b(c
    a\\B(c
 0: a\B(c

/a\b(c/literal,firstline
    XYYa\\b(c
 0: a\b(c
\= Expect no match
    X\na\\b(c
No match

/a\b?c/literal,use_offset_limit
    XXXXa\\b?c\=offset_limit=4
 0: a\b?c
\= Expect no match
    XXXXa\\b?c\=offset_limit=3
No match

/a\b(c/literal,anchored,endanchored
    a\\b(c
 0: a\b(c
\= Expect no match
    Xa\\b(c
No match
    a\\b(cX
No match
    Xa\\b(cX
No match

//literal,extended
Failed: error 192 at offset 0: invalid option bits with PCRE2_LITERAL

/a\b(c/literal,auto_callout,no_start_optimize
    XXXXa\\b(c
--->XXXXa\b(c
 +0 ^             a
 +0  ^            a
 +0   ^           a
 +0    ^          a
 +0     ^         a
 +1     ^^        \
 +2     ^ ^       b
 +3     ^  ^      (
 +4     ^   ^     c
 +5     ^    ^    End of pattern
 0: a\b(c

/a\b(c/literal,auto_callout
    XXXXa\\b(c
--->XXXXa\b(c
 +0     ^         a
 +1     ^^        \
 +2     ^ ^       b
 +3     ^  ^      (
 +4     ^   ^     c
 +5     ^    ^    End of pattern
 0: a\b(c

/(*CR)abc/literal
    (*CR)abc
 0: (*CR)abc

/cat|dog/I,match_word
Capture group count = 0
Max lookbehind = 1
Extra options: match_word
Starting code units: c d 
Subject length lower bound = 3
    the cat sat
 0: cat
\= Expect no match
    caterpillar
No match
    snowcat
No match
    syndicate
No match

/(cat)|dog/I,match_line,literal
Capture group count = 0
Compile options: literal
Overall options: anchored literal
Extra options: match_line
First code unit = '('
Subject length lower bound = 9
    (cat)|dog
 0: (cat)|dog
\= Expect no match
    the cat sat
No match
    caterpillar
No match
    snowcat
No match
    syndicate
No match

/a whole line/match_line,multiline
    Rhubarb \na whole line\n custard
 0: a whole line
\= Expect no match
    Not a whole line
No match

# Perl gets this wrong, failing to capture 'b' in group 1.

/^(b+|a){1,2}?bc/
    bbc
 0: bbc
 1: b
    
# And again here, for the "babc" subject string. 

/^(b*|ba){1,2}?bc/
    babc
 0: babc
 1: ba
    bbabc
 0: bbabc
 1: ba
    bababc
 0: bababc
 1: ba
\= Expect no match
    bababbc
No match
    babababc
No match

/[[:digit:]-a]/
Failed: error 150 at offset 10: invalid range in character class

/[[:digit:]-[:print:]]/
Failed: error 150 at offset 10: invalid range in character class

/[\d-a]/
Failed: error 150 at offset 3: invalid range in character class

/[\H-z]/
Failed: error 150 at offset 3: invalid range in character class

/[\d-[:print:]]/
Failed: error 150 at offset 3: invalid range in character class

# Perl gets the second of these wrong, giving no match.

"(?<=(a))\1?b"I
Capture group count = 1
Max back reference = 1
Max lookbehind = 1
Last code unit = 'b'
Subject length lower bound = 1
    ab
 0: b
 1: a
    aaab 
 0: ab
 1: a

"(?=(a))\1?b"I
Capture group count = 1
Max back reference = 1
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 2
    ab
 0: ab
 1: a
    aaab
 0: ab
 1: a
    
# JIT does not support callout_extra  
    
/(*NO_JIT)(a+)b/auto_callout,no_start_optimize,no_auto_possess
\= Expect no match
    aac\=callout_extra 
New match attempt
--->aac
 +9 ^       (
+10 ^       a+
+12 ^ ^     )
+13 ^ ^     b
Backtrack
--->aac
+12 ^^      )
+13 ^^      b
Backtrack
No other matching paths
New match attempt
--->aac
 +9  ^      (
+10  ^      a+
+12  ^^     )
+13  ^^     b
Backtrack
No other matching paths
New match attempt
--->aac
 +9   ^     (
+10   ^     a+
Backtrack
No other matching paths
New match attempt
--->aac
 +9    ^    (
+10    ^    a+
No match
    
/(*NO_JIT)a+(?C'XXX')b/no_start_optimize,no_auto_possess
\= Expect no match
    aac\=callout_extra 
New match attempt
Callout (15): 'XXX'
--->aac
    ^ ^     b
Backtrack
Callout (15): 'XXX'
--->aac
    ^^      b
Backtrack
No other matching paths
New match attempt
Callout (15): 'XXX'
--->aac
     ^^     b
No match

/\n/firstline
    xyz\nabc
 0: \x0a

/\nabc/firstline
    xyz\nabc
 0: \x0aabc

/\x{0a}abc/firstline,newline=crlf
\= Expect no match
    xyz\r\nabc
No match

/[abc]/firstline
\= Expect no match
    \na
No match
    
# These tests are matched in test 1 as they are Perl compatible. Here we are
# looking at what does and does not get auto-possessified. 

/(?(DEFINE)(?<optional_a>a?))^(?&optional_a)a$/B
------------------------------------------------------------------
        Bra
        Cond
        Cond false
        CBra 1
        a?
        Ket
        Ket
        ^
        Recurse
        a
        $
        Ket
        End
------------------------------------------------------------------

/(?(DEFINE)(?<optional_a>a?)X)^(?&optional_a)a$/B
------------------------------------------------------------------
        Bra
        Cond
        Cond false
        CBra 1
        a?
        Ket
        X
        Ket
        ^
        Recurse
        a
        $
        Ket
        End
------------------------------------------------------------------
    
/^(a?)b(?1)a/B
------------------------------------------------------------------
        Bra
        ^
        CBra 1
        a?
        Ket
        b
        Recurse
        a
        Ket
        End
------------------------------------------------------------------

/^(a?)+b(?1)a/B
------------------------------------------------------------------
        Bra
        ^
        SCBra 1
        a?
        KetRmax
        b
        Recurse
        a
        Ket
        End
------------------------------------------------------------------

/^(a?)++b(?1)a/B
------------------------------------------------------------------
        Bra
        ^
        SCBraPos 1
        a?
        KetRpos
        b
        Recurse
        a
        Ket
        End
------------------------------------------------------------------

/^(a?)+b/B
------------------------------------------------------------------
        Bra
        ^
        SCBra 1
        a?
        KetRmax
        b
        Ket
        End
------------------------------------------------------------------

/(?=a+)a(a+)++b/B
------------------------------------------------------------------
        Bra
        Assert
        a++
        Ket
        a
        CBraPos 1
        a++
        KetRpos
        b
        Ket
        End
------------------------------------------------------------------

/(?<=(?=.){4,5}x)/B
------------------------------------------------------------------
        Bra
        Assert back
        Reverse
        Assert
        Any
        Ket
        Assert
        Any
        Ket
        Assert
        Any
        Ket
        Assert
        Any
        Ket
        Brazero
        Assert
        Any
        Ket
        x
        Ket
        Ket
        End
------------------------------------------------------------------

# Perl behaves differently with these when optimization is turned off

/a(*PRUNE:X)bc|qq/mark,no_start_optimize
\= Expect no match
    axy
No match, mark = X

/a(*THEN:X)bc|qq/mark,no_start_optimize
\= Expect no match
    axy
No match, mark = X

/(?^x-i)AB/ 
Failed: error 194 at offset 4: invalid hyphen in option setting

/(?^-i)AB/ 
Failed: error 194 at offset 3: invalid hyphen in option setting

/(?x-i-i)/
Failed: error 194 at offset 5: invalid hyphen in option setting

/(?(?=^))b/I
Capture group count = 0
Last code unit = 'b'
Subject length lower bound = 1
    abc
 0: b

/(?(?=^)|)b/I
Capture group count = 0
First code unit = 'b'
Subject length lower bound = 1
    abc
 0: b

/(?(?=^)|^)b/I
Capture group count = 0
Compile options: <none>
Overall options: anchored
First code unit = 'b'
Subject length lower bound = 1
    bbc
 0: b
\= Expect no match
    abc     
No match

/(?(1)^|^())/I
Capture group count = 1
Max back reference = 1
May match empty string
Compile options: <none>
Overall options: anchored
Subject length lower bound = 0

/(?(1)^())b/I
Capture group count = 1
Max back reference = 1
Last code unit = 'b'
Subject length lower bound = 1

/(?(1)^())+b/I,aftertext
Capture group count = 1
Max back reference = 1
Last code unit = 'b'
Subject length lower bound = 1
    abc
 0: b
 0+ c

/(?(1)^()|^)+b/I,aftertext
Capture group count = 1
Max back reference = 1
Compile options: <none>
Overall options: anchored
First code unit = 'b'
Subject length lower bound = 1
    bbc 
 0: b
 0+ bc
\= Expect no match     
    abc
No match

/(?(1)^()|^)*b/I,aftertext
Capture group count = 1
Max back reference = 1
First code unit = 'b'
Subject length lower bound = 1
    bbc 
 0: b
 0+ bc
    abc
 0: b
 0+ c
    xbc 
 0: b
 0+ c

/(?(1)^())+b/I,aftertext
Capture group count = 1
Max back reference = 1
Last code unit = 'b'
Subject length lower bound = 1
    abc
 0: b
 0+ c

/(?(1)^a()|^a)+b/I,aftertext
Capture group count = 1
Max back reference = 1
Compile options: <none>
Overall options: anchored
First code unit = 'a'
Last code unit = 'b'
Subject length lower bound = 2
    abc 
 0: ab
 0+ c
\= Expect no match     
    bbc
No match

/(?(1)^|^(a))+b/I,aftertext
Capture group count = 1
Max back reference = 1
Compile options: <none>
Overall options: anchored
Last code unit = 'b'
Subject length lower bound = 1
    abc 
 0: ab
 0+ c
 1: a
\= Expect no match     
    bbc
No match

/(?(1)^a()|^a)*b/I,aftertext
Capture group count = 1
Max back reference = 1
Last code unit = 'b'
Subject length lower bound = 1
    abc 
 0: ab
 0+ c
    bbc
 0: b
 0+ bc
    xbc 
 0: b
 0+ c

/a(b)c|xyz/g,allvector,replace=<$0>
    abcdefabcpqr\=ovector=4
 2: <abc>def<abc>pqr
 0: 6 9
 1: 7 8
 2: <unchanged>
 3: <unchanged>
    abxyz\=ovector=4
 1: ab<xyz>
 0: 2 5
 1: <unset>
 2: <unchanged>
 3: <unchanged>
    abcdefxyz\=ovector=4
 2: <abc>def<xyz>
 0: 6 9
 1: <unset>
 2: <unchanged>
 3: <unchanged>
    
/a(b)c|xyz/allvector
    abcdef\=ovector=4
 0: abc
 1: b
 2: <unchanged>
 3: <unchanged>
    abxyz\=ovector=4
 0: xyz
 1: <unset>
 2: <unchanged>
 3: <unchanged>

/a(b)c|xyz/g,replace=<$0>,substitute_callout
    abcdefabcpqr
 1(2) Old 0 3 "abc" New 0 5 "<abc>"
 2(2) Old 6 9 "abc" New 8 13 "<abc>"
 2: <abc>def<abc>pqr
    abxyzpqrabcxyz
 1(1) Old 2 5 "xyz" New 2 7 "<xyz>"
 2(2) Old 8 11 "abc" New 10 15 "<abc>"
 3(1) Old 11 14 "xyz" New 15 20 "<xyz>"
 3: ab<xyz>pqr<abc><xyz>
    12abc34xyz99abc55\=substitute_stop=2
 1(2) Old 2 5 "abc" New 2 7 "<abc>"
 2(1) Old 7 10 "xyz" New 9 14 "<xyz> STOPPED"
 2: 12<abc>34xyz99abc55
    12abc34xyz99abc55\=substitute_skip=1
 1(2) Old 2 5 "abc" New 2 7 "<abc> SKIPPED"
 2(1) Old 7 10 "xyz" New 7 12 "<xyz>"
 3(2) Old 12 15 "abc" New 14 19 "<abc>"
 3: 12abc34<xyz>99<abc>55
    12abc34xyz99abc55\=substitute_skip=2
 1(2) Old 2 5 "abc" New 2 7 "<abc>"
 2(1) Old 7 10 "xyz" New 9 14 "<xyz> SKIPPED"
 3(2) Old 12 15 "abc" New 14 19 "<abc>"
 3: 12<abc>34xyz99<abc>55

/a(b)c|xyz/g,replace=<$0>
    abcdefabcpqr
 2: <abc>def<abc>pqr
    abxyzpqrabcxyz
 3: ab<xyz>pqr<abc><xyz>
    12abc34xyz\=substitute_stop=2
 1(2) Old 2 5 "abc" New 2 7 "<abc>"
 2(1) Old 7 10 "xyz" New 9 14 "<xyz> STOPPED"
 2: 12<abc>34xyz
    12abc34xyz\=substitute_skip=1
 1(2) Old 2 5 "abc" New 2 7 "<abc> SKIPPED"
 2(1) Old 7 10 "xyz" New 7 12 "<xyz>"
 2: 12abc34<xyz>

/a(b)c|xyz/replace=<$0>
    abcdefabcpqr
 1: <abc>defabcpqr
    12abc34xyz\=substitute_skip=1
 1(2) Old 2 5 "abc" New 2 7 "<abc> SKIPPED"
 1: 12abc34xyz
    12abc34xyz\=substitute_stop=1
 1(2) Old 2 5 "abc" New 2 7 "<abc> STOPPED"
 1: 12abc34xyz

/abc\rdef/
    abc\ndef
No match

/abc\rdef\x{0d}xyz/escaped_cr_is_lf
    abc\ndef\rxyz
 0: abc\x0adef\x0dxyz
\= Expect no match     
    abc\ndef\nxyz
No match

/(?(*ACCEPT)xxx)/
Failed: error 128 at offset 2: assertion expected after (?( or (?(?C)

/(?(*atomic:xx)xxx)/
Failed: error 128 at offset 10: assertion expected after (?( or (?(?C)

/(?(*script_run:xxx)zzz)/
Failed: error 128 at offset 14: assertion expected after (?( or (?(?C)

/foobar/
    the foobar thing\=copy_matched_subject
 0: foobar
    the foobar thing\=copy_matched_subject,zero_terminate
 0: foobar

/foobar/g
    the foobar thing foobar again\=copy_matched_subject
 0: foobar
 0: foobar

/(*:XX)^abc/I
Capture group count = 0
Compile options: <none>
Overall options: anchored
First code unit = 'a'
Subject length lower bound = 3

/(*COMMIT:XX)^abc/I
Capture group count = 0
Compile options: <none>
Overall options: anchored
First code unit = 'a'
Subject length lower bound = 3

/(*ACCEPT:XX)^abc/I
Capture group count = 0
May match empty string
Subject length lower bound = 0

/abc/replace=xyz
    abc\=null_context
 1: xyz

/abc/replace=xyz,substitute_callout
    abc 
 1(1) Old 0 3 "abc" New 0 3 "xyz"
 1: xyz
\= Expect error message
    abc\=null_context
** Replacement callouts are not supported with null_context.

/\[()]{65535}()/expand
Failed: error 197 at offset 131071: too many capturing groups (maximum 65535)

/\[()]{65535}(?<A>)/expand
Failed: error 197 at offset 131075: too many capturing groups (maximum 65535)

/a(?:(*ACCEPT))??bc/
    abc
 0: abc
    axy
 0: a

/a(*ACCEPT)??bc/
    abc
 0: abc
    axy
 0: a

/a(*ACCEPT:XX)??bc/mark
    abc
 0: abc
    axy
 0: a
MK: XX

/(*:\)?/
Failed: error 109 at offset 5: quantifier does not follow a repeatable item

/(*:\Q \E){5}/alt_verbnames
Failed: error 109 at offset 11: quantifier does not follow a repeatable item

/(?=abc)/I
Capture group count = 0
May match empty string
First code unit = 'a'
Last code unit = 'c'
Subject length lower bound = 2

/(?|(X)|(XY))\1abc/I
Capture group count = 1
Max back reference = 1
First code unit = 'X'
Last code unit = 'c'
Subject length lower bound = 4

/(?|(a)|(bcde))(c)\2/I
Capture group count = 2
Max back reference = 2
Starting code units: a b 
Last code unit = 'c'
Subject length lower bound = 3

/(?|(a)|(bcde))(c)\1/I
Capture group count = 2
Max back reference = 1
Starting code units: a b 
Last code unit = 'c'
Subject length lower bound = 2

/(?|(?'A'a)|(?'A'bcde))(?'B'c)\k'B'(?'A')/I,dupnames
Capture group count = 3
Max back reference = 2
Named capture groups:
  A   1
  A   3
  B   2
Options: dupnames
Starting code units: a b 
Last code unit = 'c'
Subject length lower bound = 3

/(?|(?'A'a)|(?'A'bcde))(?'B'c)\k'A'(?'A')/I,dupnames
Capture group count = 3
Max back reference = 3
Named capture groups:
  A   1
  A   3
  B   2
Options: dupnames
Starting code units: a b 
Last code unit = 'c'
Subject length lower bound = 2

/((a|)+)+Z/I
Capture group count = 2
Starting code units: Z a 
Last code unit = 'Z'
Subject length lower bound = 1

/((?=a))[abcd]/I
Capture group count = 1
First code unit = 'a'
Subject length lower bound = 1

/A(?:(*ACCEPT))?B/info
Capture group count = 0
First code unit = 'A'
Subject length lower bound = 1

/(A(*ACCEPT)??B)C/
    ABC
 0: ABC
 1: AB
    AXY 
 0: A
 1: A

/(?<=(?<=a)b)c.*/I
Capture group count = 0
Max lookbehind = 1
First code unit = 'c'
Subject length lower bound = 1
    abc\=ph
Partial match: c
\= Expect no match
    xbc\=ph
No match

/(?<=ab)c.*/I
Capture group count = 0
Max lookbehind = 2
First code unit = 'c'
Subject length lower bound = 1
    abc\=ph
Partial match: c
\= Expect no match
    xbc\=ph
No match

/(?<=a(?<=a|a)c)/I
Capture group count = 0
Max lookbehind = 2
May match empty string
Subject length lower bound = 0

/(?<=a(?<=a|ba)c)/I
Capture group count = 0
Max lookbehind = 2
May match empty string
Subject length lower bound = 0

/(?<=(?<=a)b)(?<!abcd)/I
Capture group count = 0
Max lookbehind = 4
May match empty string
Subject length lower bound = 0

/(?<=(?<=a)b)(?<!abcd)(?<=(?<=a)bcde)/I
Capture group count = 0
Max lookbehind = 4
May match empty string
Subject length lower bound = 0

# Addition overflow
/( {32742} {42})(?<!\1{65481})/
Failed: error 187 at offset 15: lookbehind assertion is too long

# Multiplication overflow
/(X{65535})(?<=\1{32770})/
Failed: error 187 at offset 10: lookbehind assertion is too long

# ---- Non-atomic assertion tests ----

# Expect error: not allowed as a condition
/(?(*napla:xx)bc)/
Failed: error 198 at offset 9: atomic assertion expected after (?( or (?(?C)

/\A(*pla:.*\b(\w++))(?>.*?\b\1\b){3}/
    word1 word3 word1 word2 word3 word2 word2 word1 word3 word4
No match

/\A(*napla:.*\b(\w++))(?>.*?\b\1\b){3}/
    word1 word3 word1 word2 word3 word2 word2 word1 word3 word4
 0: word1 word3 word1 word2 word3 word2 word2 word1 word3
 1: word3

/\A(?*.*\b(\w++))(?>.*?\b\1\b){3}/
    word1 word3 word1 word2 word3 word2 word2 word1 word3 word4
 0: word1 word3 word1 word2 word3 word2 word2 word1 word3
 1: word3

/(*plb:(.)..|(.)...)(\1|\2)/
    abcdb\=offset=4 
 0: b
 1: b
 2: <unset>
 3: b
    abcda\=offset=4 
No match

/(*naplb:(.)..|(.)...)(\1|\2)/
    abcdb\=offset=4 
 0: b
 1: b
 2: <unset>
 3: b
    abcda\=offset=4 
 0: a
 1: <unset>
 2: a
 3: a
    
/(?<*(.)..|(.)...)(\1|\2)/
    abcdb\=offset=4 
 0: b
 1: b
 2: <unset>
 3: b
    abcda\=offset=4 
 0: a
 1: <unset>
 2: a
 3: a
    
/(*non_atomic_positive_lookahead:ab)/B
------------------------------------------------------------------
        Bra
        Non-atomic assert
        ab
        Ket
        Ket
        End
------------------------------------------------------------------
 
/(*non_atomic_positive_lookbehind:ab)/B 
------------------------------------------------------------------
        Bra
        Non-atomic assert back
        Reverse
        ab
        Ket
        Ket
        End
------------------------------------------------------------------

/(*pla:ab+)/B
------------------------------------------------------------------
        Bra
        Assert
        a
        b++
        Ket
        Ket
        End
------------------------------------------------------------------

/(*napla:ab+)/B
------------------------------------------------------------------
        Bra
        Non-atomic assert
        a
        b+
        Ket
        Ket
        End
------------------------------------------------------------------

/(*napla:)+/

/(*naplb:)+/

/(*napla:^x|^y)/I
Capture group count = 0
May match empty string
Compile options: <none>
Overall options: anchored
Starting code units: x y 
Subject length lower bound = 1

/(*napla:abc|abd)/I
Capture group count = 0
May match empty string
First code unit = 'a'
Subject length lower bound = 1

/(*napla:a|(.)(*ACCEPT)zz)\1../
    abcd
 0: abc
 1: a
    
/(*napla:a(*ACCEPT)zz|(.))\1../
    abcd
 0: bcd
 1: b
    
/(*napla:a|(*COMMIT)(.))\1\1/
    aabc
 0: aa
 1: a
\= Expect no match     
    abbc   
No match

/(*napla:a|(.))\1\1/
    aabc
 0: aa
 1: a
    abbc   
 0: bb
 1: b

# ----

# Expect error (recursion => not fixed length)
/(\2)((?=(?<=\1)))/
Failed: error 125 at offset 8: lookbehind assertion is not fixed length

/c*+(?<=[bc])/
    abc\=ph
Partial match: c
    ab\=ph
Partial match: 
    abc\=ps
 0: c
    ab\=ps
 0: 

/c++(?<=[bc])/
    abc\=ph
Partial match: c
    ab\=ph
Partial match: 

/(?<=(?=.(?<=x)))/
    abx
 0: 
    ab\=ph
Partial match: 
    bxyz 
 0: 
    xyz
 0: 
    
/\z/
   abc\=ph
Partial match: 
   abc\=ps 
 0: 
   
/\Z/
   abc\=ph
Partial match: 
   abc\=ps 
 0: 
   abc\n\=ph
Partial match: \x0a
   abc\n\=ps
 0: 

/(?![ab]).*/
    ab\=ph
Partial match: 

/c*+/
    ab\=ph,offset=2
Partial match: 

/\A\s*(a|(?:[^`]{28500}){4})/I
Capture group count = 1
Max lookbehind = 1
Compile options: <none>
Overall options: anchored
Subject length lower bound = 1
    a
 0: a
 1: a

/\A\s*((?:[^`]{28500}){4})/I
Capture group count = 1
Max lookbehind = 1
Compile options: <none>
Overall options: anchored
Subject length lower bound = 65535

/\A\s*((?:[^`]{28500}){4}|a)/I
Capture group count = 1
Max lookbehind = 1
Compile options: <none>
Overall options: anchored
Subject length lower bound = 1
    a
 0: a
 1: a

/(?<A>a)(?(<A>)b)((?<=b).*)/B
------------------------------------------------------------------
        Bra
        CBra 1
        a
        Ket
        Cond
      1 Cond ref
        b
        Ket
        CBra 2
        Assert back
        Reverse
        b
        Ket
        Any*+
        Ket
        Ket
        End
------------------------------------------------------------------

/(?(1)b)((?<=b).*)/B
------------------------------------------------------------------
        Bra
        Cond
      1 Cond ref
        b
        Ket
        CBra 1
        Assert back
        Reverse
        b
        Ket
        Any*+
        Ket
        Ket
        End
------------------------------------------------------------------

/(?(R1)b)((?<=b).*)/B
------------------------------------------------------------------
        Bra
        Cond
        Cond recurse 1
        b
        Ket
        CBra 1
        Assert back
        Reverse
        b
        Ket
        Any*+
        Ket
        Ket
        End
------------------------------------------------------------------

/(?(DEFINE)b)((?<=b).*)/B
------------------------------------------------------------------
        Bra
        Cond
        Cond false
        b
        Ket
        CBra 1
        Assert back
        Reverse
        b
        Ket
        Any*+
        Ket
        Ket
        End
------------------------------------------------------------------

/(?(VERSION=10.4)b)((?<=b).*)/B
------------------------------------------------------------------
        Bra
        Cond
        Cond false
        b
        Ket
        CBra 1
        Assert back
        Reverse
        b
        Ket
        Any*+
        Ket
        Ket
        End
------------------------------------------------------------------

/[aA]b[cC]/IB
------------------------------------------------------------------
        Bra
     /i a
        b
     /i c
        Ket
        End
------------------------------------------------------------------
Capture group count = 0
First code unit = 'a' (caseless)
Last code unit = 'c' (caseless)
Subject length lower bound = 3

/[cc]abcd/I
Capture group count = 0
First code unit = 'c'
Last code unit = 'd'
Subject length lower bound = 5

/[Cc]abcd/I
Capture group count = 0
First code unit = 'C' (caseless)
Last code unit = 'd'
Subject length lower bound = 5

/[c]abcd/I
Capture group count = 0
First code unit = 'c'
Last code unit = 'd'
Subject length lower bound = 5

/(?:c|C)abcd/I
Capture group count = 0
First code unit = 'C' (caseless)
Last code unit = 'd'
Subject length lower bound = 5

/(a)?a/I
Capture group count = 1
Starting code units: a 
Last code unit = 'a'
Subject length lower bound = 1
    manm
 0: a

/^(?|(\*)(*napla:\S*_(\2?+.+))|(\w)(?=\S*_(\2?+\1)))+_\2$/
    *abc_12345abc
 0: *abc_12345abc
 1: c
 2: 12345abc

/^(?|(\*)(*napla:\S*_(\3?+.+))|(\w)(?=\S*_((\2?+\1))))+_\2$/
    *abc_12345abc
 0: *abc_12345abc
 1: c
 2: 12345abc
 3: 12345abc

/^((\1+)(?C)|\d)+133X$/
    111133X\=callout_capture
Callout 0: last capture = 2
 1: 1
 2: 111
--->111133X
    ^   ^       |
Callout 0: last capture = 2
 1: 3
 2: 3
--->111133X
    ^     ^     |
Callout 0: last capture = 2
 1: 1
 2: 11
--->111133X
    ^  ^        |
Callout 0: last capture = 2
 1: 3
 2: 3
--->111133X
    ^     ^     |
 0: 111133X
 1: 11
 2: 11

/abc/replace=xyz,substitute_replacement_only
    123abc456
 1: xyz

/a(?<ONE>b)c(?<TWO>d)e/g,replace=X$ONE+${TWO}Z,substitute_replacement_only
    "abcde-abcde-"
 2: Xb+dZXb+dZ
     
/a(b)c|xyz/g,replace=<$0>,substitute_callout,substitute_replacement_only
    abcdefabcpqr                
 1(2) Old 0 3 "abc" New 0 5 "<abc>"
 2(2) Old 6 9 "abc" New 5 10 "<abc>"
 2: <abc><abc>
    abxyzpqrabcxyz              
 1(1) Old 2 5 "xyz" New 0 5 "<xyz>"
 2(2) Old 8 11 "abc" New 5 10 "<abc>"
 3(1) Old 11 14 "xyz" New 10 15 "<xyz>"
 3: <xyz><abc><xyz>
    12abc34xyz99abc55\=substitute_stop=2                          
 1(2) Old 2 5 "abc" New 0 5 "<abc>"
 2(1) Old 7 10 "xyz" New 5 10 "<xyz> STOPPED"
 2: <abc>
    12abc34xyz99abc55\=substitute_skip=1
 1(2) Old 2 5 "abc" New 0 5 "<abc> SKIPPED"
 2(1) Old 7 10 "xyz" New 0 5 "<xyz>"
 3(2) Old 12 15 "abc" New 5 10 "<abc>"
 3: <xyz><abc>
    12abc34xyz99abc55\=substitute_skip=2
 1(2) Old 2 5 "abc" New 0 5 "<abc>"
 2(1) Old 7 10 "xyz" New 5 10 "<xyz> SKIPPED"
 3(2) Old 12 15 "abc" New 5 10 "<abc>"
 3: <abc><abc>

/a(..)d/replace=>$1<,substitute_matched
    xyzabcdxyzabcdxyz
 1: xyz>bc<xyzabcdxyz
    xyzabcdxyzabcdxyz\=ovector=2
 1: xyz>bc<xyzabcdxyz
\= Expect error     
    xyzabcdxyzabcdxyz\=ovector=1
Failed: error -54 at offset 3 in replacement: requested value is not available

/a(..)d/g,replace=>$1<,substitute_matched
    xyzabcdxyzabcdxyz
 2: xyz>bc<xyz>bc<xyz
    xyzabcdxyzabcdxyz\=ovector=2
 2: xyz>bc<xyz>bc<xyz
\= Expect error     
    xyzabcdxyzabcdxyz\=ovector=1
Failed: error -54 at offset 3 in replacement: requested value is not available
    xyzabcdxyzabcdxyz\=ovector=1,substitute_unset_empty
Failed: error -54 at offset 3 in replacement: requested value is not available

/55|a(..)d/g,replace=>$1<,substitute_matched
    xyz55abcdxyzabcdxyz\=ovector=2,substitute_unset_empty
 3: xyz><>bc<xyz>bc<xyz
\= Expect error     
    xyz55abcdxyzabcdxyz\=ovector=2
Failed: error -55 at offset 3 in replacement: requested value is not set

/55|a(..)d/replace=>$1<,substitute_matched
    xyz55abcdxyzabcdxyz\=ovector=2,substitute_unset_empty
 1: xyz><abcdxyzabcdxyz

/55|a(..)d/replace=>$1<
    xyz55abcdxyzabcdxyz\=ovector=2,substitute_unset_empty
 1: xyz><abcdxyzabcdxyz

/55|a(..)d/g,replace=>$1<
    xyz55abcdxyzabcdxyz\=ovector=2,substitute_unset_empty
 3: xyz><>bc<xyz>bc<xyz
    
/abc/replace=,caseless
    XabcY
 0: abc
    XABCY 
 0: ABC

/abc/replace=[4],caseless
    XabcY
 1: XY
    XABCY 
 1: XY

/abc/replace=*,caseless
    XabcY
 1: X*Y
    XABCY
 1: X*Y
    XabcY\=replace=  
 0: abc

# Expect non-fixed-length error

"(?<=X(?(DEFINE)(.*))(?1))."
Failed: error 125 at offset 0: lookbehind assertion is not fixed length

/\sxxx\s/tables=1
\= Expect no match
    AB\x{85}xxx\x{a0}XYZ
No match

/\sxxx\s/tables=2
    AB\x{85}xxx\x{a0}XYZ
 0: \x85xxx\xa0

/^\w+/tables=2
    cole
 0: \xc3

/^\w+/tables=3
** 'Tables = 3' is invalid: binary tables have not been loaded
    cole

#loadtables ./testbtables

/^\w+/tables=3
    cole
 0: \xc3

/"(*MARK:>" 00 "<).."/hex,mark,no_start_optimize
    AB
 0: AB
MK: >\x00<
    A\=ph 
Partial match, mark=>\x00<: A
\= Expect no match
    A
No match, mark = >\x00<

/"(*MARK:>" 00 "<).(?C1)."/hex,mark,no_start_optimize
    AB
--->AB
  1 ^^     .
Latest Mark: >\x00<
 0: AB
MK: >\x00<

/(?(VERSION=0.0/
Failed: error 179 at offset 14: syntax error or number too big in (?(VERSION condition

# Perl has made \K in lookarounds an error. At the moment PCRE2 still accepts.

/(?=a\Kb)ab/
    ab 
 0: b

/(?!a\Kb)ac/
    ac 
 0: ac
    
/^abc(?<=b\Kc)d/
    abcd
 0: cd

/^abc(?<!b\Kq)d/
    abcd
 0: abcd
    
# --------- 

# End of testinput2
Error -70: PCRE2_ERROR_BADDATA (unknown error number)
Error -62: bad serialized data
Error -2: partial match
Error -1: no match
Error 0: PCRE2_ERROR_BADDATA (unknown error number)
Error 100: no error
Error 101: \ at end of pattern
Error 191: PCRE2_EXTRA_ALLOW_SURROGATE_ESCAPES is not allowed in UTF-16 mode
Error 200: PCRE2_ERROR_BADDATA (unknown error number)
